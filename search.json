[{"title":"RDMA 学习笔记","date":"2022-10-10T15:50:06.000Z","url":"/2022/10/10/rdma/rdma-notes/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["PDSL","/tags/PDSL/"],["RDMA","/tags/RDMA/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"知乎专题文章 rdma杂谈，这个写得太好了，可以先看知乎看一两节，再看tutorial，再看回来 tutorial 很多都是我复制的 RDMA概述回忆一下组原有个dma，设备把数据直接发送到内存，不需要cpu参与 但是如果两台机器要发消息，就要通过传统网络栈，用户空间内存通过cpu拷贝到内核空间内存，内核空间内存dma到网卡，才能用网卡发送出去；接受的时候也是。 rdma：remote direct memory access 从一个主机的内存直接访问另一个主机的内存 将rdma协议固化到网卡上 优势： 零拷贝（不需要用户空间内核空间来回拷贝） 内核旁路 不需要cpu干预 消息基于事务（数据不是流而是离散的） 支持分散聚合条目 三种硬件实现 InfiniBand/IB，全新协议，全新交换机网卡 RDMA over Ethernet/ RoCE，普通以太网交换机，新网卡(pdsl用这一套) v1基于以太网交换机 v2基于udp iWARP/RDMA over TCP 比较基于传统以太网与RDMA技术的通信 注意的重点：陷入内核态、网卡DMA拷贝 至于rdma，也不是完全离开了cpu和内核，控制还是需要一点的。 RDMA基本元素和缩写（待补充）好好看，好好背 WQ work queue，其中的元素叫WQE work queue entry，可以理解为任务说明。这个是概念。它们的实例是SQ send queue, RQ receive queue SQ和RQ组成QP queue pair，这才是通信的基本单位。QP有编号，称为QPN.一个进程可能有好几对qp 有SQR shared receive queue（不是s&amp;r q），几个qp共享一个rq，因为使用rq的情况小 CQ completion queue，自然也有CQE。 WQ是软件push硬件pop，CQ是硬件push软件pop WR是work request，WC是work completion，是WQE和CQE在用户层的映射，用户收发的也是它们。而wqe和cqe其实是驱动的概念。 后面提到的术语： QPC queue pair context，qp上下文，标识着qp的连接信息 MR memory region（见第六节） HCA host channel adapter 宿主通道适配器，可以理解为硬件部分 L_KEY（Local Key）和R_KEY（Remote Key），保障本端远端内存访问权限 PD protection domain PD像是一个容纳了各种资源（QP、MR等）的“容器”，将这些资源纳入自己的保护范围内，避免他们被未经授权的访问。 GID Global Identifier 全局id AH Address Handle cm communication management 建链用 RDMA操作类型双端操作：一端进行send，另一端必须进行recv，收端要先下发wqe。 write：本端主动写入远端内存。除了准备阶段，远端cpu不参与 本端是通过虚拟地址读写远端内存的，而虚拟地址到物理地址转换是rdma网卡干的。 RDMA WRITE/READ才是大量传输数据时所应用的操作类型，SEND/RECV通常只是用来传输一些控制信息。 RDMA基本服务类型就像tcpip有tcp udp一样，rdma也有以可靠/不可靠、连接/数据包区分的四种服务类型 可靠服务在发送和接受者之间保证了信息最多只会传递一次，并且能够保证其按照发送顺序完整的被接收 应答机制 校验机制 保序机制 对于基于连接的服务来说，每个QP都和另一个远端节点相关联。在这种情况下，QP Context中包含有远端节点的QP信息。在建立通信的过程中，两个节点会交换包括稍后用于通信的QP在内的对端信息 QPC 即QP context ，QP 上下文。 在连接服务类型中的每个QP，都和唯一的另一个QP建立了连接，也就是说QP下发的每个WQE的目的地都是唯一的。 对于数据包来说，不会保存远端节点 RC和UD使用最多，可以类比为tcp udp RDMA之Memory Region 实现虚拟地址与物理地址转换注册MR的过程中，硬件会在内存中创建并填写一个VA to PA的映射表，这样需要的时候就能通过查表把VA转换成PA了 首先本端APP会下发一个WQE给HCA，告知HCA，用于存放待发送数据的本地Buffer的虚拟地址，以及即将写入的对端数据Buffer的虚拟地址。 本端HCA查询VA-&gt;PA映射表，得知待发数据的物理地址，然后从内存中拿到数据，组装数据包并发送出去。 对端HCA收到了数据包，从中解析出了目的VA。 对端HCA通过存储在本地内存中的VA-&gt;PA映射表，查到真实的物理地址，核对权限无误后，将数据存放到内存中。 对于远端节点来说，地址转换和写入内存都不需要cpu参与（下发wqe也许需要） 控制HCA访问内存的权限建链的时候，要知道远端节点的可用va和rkey，是通过先建立链路交换而实现的（cm，socket） 避免换页由于HCA经常会绕过CPU对用户提供的VA所指向的物理内存区域进行读写，如果因为cpu换页前后的VA-PA映射关系发生改变，前文提到的VA-&gt;PA映射表将失去意义，HCA将无法找到正确的物理地址。注册MR时”Pin”住这块内存就好了。 RDMA之Protection Domain一个节点中可以定义多个保护域，各个PD所容纳的资源彼此隔离，无法一起使用。 每个节点都至少要有一个PD，每个QP都必须属于一个PD，每个MR也必须属于一个PD。 PD是本地概念，仅存在于节点内部，对其他节点是不可见的；而MR是对本端和对端都可见的。 RDMA之Address Handleqpn是每个qp独立维护的，并不是整个网络唯一的。整个网络唯一的是gid. RC建链以后，对端信息存在qpc里。ud是在wqe中填写好对端地址。地址指的是gid、端口啥的。 这个对端地址不是直接填，而是通过AH来索引。AH就像一个地址簿 RDMA之queue pairQPC主要是给硬件看的，也会用来在软硬件之间同步qp信息 qpn为0 1 是特殊的，qp1可以用于cm communication management 控制面来说，qp有增删改查操作，类似ibv_create_qp()的样子 数据面来说，一个qp对上层只有两种接口，用来向qp中填写发送和接受请求。这里的发送不是send，而是一次通信过程的发起放。例如send write read，，， 绿色正常态，红色错误态 RDMA之Completion Queue如果一个WQE对应的CQE没有产生，那么这个WQE就会一直被认为还未处理完 同一个WQ中的WQE，其对应的CQE间是保序的 在RDMA协议中，CQE就相当于是网卡收到的数据包，RDMA硬件把它传递给CPU去处理。RDMA框架定义了两种对上层的接口，分别是poll和notify，对应着传统网卡轮询和中断模式。 RDMA之Shared Receive Queue通常来说sq任务数量远大于rq（write不需要rqe） RDMA之memory window每个MW都会绑定（称为bind）在一个已经注册的MR上，但是它相比于MR可以提供更灵活的权限控制。MW可以粗略理解为是MR的子集，一个MR上可以划分出很多MW，每个MW都可以设置自己的权限。 ​ rdma-tutorial 阅读 先看example1，主要就是看代码，不需要写东西。试着编译一下 在实验室s33服务器checkout到对应提交，然后make，提示两个错误 atoi，要用stdlib.h 找不到ibv_xxx函数，链接命令要 -libverbs 在试图跑example1的时候，会出现create_qp参数错误的报错。不好debug。翻一下pr issue， 这个pr里面fix了一些RoCE的issue，我记得我们实验室刚好是roce,,, 把他clone下来，使用-w -Wno-address-of-packed-membe屏蔽掉一些报错，就可以运行了。 里面有一些参数，dev_index是ibv_devinfo命令列出的设备索引，服务器有两台，server/client我填了0/1 gid_index 是 ibv_devinfo -v -d mlx5_XXX显示出的索引，我看到了4个，所以都填了3，这个随缘吧 测试命令： 上面的是服务端：message大小64，8个消息并发，监听7283端口，dev_index=0，gid_index=3，&amp;为后台运行 下面的是客户端。测试是把他们放在一台服务器跑了，实际可能可以放好几台分开跑吧 如果看不到输出，像是卡在那里，两个log都不动，也不怕。打开debug模式，可以看到一直在发包，不过要发1000000个才结束，还是要很久的。 我觉得没有太大的必要跑前面的example，重点在阅读代码 ib_write_bw测试rdma写贷款bandwidth"},{"title":"Redis 学习笔记","date":"2022-09-02T22:31:17.000Z","url":"/2022/09/02/programming/redis-notes/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["redis","/tags/redis/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"基于内存的nosql数据库 NoSQL 认识 水平扩展：不改动数据库表结构，通过对表中数据的拆分而达到分片的目的 垂直扩展：将表和表分离，或者改动表结构，依照訪问的差异将某些列拆分出去。 另一种解释：水平方向的添加更多的机器，在垂直的方向上添加更多的资源。"},{"title":"旋元祐英语语法链接","date":"2022-08-19T11:30:47.000Z","url":"/2022/08/19/english/xuanyuanyou-english/","tags":[["英语","/tags/%E8%8B%B1%E8%AF%AD/"]],"categories":[["英语","/categories/%E8%8B%B1%E8%AF%AD/"]],"content":"书的链接  配套习题  有习题的老书 "},{"title":"Raft 学习笔记与资料摘编","date":"2022-07-03T14:31:00.000Z","url":"/2022/07/03/tinykv/raft/","tags":[["Raft","/tags/Raft/"],["TinyKV","/tags/TinyKV/"],["分布式","/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"重新做一遍 TinyKV，立志好好学 Raft 链接Raft博士论文翻译 Raft博士论文原版 etcd中的raft实现 raft在etcd中的实现，更好 Raft 基础term 任期，index 索引，commit 提交，apply 应用 Raft 通过首先选举一个 leader ，然后让 leader 完全负责管理复制的日志来实现一致性。leader 从客户端接收日志条目，再把其复制到其他服务器上，并告诉服务器何时可以安全地将日志条目应用于其状态机。 拥有 leader 大大简化了复制日志的管理。例如， leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都以简单的方式从 leader 流向其他服务器。 leader 可能会失败或与其他服务器断开连接，在这种情况下，将选举出新的 leader。 通过 leader 机制，raft 被分为三个小问题： leader 选举：启动集群时以及现有 leader 失败时必须选出新的 leader 日志复制：leader 必须接受来自客户端的日志条目，并在整个集群中复制它们，迫使其他日志与其自己的日志一致 安全性：下文 Raft 的保证中的状态机安全：如果一个服务器在它的状态机上 apply 了一个给定 index 的日志条目，那么其他服务器不会为同一 index apply 不同的日志条目 Raft 的保证 选举安全：一个给定 term 内最多有一个 leader leader 只 append：一个 leader 从不覆盖、删除它日志中的条目，它只是 append 日志匹配：如果两份日志在某个条目有相同的 index 和 term，那么从开头到这个 index 的日志都相同 leader 完备：如果一个日志条目在某一特定 term 中被 commit，那么更高 term 的 leader 的日志中都会出现这个条目 状态机安全：如果一个服务器在它的状态机上 apply 了一个给定 index 的日志条目，那么其他服务器不会为同一 index apply 不同的日志条目。 leader 选举状态的变迁在任何时刻，每一个服务器节点都处于这三个状态之一：leader candidate follower。通常情况下，系统中一个是 leader，其他的是 follower。candidate 是选举的时候才有的。 follower 不发送请求，只是响应来自 leader candidate 的请求。leader 处理所有的请求。如果客户端把请求发给了 follower，follower 会把请求重定向给 leader 让他处理。 领导者一直是领导者，直到它宕机。 处理 rpc 时考虑 term 的基本原则基本的 rpc有两种：请求投票 rpc，附加日志 rpc（包含心跳包） 每个节点存储当前 term，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前 term： 如果一个服务器的当前 term 比其他人小，那么他会更新自己的 term 到较大的 term 值。此外： 如果一个候选人或者领导者发现自己的 term 过期了，那么他会立即恢复成 follower 状态（但是只有在请求明确表明自己是 leader 的情况下才会设置自己的 leader） 如果一个节点接收到一个包含过期的 term 的请求，那么他会直接拒绝这个请求。 服务器程序启动的时候，大家都是 follower。只要一个 follower 不断从 leader candidate 处接收到有效的 rpc 就一直是 follower。 超时选举leader 一直向所有跟随者发送心跳包（博士论文中就是不含日志的附加日志 rpc，tinykv 中不是）来维持权威。因此如果一个 follower 一段时间没有收到有效 rpc，就出现了选举超时，随后发起选举。 选举的过程： follower 转换为 candidate，自增 term，给自己投票，重置计时器 并行向其他节点发送请求投票 rpc，直到发生三件事情中的任何一件： 赢得选举。这个 candidate 从大多数服务器节点获得了针对同一 term 的选票，他就赢了，立刻成为 leader，发送心跳（考虑到一个节点最多只会对一个 term 投出一张选票，先来先服务，保证了选举安全） 其他节点成为 leader。如果收到其他节点宣称他是 leader 的附加日志 rpc，那么如果这个 leader 的 term（包含在此次的 RPC中）不小于 candidate 当前的 term，那么 candidate 会承认 leader 合法并回到 follower 状态。 如果此次 RPC 中的 term 比自己小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。 随机的选举超时时间内没有任何人获胜。再自增 term。发起选举。 日志复制客户端的请求成为 propose rpc，包含一条或多条被复制状态机执行的指令。leader 将条目附加到日志中并发起附加日志 rpc，让其他节点去复制这条日志。这条日志被安全复制的时候，leader 会 apply 这条日志并返回结果给客户端。 如果出现了网络丢包或者运行缓慢，leader 可能已经 apply 了日志并回复了客户端，但还是会不断重复尝试附加日志 rpc（比如心跳包返回的结果发现还有日志要附加） 当 leader 将日志条目复制到绝大部分节点的时候，日志条目就会被 commit（同时意味着之前的日志条目也 commit 了）。commitIndex 也会被包含到附加日志 rpc 和心跳包中。 如果 follower 知道一条日志条目 commit 了，就会 apply 这条日志条目。 回到前面的日志匹配：如果两份日志在某个条目有相同的 index 和 term，那么从开头到这个 index 的日志都相同。这个特性是因为在发送附加日志 RPC 的时候，leader 会把新的日志条目紧接着之前的条目的 index 和 term 包含在里面。如果 follower 在它的日志中找不到包含相同 index 和 term 的条目，那么他就会拒绝接收新的日志条目。 极端情况下，follower 可能会丢失一些在新的 leader 中有的日志条目，他也可能拥有一些 leader 没有的日志条目。因此，leader 要找到两者最后达成一致的地方。他会对每一个跟随者维护 nextIndex，表示下一个需要发送给 follower 的日志的 index。也会维护一个 matchIndex，表示两者达成一致的 index。 ！！要检查：成为 leader 时所有 nextIndex 为自己最后一条 index + 1。如果有一个 follower 日志和 leader 有冲突，那么 follower 会拒绝附加日志 rpc，leader 会减小对它的 nextIndex 并重试。最终 nextIndex 会在某个位置使 leader 和 follower 的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把 follower 冲突的日志条目全部删除并且加上 leader 的日志。一旦附加日志 RPC 成功，那么 follower 的日志就会和 leader 保持一致，并且在接下来的 term 里一直继续保持。 实际上，leader 不会一上来就发送附加日志 rpc，而是通过心跳包协调 nextIndex。当协调到的 matchIndex 恰好比 nextIndex 小1，就立刻发送附加日志 rpc。"},{"title":"TinyKV 课程报告","date":"2022-07-03T14:31:00.000Z","url":"/2022/07/03/tinykv/notes/","tags":[["Raft","/tags/Raft/"],["TinyKV","/tags/TinyKV/"],["分布式","/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"代码在  ，96.1分。 因为我电脑的 tmpfs 不够大，我在 kv/test_raftstore/cluster.go:61 中把测试目录设置在 /home/poorpool/tinykvtmp 了，提交的时候我把它给删了。如果要想在个人笔记本上跑，可能要这么设置一下，PingCAP 评测的时候应该不需要。 1 2a 2b 2c 3a 3c 4a 4b 4c 一定可以一次跑通，3b 有15%的概率会 fail 一个点，85%的概率一次跑通 日程表说明：我以前做过一遍 TinyKV，对 Raft 和 Percolator 也有一定的了解。这次是为了拿 TinyKV 抵学校的系统能力综合培养，所以重做了一遍，整洁了代码，整洁了逻辑。 下面的时间是我这一次的耗时，如果算上我以前做第一次的时间，总耗时大概在 25 个整天。 20220702 下载项目，完成 1 20220703 完成 2aa，2ab，但是后面一直在实习，没时间写，忘差不多了 20220808 因为以前写的太糟糕，把代码删了重写，完成了 2aa 20220809 完成了 2ab、2ac 20220810-11 重构代码，加注释，补充 2a 笔记 20220812 阅读 2b 文档，完成代码，能通过 2b 一半的测试 20220813 能通过另一半的测试，完善 2b 笔记，优化 2b 代码；开始写 2c 20220814 完成 2c，完成 3a，完成 3b（留下了一些 bug） 20220815 调 3b bug，进行批量测试，虽然不能 100% 跑过，但是差不多了。休息 20220816 完善 2c 3a 3b 文档，完成 3c 20220817 完善 3c 4a 4b 4c 文档 project 1要支持四个基本的操作 Put/Delete/Get/Scan，键是key+column。 程序入口在 kv/main.go，会根据是否 raft 来决定使用 raft_storage 还是 standalone_storage（本节内容），最终提供一个 grpc 服务，定义在 proto/proto/tinykvpb.proto proto/proto/kvrpcpb.proto 中。 需要实现的文件在 kv/storage/standalone_storage/standalone_storage.go 要实现的接口 实现的结构体 在内部维护一个 badger db，使用 engine_util 中的 CreateDB。写的时候将 []storage.Modify 转换为 engine_util.WriteBatch，读的时候获取 badger 事务调用 engine_util 中的函数即可。注意读要求一致性所以要开事务，最后记得 Discard project 2project 2a因为一年半以前写过一次 TinyKv，所以这次把 raft 论文复习了一遍直接就开始写了。写之前看一下网上对 etcd raft 实现的分析，可以学到很多思路。 project 2aa、2ab日志首先最好具备优雅地打印日志的能力，比如用一个开关控制自己的日志是否打印。我在 log/log.go 中写了一个 DInfo 函数，由 debugSwitch 控制调试输出，并且因为打印到文件里头，可选地关掉了日志高亮。最好是一开始就能打好日志，后面调试才方便。 连起来看2aa 实现了领导人选举，2ab 实现了日志复制，但是它们的边界其实没有特别清楚，比如说领导人选举的时候，要确保自己的日志是比较新的，所以两部分会有一点重合。如果按照测试写过去，容易出现 2ab 过了但是 2aa 挂了的问题。因此两个最好连起来看。 我记得我就是完成了 2ab 以后发现 TestLeaderCycle2aa过不了，打印日志，发现测试里有三个人轮流选举当 leader 的过程，1 可以获得 1 2 3 的支持，2 可以获得 2 3 的支持，3 只能得到自己的支持。原因是 3 的日志不够新，追溯日志，是我本来在 becomeLeader 里头添加 no-op 日志条目却没有把他们 append 出去，导致日志不是最新的。 创建在创建 RaftLog、Raft 的时候，要注意恢复 hardState，正确地处理好各个值的初始化问题。我印象比较深刻的有： 从 HardState 中恢复 term vote commit 创建的时候不要调用 becomeFollower 把 vote 信息给覆盖了，，， 不要漏了 config 中的 applied，感觉是后面才会用到，这里容易忽略掉 commit stabled 这些都是 index，不是数组下标 重构奥义我记得我第一次写 TinyKV 的时候，raft.go 一个文件一千多行，函数乱飞，翻起来都不好翻，日志也不好打。这次我吸取上一次的教训，立志精进代码风格： 把 raft.go 拆了 raft.go 处理创建、状态转换、消息分发给处理函数 raft_sender.go 发消息，每个 MessageType 写一个函数，最终统一调用 send() 来发消息，这样能够统一打日志（非常关键） raft_handler.go 用来处理收到的信息 函数摆好顺序，按照 MessageType 排序，工具函数放在调用函数的前头一眼就能看见 注释！注释！注释！ 不要追求速度，写完以后重构代码，细化不合理的地方，完善文档。不要像拖拉机一样坑吭吭吭就往下写 下面主要写一下遇到的问题和思考。raft 流程网上已经很充分了。 对 append no-op entry 的思考raft 要求 leader 不能提交之前任期的日志条目，或者说，提交的日志条目必须包含自己的任期，再说得清楚一些，提交的日志条目必须包含当前最新的任期（raft 论文有很好的例子）。为了在本任期没有收到同步请求的情况下也要能提交之前的日志，应当在成为 leader 的时候立刻 propose 一个空条目并 append 下去。 对收到其他任期的消息的思考过期消息直接丢弃即可（但是返回一个 response 提示它过期了会不会更好一些） 对于来自大任期的消息，不能简单地接受领导，只有他明确说明自己是领导，才接受。我以前想出来一个很好的例子：1 2 | 3 隔离，1 term 6 leader, 3 term 7 candidate 。解除隔离以后，1 收到了 3 的请求投票 rpc，要更新自己的任期，但是不能接受对方的领导。只有明确声明自己是领导才承认，即 Append 和 Heartbeat 其他小问题 leader 收到同任期 candidate 投票请求也要投拒绝票，而不是 drop message append 日志的时候有很多细节要想清楚，例如 leader.commit &gt; my.commit 时， commit = min(leader.commit, leader 给我的 lastIndex（不是我的最后一个 lastIndex）)，因为你返回的 match 不可以比 leader 现在 lastIndex 还大 收到心跳要发回复，收到心跳回复要检查 progress 并确定要不要发 append commit 增加了，才广播 append project 2ac稍微简单一些，实现 raft 的上层节点 RawNode，返回 Ready，代表上次处理完 Ready 以后和这次的更改。为此要保存下来之前的 SoftState 和 HardState。在返回新 Ready 时，如果 SoftState 和以前的不一样，才返回有值的 SoftState，否则返回空。 出 Ready 时，还会清空消息。Advance 更新 RawNode 的各种 State，处理日志 stabled applied project 2b从 2b 开始，文档、测试和实现之间的 gap 就有点大了。有两个文档很推荐看，不要闭门造车，要见贤思齐（不是抄袭） TinyKV 白皮书（力荐） 一个学长写的笔记（也很好） 这一章最终要体现在 kv/raftstore/peer_storage.go kv/raftstore/peer_msg_handler.go，代码是在这两个文件里头写的。并且很有可能返工修改 2a。 结构体关系首先了解一下这些结构体的相互关系： 上面这一串，整体是作为 RaftStorage，RaftStorage 实现了我们在实验一里头实现的接口： 它收到请求以后，会一通分发，进入 peer_msg_handler 处理消息。 peerMsgHandler 基于 peer： 注意这里头还有一个 metapb.Peer，存放了 peer id 和 store id。 回到刚才说的 peer，它有一个 RaftGroup，意味着它就是 raft 中的一个节点。这个节点的 Storage，就是 PeerStorage： PeerStorage 实现了我们在 Raft 中的 Storage 接口： peer_msg_handler 的 proposeRaftCommand()注意：这里和后面的代码都是经过摘取的，真实的代码中肯定还包含了错误校验等一系列其他繁琐的事情。 上面提到了，读写请求最后都会到达 proposeRaftCommand，在这个函数中把读写请求序列化作为一条日志条目 propose 进 Raft，让它去 append、commit、apply。我们要等日志 apply 的时候才能返回给客户端 response。考虑到 apply 的时候也是在这个 peer_msg_handler 里面，我们给他维护一个 proposal 结构，能够得到日志条目和回调的对应关系。 也就是说，我们在这个函数里干的事情主要是（省略了错误处理） 代码都比较好理解。appendProposal 是我自己写的记录回调的函数，理论上来说应该使用日志条目 index 和 term，但是在 raft 之外的上层无法取得，我们直接取最后一条日志后面的 index 就好： 增加回调是一个麻烦的事情，因为我们都知道并不是 propose 了的日志条目就会被 commit 被 apply，有可能被覆盖掉。我们希望 proposal 数组里头也要像日志数组里头一样干干净净，index 递增，就要在增加 proposal 的时候删除冲突的日志条目，也就是 index 大于等于当前 proposal.index 的条目都删除掉。 当然，这里不能直接删除，要把要被删除的回调都返回一个 ErrRespStaleCommand，可以理解为要求客户端重试的统一回复。 peer_msg_handler 的 HandleRaftReady()Raft 消息的最终宿命是被丢掉或者被 apply，apply 等一系列变化会体现在 Ready 中，处理的函数就是 HandleRaftReady()，它的流程大概如下： 它首先调用 peer_storage 的 SaveReadyState() 保存 raft 日志、HardState 等状态，然后把消息发送出去 hint：使用 GlobalContext 中的 Transport 来发送 Raft消息 接下来轮番应用日志，并且及时更新 ApplyState（后面停机了删除 ApplyState 的代码我忘了是哪一部分引入的了，也贴上来） hint: 应用每一条日志都要赶快更新、持久化 ApplyState，不然会造成数据不一致hint: 使用 WriteBatch 来确保写入一致性，例如，使用一个 kvWb 来同时保存 key-value 更新和 applyState 的更新 应用普通日志的代码： hint: 找不到回调也要 apply hint: snap 请求回调应该设置事务 Transaction 为 false 应用普通日志的时候，要查找回调，即顺着 proposal 数组查找到自己要的 index，并且删除没有用的回调。一定要记住，日志的匹配要求 index 和 term 都匹配： peer_storage SaveReadyState() 这里省略了对 snapshot 的处理，这是 2c 的部分了。我们回顾一下 Ready 的结构： Message、CommittedEntries 不是要保存的内容，因此只有 HardState Entries 需要保存。 peer_storage Append()Append 函数保存日志。 回忆一下这个表格： Key KeyFormat Value DB raft_log_key 0x01 0x02 region_id 0x01 log_idx Entry raft raft_state_key 0x01 0x02 region_id 0x02 RaftLocalState raft apply_state_key 0x01 0x02 region_id 0x03 RaftApplyState kv region_state_key 0x01 0x03 region_id 0x01 RegionLocalState kv 日志条目和 RaftLocalState 状态都存在 raftDB 里面，和上面的kvDB一样，都是一个单机数据库。 根据提示，保存日志要分三步走： 这里有一个 peer_storage_test.go 测试文件，可以用来辅助测一下 append 函数。 firstIndex 不从 0 开始打印了日志以后发现，firstIndex 从 5 开始，其实文档里面有说 Note that the value of both RAFT_INIT_LOG_TERM and RAFT_INIT_LOG_INDEX is 5。这样的话，我原本 RaftLog 里面没有日志的时候 lastIndex 返回的是 0，现在看来应该返回的是 firstIndex - 1。对应的 Term 也要从 storage 里头取了。 做到这里还返回去改造了 Raft 和 RaftLog，感觉以后还要接着改造，， peers 错误做 2b 的时候打日志调试，意外地发现遇到了所有人都是 leader 的诡异情况。打印构造情况，发现 c.peers 只有自己一个人，要从 confState 里面取。暂时还不清楚这个是干啥的，但是取了就可以了。 莫名其妙的 fail第一次做 tinykv 的时候遇到过这种情况，tmpfs 是基于内存的，我的内存 16g 扛不住，kv/test_raftstore/cluster.go:61 里面把临时文件夹放在 ssd 里面，现在可以跑过了，但是要自己清空测试文件夹。 getWrongValue 以及 CmdType 错误也是打日志一通观察，发现这样的一个场景： 1 2 3 4 5，起初 2 为 term 6 leader，后来 1 2 | 3 4 5，4 为 term 7 leader。2 propose 了日志 a，4 propose 了日志 b，不幸地它们 index 相同，4 的日志会覆盖 2 的，因此 2 apply 的时候也要检查 term，看记录 proposal 的时候和现在的日志的 term 是否一样。如果不检查 term，2 会 apply 4 的日志条目 b，但是回调 a，造成错误。 给 proposal 比对的时候加上 term，如果 term 和当前 term 不一样，就返回 StaleCommand。 从崩溃中恢复在可能崩溃的测试中，出现了这样的问题：unexpected raft log index: lastIndex 5 &lt; appliedIndex 3359 一看就是持久化没做好，观察 panic 的地方，是 RaftLocalState 没有保存。一通断点调试，发现 RaftLocalState 我保存之前的时候是存的指针，修改的时候，指针指向的地方值会变，就没有保存好以前的 RaftLocalState。没想到给指针搞了，，， 测试的时候自己写一个 shell 脚本，连续跑测试很多次，会很有助于调试。因为 2b 开始不是跑一遍就能测出来的了。 project 2c完成快照。比方说现在 1 2 3 4 5，5 号挂了很长时间，其他四个人都 apply 很多日志了，这时候 5 恢复，没有必要给他发送那么长的日志，直接给他发一条快照就好了。 实现快照需要稍微改造一下 raft 模块，然后在 2b 的基础上增加一些改动。 RaftLog 的改动我们引入一下 snapshotIndex snapshotTerm 的概念。2a 的 firstIndex 是第一条日志条目的 index，那 snapshotIndex 就是被归档不可用的最后一条日志条目的 index，初始化为 firstIndex - 1，对应的 Term 从 storage 中取得。 RaftLog 里面有一个 pendingSnapshot，名字顾名思义。因为它的存在，lastIndex() 什么的也要修改。比如一个新创建的 peer 被发送了 snapshot，我们就说这个 lastIndex 就是 pendingSnapshot 的 lastIndex，不能说是 0。 应用快照的时候，除了要设置各种 index，还要把现有的日志条目清空。因为应用快照就代表着完全接受快照： 这里的 applySnapshot 名字其实起得不好，它不是发生在 apply 阶段的，而是 handleSnapshot 时候被调用的，就像 handleAppend 一样。 raft 模块需要明确一下，snapshot 的地位和 append heartbeat 的地位是一样的，都是 leader 宣示自己的领导地位，因此处理 snapshot 的时候也要和 append 一样处理任期和 state。 下面的代码比较清楚了，如果取得不到日志条目，就发送快照。因为取得快照是一个耗费时间的任务，可能暂时不可用，这样的话就跳过发送。 处理快照的时候要注意，忽略 commit 不能增加的快照，这个会被认为是过期的，但是也要返回给 leader 提示，让他以为是成功更新，不然 leader 一直收不到回复，就会一直发快照而卡死。不要忘记处理 Prs。 peer_storageRaftLog 接收到 Snapshot 以后，会体现在 Ready 中，目的是更新一下各种 State，在 SaveReadyState 中自然也要添加上这一点。 ApplySnapshot() 比较复杂，但是步骤也很清晰： 删除旧信息。快照的应用让 Raft 日志条目等信息变得无用。不过，删除的时候要注意 ps.isInitialized() 才可以删除，不然会产生错误 更新 raftState、applyState、regionState。这是因为快照也可能包含新的 region 的信息 send runner.RegionTaskApply task to region worker through PeerStorage.regionSched and wait until region worker finishes. peer_msg_handler快照消息的产生、发送、处理是在 raft 模块中的。在上层 peer_msg_handler，我们实际上处理的是压缩日志请求。不同于增删改查，这是一个 adminRequest，因此也要相应在 propose 的时候做出一些调整。 首先，AdminRequest 不会和普通 Request 一起出现；压缩日志请求没有回调，所以不需要处理 proposal 相关的逻辑。 同样地，在处理 Ready 的时候，我们也要处理一下 AdminRequest 了。对应的处理逻辑文档里写得很清楚了，这里粘贴一下： 根据我的理解，ScheduleCompactLog 最终会导致 Storage 中的日志被压缩掉。因此要时不时压缩一下我们在内存中的 RaftLog 保存的日志，也就是 maybeCompact 函数（自己在 Rawnode 中调用它） 如果 storage 里头不存日志条目了，那内存中也不存了。 project 3project 3a实现领导人禅让（又叫转换），增加节点，删除节点。不难，但是可能会给 3b 埋坑，，， 领导人禅让领导人禅让基本上也可以称为 local message，因为它不会被传播。把这条消息往下 step 的时候要注意： 如果自己不是 leader，就把消息转发给 leader 我们使用 leadTransferee == 谁 来标记当前在试图禅让给谁，禅让的判定过程叫 handleTransferLeader(to uint64)， to 被删了、to 是自己，返回 更新领导人禅让计时器，记录 leadTransferee 检查 leadTransferee 日志情况。如果和自己日志一样新，就向他发送 MsgTimeoutNow，leadTransferee 收到以后会和收到 MsgHup 一样立刻开始选举 如果 leadTransferee 日志没自己新，就给他发 append 与此同时，handleAppendResponse 里面，如果接收到来自 leadTransferee 的消息，就重新调用 handleTransferLeader 检查禅让情况 需要注意的事情： 在领导人转换期间，禁止一切 propose。直接返回 ErrProposalDropped 如果 leadTransferee 挂了，就会导致领导人禅让计时器超时，这种情况下终止禅让，不然一直不能 propose 增删节点增加节点，就要更新 Prs，设置好它的 Match 和 Next（lastIndex + 1）。如果是 leader，可以考虑立刻广播心跳，因为 peer 的创建是根据消息的 to 不存在而创建的，这样可以尽快达成一致 删除节点，也要更新 Prs，也要尝试更新 commit 和广播 append project 3b如果说《春江花月夜》是诗中的诗，顶峰上的顶峰，那 3b 一定是 TinyKV 中的顶峰了，不论是它的抽象程度还是困难程度，还是找不到 bug 在哪里的痛苦，以及测试的耗时，，，做这一部分的时候要多参考参考其他人的文档，跟同学讨论讨论，上网搜索报错和 bug，时刻保持心态的平和。 3b 分为三部分，第一部分实现领导人转换，很简单不需要很多功夫，收到这个 adminRequest 的时候直接调用 RawNode 的相关方法然后返回就行，不需要 propose；第二部分实现配置变更；第三部分实现 multi-raft 的 region split 我跑了 28 次，有 4 次会 fail，每次 fail 一个点。 配置变更配置变更也是作为 AdminRequest 来到 proposeRaftCommand 的，但是因为它比较特殊，不仅要通过 Raft 同步，还要修改 Prs，为了表示区分，它在日志条目中的 Type 为 EntryType_EntryConfChange，并且有一个专门的 ProposeConfChange(cc pb.ConfChange) 方法，因此，proposeRaftCommand 处理这个 AdminRequest 也稍微有一点变化： 把 msg 也传进去，因为后面可能要捞出来检查版本。 因为我们一次只处理一个节点变更，日志条目容不得两个节点变更的未 apply 日志存在，所以要用 pendingConfIndex 确保只有一个节点变更日志等待 apply 此后同样的步骤，我们首先把内容都取出来，检查 Region 版本是否匹配。如果不匹配，说明已经过时了。 接下来，如果是增加节点，我们就 更新 region ConfVer 插入到 peer Cache 中 插入到 peer 数组中 写入 WriteBatch 如果是删除节点，则要分类讨论：删除自己就 destroyPeer()，删除别人使用和上面差不多的技法。 region splitsplit adminRequest 的地位和压缩日志一样，因此直到 apply 前，处理的方法都大差不差。 注意：引入 split 以后，get put delete 要检查 key 是否在 region 中。 split apply 的时候也要检查 key 是否在 region 中、版本对不对，步骤大概为： 创建新 region 修改当前 region 的 Version，endKey，storeMeta（记得加锁）等等 使用 ReplaceOrInsert 更新 regionRanges，也写入 WriteBatch 在当前 store 创建 peer 向路由注册 peer 向新 region 发送 start 回调 meta corruption detected 问题我参考的 ，这个问题的出现是在 destroyPeer 中，meta.regionRanges.Delete(&amp;regionItem{region: d.Region()}) == nil 导致的。删除为空，是因为新创建的 peer 没有插入到 regionRanges 中。因此要在 maybeCreatePeer() 最后面加一句 meta.regionRanges.ReplaceOrInsert(&amp;regionItem{region: peer.Region()})，这样就不会出现无效删除的问题了。 增删节点导致的 request timeout我搜索到了这个问题 ，观察日志还真是这样。比方说最后剩下 1 2，1 是 leader 要删除自己，1 send append to 2, 2 send appendResponse to 1, 1 update commit and destroy itself。考虑到 commit 更新了，1 要发给 2 commit 更新的消息，但是如果这条消息不幸被 drop 掉，2 就不知道 1 给删除了！！！此时，2 一直不知道 1 给删除了，试图发起投票，当然是无尽的失败。 我也用的邪道，在 handleAppendResponse 里面，如果要更新 commit 广播 append，就把 append 连续广播五遍，减少消息丢失的可能性，，，但是这样挺不优雅的 proposal 导致的 request timeout原来我对 proposal 处理得比较粗浅，打印出来发现它不是单调的，使用了 append rpc 类似的方法来确保它单调。但是还是有很小的概率不单调，可能是并发操作吧。 storeMeta 导致的 request timeout我发现在增删节点的时候加锁修改 storeMeta 容易增加超时几率，很迷惑，暂时不太会改，只能在这里不修改它了。参考了，不过没有用  no region 问题参考了  增加了一个方法，快速刷新 scheduler 的缓存，有效避免了 no region 问题。 project 3c完善调度器。这是一个独立的部分，可以喘一口气了，但是也要多跑几遍。 第一个要求是实现对 region 心跳的处理，在 scheduler/server/cluster.go 中的 processHeartBeat()。 首先写一个比较 region 谁更新的函数，先比较 Version 再比较 ConfVer 注意这里要使用 Get 方法，因为可能有 nil，，， 然后检查心跳是否可以接受，首先检查同 id 的 region 谁更新，然后检查和 heartbeart region 重叠的 region，新 region 要都比他们新。 然后就可以调用 PutRegion() 和 updateStoreStatusLocked()（这个函数更简单）来更新 region 情况了。 第二部分是选择一个 store，将 region 从这个 store 迁移到另一个 store。在 scheduler/server/schedulers/balance_region.go 取出所有 IsUp() 并且 DownTime 合格的 store，把他们按照 regionSize 从大到小排序 依次考察 store，对于每个 store 试图选择一个 pendingRegion 选不到就试图选择一个 followerRegion 选不到就试图选择一个 leaderRegion 还选不到就考察下一个 store 现在我们得到了要迁移的 region 和它的 store 检查 region 的 store 数量，没有超过 cluster.GetMaxReplicas() 的话，就返回。因为他可以直接创建一个 peer，而不是迁移 取得一个目标 store，要求 regionSize 尽量小，且不在 region 原来的 store 中 要求 store size 差比较大，这样迁移才有意义，也就是要 region.GetApproximateSize() &lt; 2*(fromStore.GetRegionSize()-toStore.GetRegionSize()) AllocPeer, CreateMovePeerOperator project 44a实现一个 MvccTxn，辅助后面的实现。 column family 派上用场。 CFLock 对应 Lock，写 key 没有 timestamp，在 value（lock 结构体）里面保存 Lock 的 startTs CFDefault 对应 value，写 key 包含 startTs CFWrite 对应 Write，写 key 包含 commitTs，在 value（write 结构体）里面保存 Write 的 startTs PutWrite GetLock PutLock DeleteLock DeleteValue 都比较直观（注意没有 DeleteWrite） Write 的 Get 方法有两个，CurrentWrite 从 EncodeKey(key, TsMax) 开始遍历，遍历趋势是同 key 的 commitTs 变小，然后到不同 key。把 startTs 取出来，startTs 要和 txn.StartTs 相同，才是当前事务的 Write；MostRecentWrite 也是要 seek 一下，能找到同 key 的就返回了。 GetValue 要取得在 txn.StartTs 这一刻有效的 Value，因此从 EncodeKey(key, TsMax) 找最新 Write，如果 WriteKind 为 Delete 就返回 nil，否则就取出这个 Write 的 startTs 在 CFDefault 中的值（其实我有点疑惑这里不用考虑 WriteKind 为 rollback 吗） project 4b 4c在 kv/server/server.go 中实现 KvGet KvPreWrite KvCommit，使用上面的 MvccTxn。 Percolator 事务基本形状： Prewrite。对于每一个 key，检查错误，有的话返回所有错误，没有的话 apply txn.Writes() 检查 MostRecentWrite，有没有 commitTs &gt;= txn.StartTs 的 write 的？有的话记录 Write 冲突 检查 Lock，有不是自己的 lock（lock StartTs 对不上），记录已经被锁 现在这个 key 没有问题了 给这个 key 加上锁 写入 value 到 CFDefault 中（写入 Value 发生在 PreWrite 阶段！！） CheckTxnStatus，以 primary key 为准 检查 lock 情况，如果没 lock 或者不是自己的 lock，就检查 CurrentWrite write != nil，那说明事务已经执行。通过 write 的 Kind 来设置 resp 的 commitVersion write == nil，事务不行了，向 Write 中写入 WriteKind_ROLLBACK（这里不用删除 Value，删除 value 是在 rollback） 自己的 Lock 还在，但是 lock 超时了，就向 Write 中写入 WriteKind_ROLLBACK，删 lock，删 Value 事务没问题，返回 Commit 首先使用 Latch 对 keys 统一加锁，然后对于每个 key 取 lock，如果没 lock，取得 CurrentWrite，如果已经提交就忽略，其他情况报错 不是自己的 lock，返回错误（可以重试） 写入 write Rollback 也差不多，先统一加锁，然后对于每一个 key 取 CurrentWrite，已经回滚就 continue，其他情况就 Abort 写入 write 如果自己 lock 着，就删除 value 和 lock KvResolveLock 就是取得当前 txn.StartTs 的所有 lock，根据 commitVersion 决定是提交还是回滚 KvGet 的时候可以使用 lock.IsLockedFor(req.Key, txn.StartTS, resp) 来检测 lock 冲突，还会自动设置 resp 的 Error 字段，很方便。简单来说就是如果 lock 不是自己的就报错，不然就 GetValue 返回去 KvScan 也差不多，就是要自己实现 Scanner，确保对于每一个 key 都返回一个 value，下次就是另一个 key "},{"title":"数据库笔记","date":"2022-05-29T22:41:22.000Z","url":"/2022/05/29/course/database/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"过！过！过！ 复习要点绪论文件系统vs数据库系统的特点 数据模型三个要素，层次模型，网状模型，关系模型的数据结构（zxs说前俩都没讲） 三级模式，二级映像，数据独立性 关系模型三类完整性，主码和外码，参照关系 被参照关系，参照完整性 关系代数基本运算必考！并差积……等等运算，唯独除法没出过！ SQL明确指出不考触发器、断言 查询 修改 权限 sql有关的 20% 特点 create alter drop insert delete update select 单表 多表查询 like，下划线，escape sql一定有！ 数据库安全性明确指出不单考，完整性也不单考，放在sql里头 grant revoke语句 role 权限转授 自主存取控制和强制存取控制的概念 完整性存在感不是很大 三类完整性的概念和实现 实体完整性 参照完整性很有可能考 自定义完整性 pk fk check unique not null 关系数据理论35% 明确指出不考最小覆盖、正则覆盖。 明确指出不需要判断无损连接，但是要知道分解应该满足无损连接 明确指出从来只考基本，例如闭包计算，范式级别判断，找主码 从来没考过难题，简单的一塌糊涂 属性集闭包很有可能考，因为太简单，注重过程！！！比如循环一遍发现没有变化之类的 函数依赖 公理系统 主码和找主码的过程 判断函数依赖是否成立 各个范式的判断 模式分解，分解算法都只是了解 数据库的设计 15%必考 概念设计 er图 逻辑设计 模式 外模式 物理设计 索引 聚簇索引 普通索引 重点是er转关系模式 代数优化明确指出物理优化不会单考，可能顺带问一下怎么提高某个连接查询的性能 常用变换规则，各种启发式规则，反正就是那一套 连接规则 恢复重点考系统故障，并且是带检查点的系统故障恢复，极有可能考 其他两个一个简单一个难，，， 并发控制明确指出多粒度封锁不考 并发和恢复 20% 并发操作引起的数据不一致性 封锁和封锁协议 三级封锁协议，两段锁协议 死锁，预防死锁 可串行化，冲突可串行 可能要构造各种犀利把少的情况，也可能指定锁协议 必须用表格画，每一行必须只有一条语句 第八章 存储引擎明确指出只考槽页，估计八分 绪论数据库管理系统（Database Management System-DBMS）是位于用户与操作系统之间的一层数据管理软件。MySQL等。 数据库系统DBS包括数据库DB、DBMS、数据库管理员DBA…… 文件系统与数据库系统的区别 文件系统的数据是面向某一应用的，共享性差、冗余大，独立性差，文件内部的记录虽然是有结构的，但是整体无结构，由应用程序自己控制数据。 数据库系统中的数据不再仅仅面向某一个应用，而是面向所有用户。数据的共享性高、冗余度小，具有高度的物理独立性和逻辑独立性。数据库中的数据用数据模型组织和描述，由专门的软件DBMS提供安全性、完整性、并发控制和恢复能力。 二者的联系： 二者都是计算机系统中管理数据的软件。 文件系统是操作系统的重要组织部分，而DBMS是独立于操作系统的软件。DBMS 是在操作系统的基础上实现的，数据库中数据的组织和存储是通过操作系统中文件系统来实现的，数据库最终以文件的形式存在。DBMS对数据库的任何操作最终要转化为对文件的操作。  层次模型，网状模型，关系模型层次模型： 网状模型：（相比于树，允许无双亲和多个双亲） 关系模型关系模型中数据的逻辑结构是一张二维表，它由行和列组成。列表示属性，表间的特定冗余列信息表示实体间的联系 三级模式，二级映像，数据独立性模式Schema是型的描述，不涉及具体的值，反映的是数据的结构及其联系，是相对稳定的 三级模式和二级映像： 模式Schema，数据库中全体数据的逻辑结构和特征的描述。一个数据库只有一个模式，与数据的物理存储细节和硬件环境无关，与具体的应用程序、开发工具及高级程序设计语言无关. 外模式External Schema，数据库用户使用的局部数据的逻辑结构和特征的描述。一个数据库可能对应有多个外模式。 内模式Internal Schema，数据物理结构和存储方式的描述，一个数据库也只有一个内模式。 当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性 数据模型，数据库系统的结构和组成ER图： 关系：对应通常说的一张表。 元组：表中的一行即为一个元组。 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名。 主码（Key）：表中的某个属性组，它可以唯一确定一个元组。 域（Domain）：属性的取值范围。 分量：元组中的一个属性值。 关系模式：对关系的描述，学生（学号，姓名，年龄，性别，系，年级） 关系数据库三类关系，三类完整性三类关系：基本关系（实际存在的）、查询表、视图表。 实体完整性：所有主属性不能取空值。 参照完整性：参照关系R，被参照关系S，R的一组属性F和S的主码$K_s$对应，则F为R的外码。则R中每个元组在F上的值要么为空值，要么等于S中某个元组的主码值。 用户定义的完整性。 关系数据结构域、笛卡尔积顾名思义。笛卡尔积中每一个元素$(d_1,d_2,\\ldots,d_n)$称为元组，其中$d_i$称为分量。 笛卡尔积的基数是所有域的大小的乘积。 关系是笛卡尔积的子集。$R(D1,D2,\\ldots,Dn)$，R为关系名，n为关系的目/度。 总之，关系是一个二维表。 若关系中的某一属性组的值能唯一地标识一个元组，且去掉这组属性中的任何属性或属性组都不能唯一标识元组，则称该属性组为候选码。候选码的诸属性称为主属性，不包含在任何侯选码中的属性称为非码属性。 若一个关系有多个候选码，则选定其中一个为主码（Primary key） 关系R的属性组，跟与R联系的另一关系S中的码相对应，则称这个属性组为外码。 关系代数分量和象集若记t是R的一个元组，$t[A_i]$是t在属性$A_i$上的分量，A是属性们中的一部分，$t[A]$表示元组t在属性组A上的分量的集合，$\\bar A$表示去掉A的k属性组。 象集表示关系R中属性组X上值为x的诸元组在属性组Z上分量的集合。 （简单来说就是选择）。象集一般用$A_{b}$表示，用下面的投影表示就是$\\Pi_{A}(\\sigma_{B=b}(R))$。 元组连接：$\\overset{\\frown} {t_rt_s}$ 关系运算运算对象和结果都是关系。因此结果一定是表!!! 基本的关系运算：并、差、笛卡尔积、选择、投影 选择：$\\sigma_F (R) = {t|t\\in R \\and F(t)为真}$。自然是满足结合率啥的的。 投影：$\\Pi_A(R) = { t[A] | t \\in R } , A\\subseteq U$，从R(U)中选出若干属性列组成新的关系。结果中要去掉相同行。 扩展的关系运算：交，连接，除 交：$R∩S = R - (R - S）= S - (S - R)$ 除：R (X，Y) ÷S (Y，Z)， X，Y，Z为属性组，Z不重要。R.Y 与 S.Y 同语义 (可以不同名)。某种意义上可以把除法理解成整除。 $R÷S = {t [X] | t \\in R \\and \\Pi_Y (S) \\subseteq Y_{t[X]}}= \\Pi_X(R) - \\Pi_X(\\Pi_X(R) \\times \\Pi_Y(S) - R)$. θ连接：R和S的笛卡尔积中选取R关系在A属性组上的值与S关系在B属性组上值满足θ比较关系的元组。 广义定义$R \\underset{A\\theta B}{\\Join} S = {\\overset{\\frown} {t_rt_s} |t_r \\in R \\and t_s\\in S \\and t_r[A]θt_s[B] }=\\sigma_{R[A]θS[B]}( R×S)$，其中θ是一个运算符。 显然地，有一种等值连接，是从笛卡尔积中取得A、B属性值相等的那些元素。$R \\underset{A= B}{\\Join} S$。还有自然连接，是一种特殊的等值连接，比较 的分量必须是相同属性组，在结果中要把重复的属性列去掉。$R(U_r)$和$S(U_s)$具有相同的属性组$B=U_r\\cap U_s$ , $U=U_r\\cup U_s$，$R \\Join S = {\\overset{\\frown} {t_rt_s}[U] |t_r \\in R \\and t_s\\in S \\and t_r[B]=t_s[B] }$. 上面介绍的是内连接，还有外连接： SQL本章最好看PPT，太复杂了 概述基本表，可带索引，都放在存储文件里。 视图，只存放定义在数据库中，不存放对应数据，是虚表，概念同基本表。 游标，内存中生成的临时表，相当于指针指向当前处理元组。 数据定义创建create、删除drop、修改alter 组合上 模式/架构schema、表index、视图view、索引index 数据库database、存储过程procedure、触发器trigger、函数function 在mysql中scheme和database完全等价，SQL server中一个DB可以有多个架构，一个用户可以拥有多个架构，一个架构可以被多个用户拥有，不同架构下允许同名数据对象(db.schema.object)，每个DB有一个缺省的schema叫dbo schemacreate schema 架构名 authorization 用户名 DROP SCHEMA 架构名 &lt;CASCADE | RESTRICT&gt; CASCADE是级联删除，先删表再删模式。RESTRICT:若架构非空，则拒绝删除 table 主码约束： primary key唯一性约束：unique非空值约束：not null参照完整性约束：foreign keycheck约束：check(逻辑表达式) 表约束： )表约束可改成列约束(不用指定列名); 约束名可省略 索引 聚簇索引最好满足： 被索引的列被经常用于检索 很少对基表进行增删操作 很少对其中的变长列进行修改操作 数据查询 select别名与Where条件别名可以as、省略as、等号。如果用重名，就用反点号。 IN (&#39;Ireland&#39;, &#39;Iceland&#39;, &#39;Denmark&#39;);检查在不在列表里 BETWEEN 200000 AND 250000闭区间检查 LIKE表模糊查询，%通配许多个字符，_通配一个字符。 concat(&#39;%&#39;, name, &#39;%&#39;)拼接多个字符串 where area &gt;= 3000000 OR population &gt;= 250000000多个条件 ROUND(num, 位数)保留几位小数。位数为1就是保留1位小树，为-3就是对1000取整。 字符串取整用LENGTH() left(字段, 字符数)取最左边多少个字符。 &lt;&gt;表示不等于 order by可以有多个排序字段order by yr desc, winner，里头甚至可以有逻辑表达式：ORDER BY subject IN (&#39;Physics&#39;,&#39;Chemistry&#39;), subject,winner表示物理化学的放最后，总体按照学科、获奖者排序。 null 用 is distinct表示不重复的 一些聚集函数 可以用 case when 当三目运算： COALESCE(x,y,z,...)会返回第一个非空的元素 分组、排序等“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理 WHERE子句作用于基表或视图，从中选择满足条件的元组。HAVING短语作用于组，从中选择满足条件的组，它总是跟集函数相关。 group by之后的列表，必包含select列表中除去集函数之后的列表. Show the years in which three prizes were given for Physics. group by 也可以由多个字段组成。 连接join在where前面！ 列出成绩表上所有学生的学号，姓名，所修课程名称和该课程成绩： left join：join“右边”的东西可以为空。right full同理。 嵌套查询嵌套查询如果要大于等于一个子查询的列表，可以使用all，where xxx &gt;= all (select ...)，注意空。 有any、all 内外两个查询都有一样的表名的话记得起别名。 可以用在select from where having里面 子查询里面不能使用order by，前面可以用in、比较、exists SQL没有全称量词 数据更新 也可以那啥： 数据库安全数据库安全性控制授权Grant与回收Revoke一句只搞一个表 With grant option有了可以转授该权限，没有则不能。不能够循环授权。 With admin option有了可以转授角色。 revoke 要用from。 数据库角色mysql中无login的概念！ GRANT语句可以将权限或角色（权限集合）授予用户或角色。但是不能将权限和角色混合授予用户(或角色)。 也就是说授予权限给角色，授予角色给用户。 强制存取控制方法 数据库完整性实体完整性关系模型的实体完整性：CREATE TABLE中用PRIMARY KEY定义 单属性构成的码可以定义为列级约束条件或者表级约束条件 多属性构成的码只能定义为表级约束条件。alter table xx add/drop ... 在insert、update时检查。主码值唯一否、主码属性为空否。 参照完整性constraint xx foreign key (col1) references tbl_name(tbl_col) 解决：外码列允许为空。级联CASCADE操作。 用户定义的完整性NOT NULL和UNIQUE只出现在列约束上DEFAULT和CHECK约束既可以出现在列约束上，也可以出现在表约束上 域和断言Domain(域): 带约束的数据类型 Assertion(断言)更复杂、性能更低，他不是 一个数据类型 触发器约束只能访问本行数据，不能跨行、跨表、跨库；约束也无法比较修改前后的数据 这种情况可以用触发器。 事务（(A)原子性(C)一致性(I)隔离性(D)持久性）： AFTER触发器。在执行完INSERT、UPDATE或DELETE等操作并处理完约束之后执行AFTER触发器。AFTER 触发器只能在表上指定。 instead of 触发器：它指定执行触发器的内容而不是执行引发触发器执行的SQL语句。一个表只能定义一个INSTEAD OF触发器。INSTEAD OF触发器可以定义在视图上。 if的写法：if xxx then xxx elseif xxx then xxx else xxx end if; Inserted(NEW)：新插入的数据(insert时)、更新后的数据(update时)Deleted(OLD)：被删的数据(delete时)、更新前的数据(update时)可查询，但不能修改两表的内容 关系数据理论函数依赖R(U)：$X , Y \\subseteq U$， r是R的任意一个关系，对$\\forall s , t \\in r$，若s[X] = t[X]，则s[Y] = t[Y]， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。 X称为这个函数依赖的决定属性集(Determinant)。y = f(x) 简单说就是什么决定了什么的问题。 若X→Y，并且Y→X, 则记为X↔Y。 若Y不函数依赖于X, 则记为$X\\not \\rightarrow Y$ 。 函数依赖是语义范畴的概念，不是根据数据的概念。 X与Y有1:1联系，X→Y，Y→X，即X ↔ Y X与Y有m:1的联系时，只存在函数依赖X→Y X与Y有m: n的联系时，则X与Y之间不存在任何函数依赖关系 R(U)：$X , Y \\subset U$，若X→Y，且Y⊈ X，则称X→Y是非平凡的函数依赖；若X→Y，但Y $\\subseteq$ X, 则称X→Y是平凡的函数依赖。 平凡：就是没劲，自己当然决定自己（而且平凡的函数依赖总是成立的）我们总是讨论非平凡的函数依赖。 R(U)：$X , Y \\subset U$，$\\forall X’\\subset X$，$X\\not \\rightarrow Y$，则称Y完全函数依赖于X，记作$X\\stackrel{f}{\\rightarrow}Y$。就是说X决定Y，X不能再小了。 如果存在这么一个X’也能决定Y，就称Y部分函数依赖于X，记作$X\\stackrel{p}{\\rightarrow}Y$. 在关系模式R(U)中，如果X→Y，Y→Z，且Y⊈ X， Z⊈ Y , Y→X，则称Z传递函数依赖于X。 码和主码：设K为关系模式R&lt;U,F&gt;（F是函数依赖集合）中的属性或属性组合。若$K\\stackrel{f}{\\rightarrow}U$，则K称为R的一个侯选码（Candidate Key）。若关系模式R有多个候选码，则选定其中的一个做为主码（Primary key）。外码不说了。 函数依赖的公理系统基本理论逻辑蕴含：设R &lt;U，F&gt;; 其任何一个关系r，若函数依赖X→Y都成立, 则称F逻辑蕴含X →Y，记作记作$F \\vdash X\\rightarrow Y$。总之，所有完全、部分、传递函数依赖都搞上了。 函数依赖集的闭包：关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体所构成的集合称作F的闭包，$F^+ = {X\\rightarrow Y | F\\vdash X\\rightarrow Y}$. 属性集的闭包：设F为属性集U上的一组函数依赖，$X \\subseteq U$，$X_F^+ = {A | X\\rightarrow A ∈ F^+}$称为属性集X关于函数依赖集F的闭包。F确定的情形下，也可以简写成$X^+$。其实就是通过X能确定的属性的集合。 （其中F逻辑蕴含A→B, AB→A, A→C,…反正好多没意思的函数依赖） Armstrong公理系统： 自反律 $Y\\subseteq X ⇒ X→Y$ 增广律 $X→Y ⇒ XZ→YZ$ 传递律 $X→Y, Y→Z ⇒ X→Z$ 可以推导出来： 合并律 $X \\rightarrow Y，X \\rightarrow Z \\Rightarrow X \\rightarrow YZ$ 分解律 $X\\rightarrow Y, Z\\subseteq Y \\Rightarrow X\\rightarrow Z$；特别地，$X\\rightarrow YZ \\Rightarrow X \\rightarrow Y，X \\rightarrow Z$ 伪传递律 $X \\rightarrow Y，WY \\rightarrow Z\\Rightarrow WX \\rightarrow Z$ 以及几个重要引理： $X\\rightarrow A_1 A_2 \\cdots A_k \\Leftrightarrow X\\rightarrow A_i (i=1, 2, \\ldots ,k) $ $X→Y \\Leftrightarrow X_F^+ ⊇ Y$ $V→W，X_F^+ ⊇ V ⇒ X_F^+ ⊇ W$ 计算属性集的闭包，可以来回扫描函数依赖，直到闭包集不变化： 如果$G^+=F^+$，就说函数依赖集F覆盖G（F是G的覆盖，或G是F的覆盖），或F与G等价。 $ F^+ = G^+ \\Leftrightarrow F \\subseteq G^+，G \\subseteq F^+$ 求极小函数依赖集每一个函数依赖集F均等价于一个极小函数依赖集$F_m$。（它不是唯一的） 三步循环走：单属性化、无冗余化、既约化；单属性化、无冗余化、既约化；单属性化、无冗余化、既约化…… 单属性化：利用分解律，将所有函数依赖右部单属性化 无冗余化：逐一检查F中各函数依赖X→Y，令G=F-{X→Y}，若$X_G^+⊇ Y$ ， 则从F中去掉此函数依赖。 既约化：去掉依赖左部的多余属性： 正则覆盖正则覆盖不要求右侧单属性，恰恰相反，它要求左侧相同的依赖要合并成一个正则覆盖不单单寻找左侧多余的属性，它寻找两侧多余的属性 如果去掉一个函数依赖中的属性不改变该函数依赖集的闭包，则称该属性是无关属性。 两步循环走： 使用合并律合并左侧相同的函数依赖 找出每个函数中的无关属性，并去之 求关系模式R&lt;U,F&gt;候选码仅在函数依赖右部出现的属性集称为纯R属性集，记为RO(Right Only)；不在任何函数依赖右部出现的属性集为独立属性集，记为N；在函数依赖左右部均出现的属性集称为双边属性集，记为LR； 不在任何函数依赖右部出现的属性必出现在每个候选码中(一定是主属性) 仅在函数依赖右部出现的属性一定不是主属性(不会出现在任何候选码中) 范式与规范化1NF任给关系模式R(U,F)，若U中每个属性及其值均为不可再分的基本数据元素（原子项），则R∈1NF。 消除非主属性对码的部分依赖，规范化(投影分解)： 所有完全FD于码的属性组成一个关系模式 所有部分FD于码的属性组成另一个关系模式 解决了1NF的这些问题，就是2NF了： 2NF若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。 (不存在非主属性对码的部分函数依赖)推论: 若R∈1NF,且其候选码为单个属性,则R∈2NF 要投影分解,消去非主属性对码的传递依赖。 解决了2NF的这些问题，就是3NF了： 3NF关系模式R&lt;U，F&gt; 中若不存在码X、属性组Y及非主属性Z（Z ⊈ Y）, 使得X→Y，$Y \\not → X$，Y→Z，成立，则称R&lt;U，F&gt; ∈ 3NF。 (属性不依赖于其它非主属性 [ 消除传递依赖 ],要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。) 关系模式R的所有非平凡函数依赖，要么左侧包含候选码，要么右侧是主属性。（定义2） 例如，员工信息表Staff中已经包含部门编号dept_id，那么就不能再包含dept_name, dept_location等信息。 BCNFR&lt;U，F&gt;∈1NF，若X→Y，且Y ⊈ X 时X必含码，则R∈BCNF。 所有非平凡函数依赖左侧必包含候选码。 R∈BCNF，则R∈3NF 例如，StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，(仓库ID, 存储物品ID) →(管理员ID, 数量)，(管理员ID, 存储物品ID) → (仓库ID, 数量) 但是存在如下决定关系：(仓库ID) → (管理员ID)，(管理员ID) → (仓库ID)，即存在关键字段决定关键字段的情况，所以其不符合BCNF范式 因此分解成仓库管理：StorehouseManage(仓库ID, 管理员ID)；仓库：Storehouse(仓库ID, 存储物品ID, 数量)。 多值依赖放弃了 描述型定义：设R(U)是一个属性集U上的一个关系模式， X、 Y和Z是U的子集，并且Z＝U－X－Y，多值依赖 X→→Y成立当且仅当对R的任一关系r，给定一对(x, z）的值 ，有一组Y的值与这对应，这组值仅仅决定于x值而与z值无关。 若X→→Y，而Z＝φ，则称X→→Y为平凡的多值依赖否则称X→→Y为非平凡的多值依赖 4NF BCNF说是在3NF的基础上消除了一切属性对码的部分、传递函数依赖比较好。 关系模式的分解 无损连接分解 就是分解以后再join！ 保持函数依赖的分解 数据库设计 建立索引的考虑： 如果一个(或一组)属性经常在查询条件中出现，则考虑在这个(或这组)属性上建立索引(或组合索引) 如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引 如果一个(或一组)属性经常在连接操作的连接条件中出现，则考虑在这个(或这组)属性上建立索引 为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块称为聚簇 聚簇索引的索引项顺序与表中元组的物理顺序一致。在一个基本表上最多只能建立一个聚簇索引。 当一个关系满足下列两个条件时，可以选择HASH存取方法： 该关系的属性主要出现在等值连接条件中或主要出现在相等比较选择条件中 该关系的大小可预知，而且不变 / 该关系的大小动态改变，但所选用的DBMS提供了动态HASH存取方法。 关系数据库引擎基础-SP我感觉这一节不太会考。 数据库存储从效率、安全等角度出发，主流DBMS都倾向于自己进行页面管理。 文件组织：基于链表的堆文件O(n)，基于页目录的堆文件类似哈希表。而堆文件是一个无序的page集合，其中的元组可按随机顺序存放，支持page的创建、读、写和删除操作，支持遍历所有pages的操作 基于链表的堆文件，堆文件头部设立一个header page，并存放两个指针，分别指向：空页列表（free list）头部、数据页列表（data list）头部。每个page均记录当前空闲的空间（slot） （感觉就是俩双向链表） 基于目录的堆文件： 一个页只存放一类信息（元组、元数据、索引、日志记录） 每个页具备一个唯一ID，单文件可以是offset，多文件一般会有个间接层映射页面id到文件的路径和offset 硬件页面是存储设备中能保证故障安全写操作（failsafe write）的最大数据块单位。每个页有页头。 页面内“数据”的组织方式： 面向元组型 日志结构型 面向元组型的页设计就是嗯append元组，对删除元组和变长元组支持不好，更长见的是： 槽页（Slotted Pages） 日志式文件记录，页中只存放日志记录 联机事务处理（On-Line Transaction Processing，OLTP），传统具较强“事务特性”需求的应用，比如电商、贸易等联机分析处理（On-Line Analytical Processing，OLAP），数据量较大，主要是查询、复杂查询、统计，甚至数据挖掘 复合事务分析处理（Hybrid Transaction-Analytical Processing，HTAP）兼具OLTP和OLAP特征 常见的n元存储模型（n-ary storage mode，NSM，又名“行存储”）非常适合OLTP。此时，单个元组的所有属性连续的分布在一个page中，查询往往涉及单个实体（工作量较少），并能适应较为繁重的“更新”工作量 针对OLAP，分解存储模型（Decomposition Storage Model，DSM）更为适合，又称为“列存储”，DBMS将单个属性的值连续的组织在一个page中；可以很好的适应大数据量、复杂查询语义、高负载查询。 缓存当执行引擎操作那部分内存时，缓冲池管理器必须确保该页面始终驻留在那片内存区域中。 缓冲池管理器的目标：尽可能减少磁盘I/O带来的延时。 用于缓存页面的内存空间被组织为一个数组，其中每个数组项被称为一个帧，一个帧正好能放置一个页面。 页表是缓冲池管理器用于维护缓冲池元数据的数据结构。维护位置信息、脏标志、引用计数。 锁lock是事务级别的，保护的是表、元组这种逻辑对象，持续时间长，可以回滚 闩latch是线程级别的，保护的是内部数据结构，一般用os机制实现， 不考虑回滚。 散列表散列函数特性： 函数的输出是确定的 输出值的分布是随机且均匀的 易于计算 线性探测法： 如果散列值对应的桶中已有数据，则将数据存放到相邻的桶中。查找时，从散列值对应的位置开始向后搜索。直至找到key值或者空桶。 但是删除时，要注意避免影响将来的查找。可以用墓碑法或者移位法。 链式散列表： 每个桶指针指向一个链表，散列值相同的数据拉链存放。 可扩展散列表：以二倍翻倍 线性散列表：以奇怪的关系扩展 查询处理迭代模型（火山模型）：不断执行Next函数，得到元组或者一个null标记。 物化模型： 物化模型适合OLTP. 向量模型：和迭代模型差不多，不过返回的是一批元组而不是一个 至于数据存取方法，有三种： 顺序扫描 索引扫描（多索引一般用求交集的方法） 关系查询处理和查询优化-SP关系数据库系统的查询处理 查询分析 查询检查 查询优化 查询执行 选择操作典型实现方法：（1）全表扫描方法（2）索引扫描方法 连接操作的实现： 嵌套循环方法(nested loop) 排序-合并方法(sort-merge join 或merge join) 索引连接(index join)方法 哈希连接(Hash Join)方法 关系数据库系统的查询优化也许会出分析题吧。分析块数量。 代数优化关系代数表达式的优化 代数优化的查询树启发式优化规则： 选择运算应尽可能先做！！！（减小中间集的规模） 投影和选择运算同时进行（避免重复扫描） 将投影运算与其前后的双目运算结合起来（避免重复扫描） 某些选择运算＋其前面的笛卡尔积 ⇒ 连接运算 （减小中间集的规模） 提取公共子表达式(公因子)（保存计算结果，避免重复计算） 总的来说，算法就是四步： 分解选择运算 通过交换选择运算，将其尽可能移到叶端 通过交换投影运算，将其尽可能移到叶端 合并选择和投影的串接 物理优化嵌套循环怎么计算块数？ 这个只是读的，写的时候要继续考虑 数据库恢复技术-SP基本概念事务是恢复和并发控制的基本单位 事务的ACID特性： 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持续性（Durability ） 恢复的目标：ACD没有I 事务故障：某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了，比如溢出，死锁牺牲，业务要求 系统故障：使系统停止运转的事件；OS得重启 介质故障：硬件故障使存储在外存中的数据部分丢失或全部丢失 事务故障时，夭折的事务可能已把对数据库的部分修改写回磁盘 系统故障时，只有外部存储设备上的数据未受影响 事务故障的恢复 反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作。 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”（Befor Image, BI）写入数据库。 插入操作， “更新前的值”为空，则相当于做删除操作 删除操作，“更新后的值”为空，则相当于做插入操作 修改操作，则用BI 代替 AI（After Image） 继续反向扫描，对下一个更新操作作同样处理。 直到读到此事务的开始标记。 系统故障的恢复 正向扫描日志文件（即从头扫描日志文件） Redo队列: 在故障发生前已经提交的事务 Undo队列:故障发生时尚未完成的事务 对Undo队列事务进行UNDO处理 反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作 对Redo队列事务进行REDO处理 正向扫描日志文件，对每个REDO事务重新执行登记的操作 介质故障的恢复略 具有检查点的恢复技术 在日志文件中增加检查点记录 增加重新开始文件 恢复子系统在登录日志文件期间动态地维护日志 检查点记录的内容：建立检查点时刻所有正在执行的事务清单，这些事务最近一个日志记录的地址 重新开始文件的内容：记录各个检查点记录在日志文件中的地址 并发控制"},{"title":"编译原理笔记","date":"2022-05-29T22:37:22.000Z","url":"/2022/05/29/course/compile/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["编译原理","/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"过！过！过！ 引论和课程重点编译过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成 第一章大概10% 第二章文法语言肯定要给语言要求使用文法描述，可以结合第三章 自顶向下分析肯定会考一个完整的 LR也会考一个完整的 算符优先，简单优先可能不会考完整的，只会考一个概念 几种LR的关系要知道 第七八章要考，可能会考翻译模式，给c让你翻译中间代码。 第九章考一个栈帧就行了 具体的开完会再说 课程重点选择来源：作业里有的、PPT后面写的重点 ch02-文法和语言设计一个已知语言的文法；确定已知文法定义的语言；求句型的短语、直接短语和句柄；文法二义性判定 ch03-词法分析设计正规文法|正规式|有穷自动机；等价转换；词法分析器的构造 ch04-自顶向下语法分析方法 计算产生式的SELECT()集 FIRST()集，FOLLOW()集 判断文法是否LL(1)文法 LL(1)分析表 LL(1)分析算法 递归子程序构造 非LL(1)文法：提取左公因子，消除左递归，改造或重新设计文法，使其成为LL(1)文法 ch05-自底向上优先分析计算优先关系；优先文法的判定；构造优先分析表；优先分析算法 ch06-LR分析基本概念：可归前缀、活前缀、LR(0)项目、移进项目、待约项目、归约项目、接受项目、移进-归约冲突、归约-归约冲突、LR(0)项目集、LR(0)项目集规范族、LR(0)文法、SLR(1)文法、搜索符、搜索集、LR(1)项目、LR(1)文法、LR(1)项目集规范族、同心项目、同心项目集和LALR(1)文法重点掌握： 构造识别LR(0)活前缀DFA、构造识别LR(1)活前缀DFA和合并识别LR(1)活前缀DFA的同心项目集； LR(0)、SLR(1)、LR(1)和LALR(1)文法判别； LR(0)、SLR(1)、LR(1)和LALR(1) 分析表； LR分析算法。 ch07-语法制导的语义分析属性文法基本概念与属性的计算方法；翻译模式基本概念与属性的计算方法 ch08-静态语义分析和中间代码生成符号表的作用于基本实现技术；表达式的中间代码表示；基本语法规则的语义规则设计 ch09-运行时存储组织静态数组、动态数组、关键字池、浮动地址代码、静态数据对象、动态数据对象、静态存储分配、栈式动态存储分配、堆式存储分配、过程活动记录和静态层次数 ch10-代码优化与目标代码生成基本块划分程序流图构造循环的识别循环的优化 文法和语言符号和符号串-文法的基本要素字母表∑是非空有穷集合，其元素称为符号。由字母表∑中的符号组成的有穷序列称为 (字母表∑上的)符号串. 不含任何符号的有穷序列称为空串,记为ε。符号串α的长度是指符号串α中含有符号的个数，记为︱α︱。如果集合A的元素都是字母表∑上的符号串，则称集合A为∑上的符号串集合，简称串集。 设字母表∑＝｛a，b，c｝，A＝｛ε，a，ba，cab｝，B＝｛a1，ba，cab｝，则 A是∑上的符号串集合，B不是∑上的符号串集合。 符号串的运算：和计算理论中的类似。连接、或、幂、正闭包、星闭包。 符号串集合的运算：（笛卡尔）乘积、和、幂、正闭包、星闭包。 显然，若A为任意一个字母表，$A^*$就是字母表上所有符号串（包括空串）的集合。 文法和语言的形式化定义$\\alpha ::= \\beta$简写为$\\alpha \\rightarrow \\beta$。若P中包含它，则任意的串γαδ 可以推导出γβδ，这是直接推导/一步推导，记为γαδ $\\Rightarrow$ γβδ。也可以说γβδ归约到γαδ ，这种归约称为直接归约/一步归约。 若$\\alpha \\stackrel{+}{\\Rightarrow} \\beta$或者$\\alpha \\rightarrow \\beta$，则记$\\alpha \\stackrel{*}{\\Rightarrow} \\beta$。 句型和句子：G[S] 有$S \\stackrel{}{\\Rightarrow} \\beta$，则称β是文法G[S]的句型。若β∈$V_T^$，则称β是文法G的句子。当然，句子也是句型。 文法G产生语言即为其句子的集合，记为L(G)。如果两个文法的产生语言一样，文法就等价。 文法的类型 0型文法/短语文法/图灵机：一个文法的所有规则，左侧至少含有一个非终结符。 1型文法/上下文有关文法/线性界限自动机：左侧符号串的长度不大于右侧符号串的长度（空规则除外），且左侧至少含有一个非终结符。（ γAδ $\\Rightarrow$ γβθδ，A被替换成βθ，跟A的上下文相关，因为要match整个 γAδ） 2型文法/上下文无关文法：任一产生式左部均为恰好一个非终结符 3型文法/正规文法/有限自动机：跟教材上不一样！ L3真含于L2真含于L1真含于L0。 上下文无关文法及其语法树 最右推导，也叫规范推导。由规范推导所得的句型，叫做规范句型(右句型)。规范推导的逆过程，叫做规范归约。 语法的二义性不等于语言的二义性。二义性文法可能存在等价的非二义性文法。不过语法的二义性问题是不可判定的。 句型的分析 假设文法G[S]是语言L之文法，即L(G)＝L，则“符号串α是否符合语言L的语法问题” 被等价地转化成“推导或归约问题”，即是否$S \\stackrel{}{\\Rightarrow} \\alpha \\and \\alpha \\in V_T^$。 自顶向下分析法：从文法开始符号出发，反复使用规则，寻找匹配符号串（推导）的句型，直到推导出句子或穷尽规则也不能推导出。 要解决的问题：选择句型中哪一个非终结符进行推导、选择非终结符的哪一个规则进行推导。 容易出现回溯，可以考虑提公因子。 自下而上分析法：从输入符号串α开始，逐步进行“归约”，直至归约出文法的开始符号 S，则输入串α是文法G定义的语言的句子，否则不是 要解决的问题：如何选择句型α的子串β进行归约。 按句柄归约-规范归约(移进-归约) 总的来说,一个非终结符的树叶组成短语，一个下面就一层的非终结符的树叶组成直接短语。在做推导的时候，ε直接不写。但是在分析短语的时候，ε要写出来。一个句型最左边的那一个直接短语，叫做句柄 补充说明-文法中的多余规则和epsilon (ε) 规则 文法的化简： 删除A-&gt;A这样的有害规则 删除不终结产生式（永远到不了终结符） 删除不可用产生式（压根到不了规则左边的非终结符） 删除ε产生式： 词法分析词法分析程序设计 输出每个词形式 (单词种别，单词自身的值)，单词种别常用enum 单词的形式化描述工具 用正规文法、正规式、有穷自动机三种描述方法。（计算理论人狂喜） 正规文法：设文法G＝（$V_N$，$V_T$，P，S），如果任意A→β∈ P，A∈ $V_N$ ，且β只能是aB或a或Ɛ, 则称文法G属于右线性3型文法。 正规式：算符优先级由高到低 ：*，·，| 有穷自动机 DFA的f: 状态转换(移)函数，为$K\\times \\Sigma \\rightarrow K$的单值部分映射 DFA的扩展状态转移函数 f’ $K\\times \\Sigma^* \\rightarrow K$，编译的DFA好像允许不是每个字母都有状态去转移 NFA的状态转移函数 $K\\times(\\Sigma\\cup{ε})\\rightarrow P(K)$，其中P(K)为K的幂集 NFA 弧上的标记可以是ε，同一个字母可能出现在同一状态射出的多条弧上 NFA 每次都做集合到集合的变换 显然$\\epsilon-Closure(I)$就是I通过空转移能到达的所有状态的集合 各类转换正规式转正规文法 我的评价是计算理论重现江湖 正规文法转正规式 NFA转DFA 画这么一个表： 重命名 a b {0,1,7,2,4} 0 {3,8,6,1,7,2,4} {5,6,1,7,2,4} {3,8,6,1,7,2,4} … … … 就是首先放进去ε-Closure(S)，然后不断变换。注意每一个变换的结果都是ε-Closure。最后按这个表格重命名画图。 DFA的化简 消除无用状态：不可达，没有通路到达终态； 合并等价状态（都是终结态/非终结态，任意转换都到等价的状态） 起初的两个集合先按终结 非终结分类，每次查看有没有一个集合的两个元素的转移结果不在同一个集合里头，那么这两个元素就要拆开。 正规式和有穷自动机的转换 NFA转正规式： 正规式转NFA： NFA转DFA就是了。 正规文法和有穷自动机的转换 自顶向下语法分析方法自顶向下是推导，ANTLR4，LL(1) 确定的自顶向下语法分析思想约定好每次选择最左边的非终结符，选择出来一个唯一的产生式 FIRST(α)-串首(终结)符号集 FOLLOW(A)-非终结符的后继(终结)符号集。FOLLOW(A)是由任意句型中紧邻非终结符号A之后出现的终结符号a组成的集合。 SELECT(A→α) - 产生式的可选集 文法G是LL(1)的，当且仅当对每个VN，A的两个不同产生式A→α，A→β，满足SELECT(A→α) ∩ SELECT(A→β) = Φ 其中，α、β不能同时推导出ε。确定的无二义性的。 L – Left to right parsing 从左至右分析tokenL – Left-most derivation 最左推导1 –只需向右看1个符号便可以决定选择哪个产生式进行推导 LL(1)文法的判别文法G是LL(1)的,当且仅当任意两个左部相同的产生式其select集的交集为空。 判别$S \\stackrel{*}{\\Rightarrow} \\alpha$ ？仅当α中所有非终结符全部可推导出空，且α无非空的终结符 求产生式右部FIRST集, 如产式右部可推导出ε,则还需： 计算产生式左部FOLLOW集 判别能否产生空串： 求产生式右部FIRST集： 求follow集合： 某些非LL(1)文法到LL(1)文法的等价变换若文法含有左公共因子，或者含有直接或间接左递归，一定不是LL(1)文法。 先消除左递归，再提取左公因子。 提取左公因子： 这么不断提取。注意没有左公因子只是一个必要条件。 消除左递归： 消除一切左递归： LL(1)分析的实现-递归下降分析法将每个非终结符编写成一个递归子程序，选择规则的实现步骤是将输入串“下一个符号”逐个与A规则的选择集进行判定。 LL(1)分析的实现-表驱动分析法 自底向上优先分析简单优先分析法 文法G的符号集V中,任意两个符号之间至多$\\lessdot$lessdot、$\\gtrdot$gtrdot、$\\eqcirc$eqcirc（实在打不出来了）三种简单优先关系之一,且没有相同右部的规则,则文法G称为简单优先文法。 算符优先分析法 设不含空规则的文法G为OG文法,如果任意两个终结符之间至多存在$\\eqcirc,\\lessdot,\\gtrdot$三种算符优先关系之一,则称文法G为算符优先文法(Operator Precedence Grammar),简称OPG文法。 后面太复杂了，做了作业再截图 实例注意：任何句型前后都有一个井号！自己加的。 竖着的是a，横着的是b，内容是a和b的关系 N代表任意非终结符，感觉是根据前一个非终结符的关系来判定，小于和等于就移进。大于规约。 LR 分析语法分析。本章要对着ppt仔仔细细研究。 LR分析概述LR(k)：L(Left to right parsing), R(right-most derivation in reverse), K(look ahead k token(s)) 总控程序、分析栈和分析表三个组成部分，移进-规约法。 总之，状态栈和符号栈要同进同出。 LR(0)分析活前缀和可归前缀简单地说，先找到句柄（最左直接短语），然后活前缀是从符号串最左端到句柄最右端，这一条串的所有前缀。可归前缀是从符号串最左端到句柄最右端这一条串。 识别活前缀DFA技术线路是根据文法G，构造识别活前缀NFA M。之后通过子集法，将NFA M确定化，得到识别活前缀DFA M′。 添加一条$S’\\rightarrow S$规则，S’作为起始符，用来给最后转移到接收态。 S→aAcBe这样的，画状态，最后一个节点标上规则的序号并为可接收态，每个非终结符边前面的状态要通过$\\epsilon$转移到相应的规则上面 确定化nfa，得到dfa，按照标注的规则转移 构造LR(0)项目集规范族首先是给状态取一个规范的名称 这样的话，可以通过上面的方法构造识别活前缀的dfa，也可以使用LR(0)项目集(规范族)直接构造识别活前缀的DFA。 设I是文法G的LR(0)项目子集，则MOVE(I，X)定义如下：MOVE(I，X) ＝ {A→αX·β︱A→α·Xβ∈I}。move就相当于把点往后挪了一格。 I的闭包就是它和第一个非终结符的规则的集合： 最终构造DFA方法（仔细研读）： 文法G的识别活前缀DFA M的状态集称为文法G的LR(0)项目集规范族。 LR(0)分析表的构造 表见上。总之，有一个状态$i$（对应项目集规范族$I_i$） 非终结符转移到$j$，填action为j $I_i$是不含规约项目的，那么通过终结符转移到j，填action为$S_j$ $I_i$是含规约项目的，那么全行都是对应的的$r_x$ 状态1通常是$S’\\rightarrow S$，那么action[1,S]为accept。 移进-归约冲突: 项目集中同时出现移进和归约项目：A→α•aβ，B→γ•归约-归约冲突：项目集中同时出现多个归约项目：A→α•，B→β• 如果文法G的LR(0)项目集规范族不存在移进-归约冲突或归约-归约冲突的项目集，则文法G称为LR(0)文法。可采用LR(0)分析法、无二义性的。分析表ACTION表中每格仅会是移进、归约和报错3种动作之一。 SLR(1)分析LL(1)的痛苦是解决不了移进-规约冲突和规约-规约冲突问题。 不是LR(0)文法时，可以采用简单地向后看1个输入符号的方法，解决移进-归约冲突或归约-归约冲突。 它的构造法和LR(1)的很类似，除了$I_i$是含规约项目的时候，不再是简单地把全行都搞成对应的$r_x$，而是$\\forall a\\in FOLLOW(A), action[i,a]=r_i$。也就是说得在follow集合里头。 SLR(1)文法，是无二义性的；LR(0)文法，一定也是SLR(1)文法 LR(1)分析b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件 把First(β)作为产生式作为B→γ归约时向前查看的符号集合,代替SLR(1)分析法中的Follow(B) 并将向前搜索符号集也放在LR(0)项目的后面:[A→α•β, a]， a称为向前搜索符(展望符) - LR(1)项目 LR(1)项目中LR(0)项目部分称为LR(1)项目的心。 同心的LR(1)项目简记为 [LR(0)项目，搜索符1︱搜索符2︱···︱搜索符m]。 “搜索符1︱搜索符2︱···︱搜索符m”称为搜索集。 形如[A→α•, a]的项表示仅在下一个输入符号等于a时才可以按照A→α 进行归约； 这样的a的集合总是FOLLOW(A)的子集，通常是真子集 就是非终结符的后头和后继符都那啥 LALR(1)分析如果采用同心项目集合并方法，进行合并后的文法G的LR(1)项目集规范族，没有LR(1)项目冲突，则称文法G为LALR(1)文法。 合并同心集时产生移进-规约、归约-归约冲突, 就不是LALR(1)文法。 任何一个二义性文法都不是LR的 语法制导的语义计算基于属性文法的语义计算属性文法综合属性： 自下而上传递信息 语法规则：产生式左部符号的综合属性由产生式右部符号的属性计算得出 语法树：父节点的综合属性由子结点的属性和父结点自身的属性计算得出 终结符的综合属性值是由词法分析器提供的词法值，因此在属性文法中没有计算终结符属性值的语义规则 继承属性： 自上而下传递信息 语法规则：根据右部候选式中的符号的属性和左部符号的属性计算右部候选式中的符号的继承属性 语法树：根据父结点和兄长节点的属性计算子结点的继承属性 产生式右部符号的继承属性和产生式左部符号的综合属性由本产生式提供计算规则。且规则中只能使用本产生式中文法符号的属性。产生式左部符号的继承属性和产生式右部符号的综合属性的计算规则不由本产生式提供，而是根据其它产生式的语义规则来计算。 带注释的语法树(仅含综合属性)：仅使用综合属性的属性文法称S－属性文法 带注释的语法树(含继承属性）：先构造语法树，再计算属性。 语义计算属性依赖： 如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边 树遍历算法： 一遍扫描法：在语法分析的同时计算属性值 语义规则被计算的时机 自上而下分析，一个产生式匹配输入串成功时 自下而上分析，一个产生式被用于进行归约时 S-属性文法和L-属性文法仅含综合属性的属性文法称为S-属性文法 基于S-属性文法的语义计算给LR分析栈里头加上一个语义栈 基于L-属性文法的语义计算上面的树遍历法 基于翻译模式的语义计算翻译模式属性文法的语义规则：总是放在产生式的尾部翻译模式：把语义规则（也称语义动作），用花括号{ }括起来，插入到产生式右部的合适位置上。进一步细化了语义计算的时机。 基于S-翻译模式的语义计算S-翻译模式：仅涉及到综合属性，通常语义动作集置于产生式右端的末尾。常采用LR的自底向上的分析法，和S属性文法类似。 与S-属性文法类似 基础文法是LL(1)：自顶向下计算 基础文法是LR系：自底向上计算 基于L-翻译模式的自顶向下计算 分析程序由一组递归子程序(函数)组成，每个非终结符对应一个子程序 如果非终结符有多个产生式，根据当前符号和SELECT集决定用哪个产生式 从左到右分析符号串，遇到终结符就匹配，遇到非终结符就调用相应的分析子程序 要求基础文法是LL(1)的 基于L-翻译模式的自底向上计算从翻译模式中删除嵌入在产生式中间的语义动作继承属性的求值结果以综合属性值存放在语义栈中，对继承属性的访问变成对语义栈中某个综合属性的访问模拟继承属性的计算 静态语义分析和中间代码生成静态语义分析类型表达式： 基本类型是类型表达式 若T是类型表达式，I是整数域 (0..5; 1..10), 则Array(I,T) 也是类型表达式 若T是类型表达式，则pointer(T)是类型表达式 …… 中间代码生成 赋值语句和算术表达式的翻译S -&gt; id := E 语义属性 id.place : id 对应的存储位置 E.place : 用来存放 E 的值的存储单元的地址 E.code : 对E 求值的 TAC 语句序列 S.code : 对应于 S 的 TAC 语句序列 语义函数/过程 gen() : 生成一条 TAC 语句 newtemp() : 在符号表中新建一个从未使用过的名字， 并返回该名字的存储位置 || 是TAC 语句序列之间的链接运算 说明语句的翻译 bool表达式的翻译 拉链与代码回填（backpatching） 运行时存储组织运行时存储组织概述 静态存储分配数据空间仅需要有静态数据区即可。对于所有数据对象，其分配的存储地址都是相对于静态数据区的偏移量，即登记在符号表中数据对象的地址( .place)属性值。 绝对地址 ＝ 静态数据区首址 + 偏移量 栈式存储分配 调用子程序时，在栈顶，给子程序分配所需的子程序数据区； 子程序返回时，从栈顶，收回分配给子程序所占用存储区。 当子程序被递归调用时，同一个子程序可能在数据空间中同时拥有多个子程序数据区，每个数据区对应于同一个子程序的一次执行过程。 对于所有数据对象，其分配的存储地址都是相对于数据对象所在的子程序数据区的偏移量。 栈帧又叫活动记录。 堆式存储分配略 活动记录（栈帧） 注意：在本题中，int的单元数是1，float的单元数是2！ 嵌套程序块：太难了，感觉不会考 过程调用call-by-value ：调用过程计算实参的值，将其放于对应的存储空间，被调用过程执行时，就像使用局部变量一样使用这些形式单元 call-by-reference：想想C语言，很直观 代码优化与目标代码生成优化技术介绍常量折叠：r2 = 2 * 3 优化为 r2 = 6 常量传播：代入常量 常量传播可能导致分枝判断条件是常量，从而导致分枝的代码不需要执行，这种优化叫做稀疏有条件的常数传播 ……略 基本块、流图、循环基本块基本块是一个最大的不可分割的、连续的三地址指令序列，这个块中的指令要么全执行，要么全不执行。 基本块的入口： 程序的第1条语句； (条件/无条件)跳转语句的跳转目标语句； 条件跳转语句的下一条语句； 划分基本块的方法如下： 依据入口语句定义，确定程序所有的入口语句； 对每一个入口语句，确定对应的基本块。这些基本块是由入口语句向后直到 转移语句(包括该语句在内)； 或到停止语句； 或到下一个入口语句(不包括该语句)之间的代码段。 凡不属于任何一个基本块的语句都是无用语句，将其全部删除。 流图 一般把基本块划分和图画到一块（图里头放基本块） 常用优化方法删除公共子表达式(CSE)：如果表达式x op y先前已被计算过，并且从先前的计算到现在，x op y中变量的值没有改变，那么x op y的这次出现就称为公共子表达式 cse可以是基本块内的，也可以是其他基本块的，叫做全局公共子表达式。 删除全局公共子表达式的时候要非常谨慎，因为很有可能在别的块改了值！ 删除无用代码：常用的公共子表达式消除算法会引入一些形如x = y的赋值语句，在其之后尽可能地用y代替x，然后就能给删除无用代码带来机会 常量合并：前面讲了 代码移动：不管循环执行多少次都得到相同结果的表达式，在进入循环之前就对它们求值 强度削弱：用较快的操作代替较慢的操作，如用加代替乘 循环： 在程序流图G中，对于任意一个结点序列α，如果在结点序列之外存在一个结点指向结点序列中的结点V，或者结点序列中的结点V是程序首结点，则称结点V 为结点序列α的入口结点。 求循环：我感觉这玩意考不了 代码优化技术窥孔优化删除冗余的存(store)或取(load)操作 局部优化（重点） 对基本块中每一条四元式代码，依次构造对应的DAG图，最后基本块中所有四元式构造出来DAG连成整个基本块的DAG， 准备操作数的结点 常量合并 常量传播 复制传播 删除公共子表达式 删除无用赋值(死代码) 循环优化对循环中的代码，可以实行 代码外提 归纳变量强度消弱 删除归纳变量(变换循环控制条件) 循环展开 循环合并 目标代码生成技术"},{"title":"C++ 专题学习","date":"2022-02-01T11:21:21.000Z","url":"/2022/02/01/language_notes/cpptopiclearning/","tags":[["C++","/tags/C/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"a tour of c++ 之类的书 语言基础char要是想用来表示数的话最好明确指定signed和unsigned。无符号溢出是取模，有符号溢出是ub。字符串字面值可以分多行书写。 内层作用域可以覆盖外层作用域的定义。但是同一个内层作用域不能重定义相同变量。可以使用空的::variable_name来取得全局作用域的变量。 在C++中不能将void *隐式转换为其他类型指针，并且字面量0可以隐式转换成任意类型的空指针常量。C中NULL是(void *)0，C++中NULL是0，有接收char *和int的两个函数会歧义。但是nullptr是nullptr_t，该类型定义了转到任意指针类型的转换操作符，同时不允许该类型的对象转换到非指针类型。 int *&amp;r=p是定义一个指针p的引用。 const如果在main.cc prog.cc分别定义一个int x;，那也会报重定义，和计算机系统基础教的不一样。强弱符号主要是看编译器的。 不过，如果分别定义一个const int x=10;则不会重定义。因为const被设定为只在当前文件有效。如果想在多个文件里共享一个const，就声明和定义都加上extern关键字。例如头文件extern const int x;，定义extern const int x = 10; 常量引用可以绑定一个字面值、甚至是一个类型不一样的表达式。double y = 10.0; const int &amp;x=y/3.14;。实现相当于整了个临时量绑上去引用。 常量引用可能引用一个并非const的对象，这就能修改常量引用了，，， 顶层const是指针本身不能修改，int *const x=&amp;qwq;，const int *x=&amp;qwq是底层const。而constexpr int *x=&amp;qwq则是顶层const。 const是只读，可以等到运行时确定值；constexpr是常量，必须要在编译时确定值。 类型别名和 decltypetypedef因为不能用于模板别名，所以推荐使用using decltype 用来取得类型 decltype(*p) 对一个解引用操作符来说，类型是引用。这是因为解引用返回的是一个左值。如果表达式求值结果是左值，decltype作用于表达式得到的就是引用类型。 如果 decltype 里头的是一个变量，那自然就是变量的类型。如果是带括号的变量，其实是左值表达式，结果是引用。 辩经 这就是现代C++，，， TODO: 表达式和引用的关系 列表初始化  构造与拷贝控制可以参考 C++ Primer 第十三章拷贝控制。 五大成员函数：拷贝构造函数、移动构造函数，拷贝赋值运算符、移动赋值运算符，析构函数。 构造函数可以声明为explict的来抑制只有一个参数的构造函数的隐式转换。 如果自己定义了构造函数，可以用=default依然生成默认的构造函数。可以用=delete来拒绝生成默认的拷贝赋值运算符等。 如果一个类需要析构函数，它往往需要把拷贝构造函数和拷贝赋值运算符也写上（里头可能有指针）。 注意处理自赋值问题：先new再delete。 右值引用、移动语义、引用折叠、万能引用、完美转发移动构造函数是偷资源的，形式都是Node(Node &amp;&amp;nd)。如果现在写一个swap： 发生一次拷贝构造、两次拷贝赋值，很野蛮。如果Node里头存一个指针，那岂不是要多内存分配一次。 这样就很好。由此可见，std::move把左值引用转换为右值引用。这就是移动语义。它的源代码： 总而言之，就是强转。 在继承和组合的时候要显式调用std::move，因为一个接受右值引用的变量可能是左值： 返回局部变量时不要使用移动语义。 引用折叠是实现万能引用的技术。看  使用万能引用写一个wrapper，如 虽然myforward可以接收左值和右值了，但是调用的结果是输出左值左值！这是因为形参x具名。如果充分利用T里面的信息，交给std::forward 上面代码都使用的是下面第一个函数的例子。T为int &amp;时，int&amp; &amp;&amp;为int &amp;。T为int时，int &amp;&amp;。 这就实现了完美转发。 总而言之，移动语义是通通转为右值。完美转发是靠类型推导来取得真正的引用类型。 也参考  智能指针"},{"title":"Rust 随便学学","date":"2022-02-01T11:21:21.000Z","url":"/2022/02/01/language_notes/rustbook/","tags":[["Rust","/tags/Rust/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"Rust book，rustlings 基础表达式没有分号，可以有： loop 循环中可以break到标签，也可以break返回一个值。 let定义的变量可以推断出类型，const定义的变量必须有类型。 函数参数和返回值： rust 的char是4个字节。 元组、数组： 字段初始化简写语法可以省略结构体中字段名和变量名相同的情况的重复。结构体更新语法可以指定剩余未显式设置值的字段应有与给定实例对应字段相同的值。 所有权 Rust 中的每一个值都有一个被称为其所有者的变量。 值在任一时刻有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 Rust 永远也不会自动创建数据的 “深拷贝”。其他语言常见的浅拷贝可能是Rust中的移动。 整型这样的在编译时已知大小的类型被整个存储在栈上，所以不会失效。要分清楚copy的和drop的。 在同一时间只能有一个对某一特定数据的可变引用。也不能在拥有不可变引用的同时拥有可变引用。注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。 引用必须总是有效的。 slice：&amp;str。编译器会确保指向 String 的引用持续有效。字面值就是字符串slice。 结构体和枚举结构体在impl块里头写方法或者是关联函数。 枚举可以存不同的数据 match和枚举很搭配。匹配是穷尽的。可以用下划线或者other取得不想要的值。 如果只想要枚举中的一种情况，可以用if-let语句。 模块可以一次use多个 集合vector： 可以用索引或者get方法，返回Option&lt;&amp;T&gt;。 map： 错误处理如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。如果 Result 是成员 Err，unwrap 会为我们调用 panic!。except类似，可以写文字。问号可以传递错误。 泛型函数名后头加尖括号T，和java的一样。结构体名后面也可以加。impl关键字后面也可以加。 泛型和cpp的模板比较类似。 trait类似接口。 生命周期注解挺复杂的，，， 函数式闭包： 所有的闭包都实现了 trait Fn、FnMut 或 FnOnce 中的一个。 迭代器加闭包 "},{"title":"6.s081 学习笔记","date":"2022-01-12T13:52:42.000Z","url":"/2022/01/12/pdsl/dpukv/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["PDSL","/tags/PDSL/"],["Raft","/tags/Raft/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"DPUKV私仓地址 阅读材料三篇文章了解 TiDB 技术内幕 - 说存储 不能用一个 raft group 来存所有数据，要按照 key 分 range，用 StartKey 到 EndKey 这样一个左闭右开区间来描述,也就是一个 Region。一个 Region 里头的多个节点叫 Replica。 多版本控制 MVCC 的情况下，key 长这样，版本号较大的放在前面，版本号小的放在后面。 三篇文章了解 TiDB 技术内幕 - 说计算 这个文章主要讲了 TiDB 变 TiKV 上的操作，可以看着玩。 三篇文章了解 TiDB 技术内幕 - 谈调度 调度落地下来主要是三件事情： 增加一个 Replica 删除一个 Replica 将 Leader 角色在一个 Raft Group 的不同 Replica 之间 transfer Raft 论文精读Raft 中文论文"},{"title":"6.s081 学习笔记","date":"2022-01-12T13:52:42.000Z","url":"/2022/01/12/projects/6s081/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["操作系统","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"2021年链接  LEC 1fork后子进程将复制父进程的数据段、BSS段、代码段、堆空间、栈空间和文件描述符。 使用exec执行新的程序时，仍然可以使用原来的文件。 xv6 使用第一种方法。也就是子shell先关闭某个fd再打开，新fd取低值。 所以分开fork和exec的好处之一是可以重定向子进程（子shell的）IO然后再exec而不会扰乱主进程的文件描述符表。 fork以后的同一个文件描述符或者dup系统调用复制出来的文件描述符，他们对应的深层（underlying）IO对象都是一个，共享offset。 shell中有种常见的重定向2&gt;&amp;1，就是说fd 2（stderr）是fd 1（stdout）的副本，也就是错误和正常输出都到一块。 一个值得研读的重定向+pipe的例子： 关于xv6：ctrl+p打印进程信息，ctrl+a x退出qemu。 Lab Util实现user/sleep.c，user/pingpong.c，user/primes.c，user/find.c，user/xargs.c，主要是完成这些工具。 LEC 3 操作系统三大需求：多路复用、隔离、交互。 宏内核monolithic kernel RISC-V有三种模式，机器模式machine mode，监督模式supervisor mode，用户模式user mode 机器起于m mode，执行几条指令以后进入s mode。在s mode里面，cpu可以执行特权指令。如果u mode 的程序企图执行特权指令，那么不会执行，而是转为s mode并且停止程序。 u mode的程序运行于用户空间user space，s mode的程序运行于内核空间 kernel space，也称为内核kernel。 XV6为每个进程都维护了一个页表 每个进程都有用户栈和内核栈。执行用户指令时只用user stack，内核栈空。 系统调用使用ecall指令。 Lab Syscallxv6进行系统调用比方说我们在user/xxx.c里头写用户程序，调用了read()系统调用。这些系统调用的声明都在user/user.h中。 usys.pl是一个perl脚本，生成到usys.S里头形如 回想一下汇编语言，参数存在寄存器a0/a1……里头，a7加载上kernel/syscall.h里头定义好的标识数，ecall触发中断。 中断描述符到中断处理函数这里还没讲，反正就到了kernel/trap.c usertrap()，调用了kernel/syscall.c syscall()，处理了系统调用。 根据标识数和一个预先定义好的函数指针数组，来到了对应的系统调用处理函数kernel/sysfile.c sys_read() 这个函数没有入参，都是自己从寄存器里面捞出来的。它里面可能调用kernel/里头的其他函数。user/xxx.c并不能调用这些函数。 如果要写什么东西到用户内存，要使用copyout()。返回值的话，sys_read()的返回值存到a0里头（等同于eax）。 LEC 4学到这里的时候和华科的os课设混着做了，感觉知识++ 硬件三级页表： 虚拟空间$2^39$，物理空间$2^56$ 快表TLB可以解决三级页表访存次数多的问题，但是记得切换进程的时候要清空tlb。 PTE（page table entry）有一些标记，PTE_V for valid, PTE_R/W之类的。 如果查的时候发现有不在的PTE，就发起缺页中断。 每个进程（CPU）都有自己的satp寄存器，存放根页表的地址。他们各自有各自的页表。并且，内核自己也有一个页表。 内核的虚拟空间内核空间映射： QEMU模拟的ram从kernbase到phystop。内核虚拟空间里，ram和底下的设备都是直接映射。 也有不是直接映射的：trampoline page（在虚拟空间的最高处，和用户页表一样，不过我不知道这是啥），以及内核栈页。每个进程都有一个内核栈。这些内核栈页直接都有guard page。 用户虚拟空间 代码片段一个PTE是一个uint64，那么一个pagetable_t就是一个uint64的指针，，， walk是走一遍三级页表，返回va对应的pte。期间可以指定是否分配不存在的页面。 空闲物理内存管理就是维护一个空闲页链表。一个页的下一个空闲页存放在这个页的最开头，用强制类型转换做。 LEC 5trap有三种可能： ecall exception，例如除零 interrupt，例如io完毕 "},{"title":"CSP 分享会中举到的代码例子","date":"2021-11-03T09:38:00.000Z","url":"/2021/11/03/algorithm_contest/cspsharingexample/","tags":[["杂记","/tags/%E6%9D%82%E8%AE%B0/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"代码风格非常重要！ 反面例子（ZJOI2019 麻将） 写出大模拟的代码CSP 202104-3 DHCP 服务器 我的考场代码。 你应当能分辨出，这段代码比上面的代码好，但是仍有很多值得改进的地方。 "},{"title":"LaTeX 模板","date":"2021-08-27T11:00:00.000Z","url":"/2021/08/27/miscellanies/latextemplates/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["latex","/tags/latex/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"记录一下经常用到的模板 "},{"title":"上了github actions","date":"2021-08-20T16:20:00.000Z","url":"/2021/08/20/miscellanies/ghactions/","tags":[["杂记","/tags/%E6%9D%82%E8%AE%B0/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"以后不用装hexo了，舒服"},{"title":"牛客和 leetcode 及类似 OJ 的部分题目刷题记录","date":"2021-03-12T19:21:15.000Z","url":"/2021/03/12/algorithm_contest/nowcoderleetcodes/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"oi 题比这刺激多了。 剑指 Offer在牛客做的。 JZ1 二维数组中的查找每行可能出现 target 的位置是递减的，所以从右上角开始向左不断走到不比自己大的元素，然后下降一格，再往左……复杂度 $O(n+m)$。 JZ2 替换空格新长度是 $length+space\\times 2$，直接扫就行了。 JZ3 从尾到头打印链表毫无难度。倒是可以用栈，遍历一遍反转，反转链表之类的东西。 JZ4 重建二叉树毫无难度。记得 x 序遍历都是说的根节点，前序便利就是根-左-右这样。 JZ5 用两个栈实现队列不一定每次都要把元素送回去，第二个栈空了再出。 JZ6 旋转数组的最小元素一个不降序列，把前面几个元素挪到后面，二分找最小值。注意时刻记录最小值，函数末返回。leetcode 好像做过。 JZ7 斐波纳契数列随便做。 JZ8 跳台阶随便做。 JZ9 变态跳台阶用前缀和随便做。想一想不对啊，直接求 $2^{number-1}$，，，， JZ10 矩形覆盖随便做。 JZ11 二进制中 1 的个数随便做。 JZ12 数值的整数次方随便做。 JZ13 调整数组顺序使奇数位于偶数前面如果不要求相对顺序不变可以用快速排序那种双指针法，要求的话就只好 $n^2$ 暴力或者空间换时间了，，， JZ14 链表中倒数第 k 个节点暴力，或者快慢指针：快指针先走 k 步左右，然后一块一步一步走。 JZ15 反转链表没有难度。还是用循环吧，常数小，，， JZ16 合并两个排序的链表没有难度。 JZ17 树的子结构注意不是同构！！！考虑好什么可以是 nullptr。 JZ18 二叉树的镜像没有难度。 JZ19 顺时针打印矩阵没有难度。 JZ20 包含 min 函数的栈考虑到 min 随栈元素增多而下降，栈的每一个位置保存原值和到目前的 min 就可以了。 JZ21 栈的压入、弹出序列压栈序列出栈顺序可否为给定出栈序列？元素不等的情况下，每次模拟入栈，尽可能按照弹出序列出栈，看最后栈空与否。 JZ22 从上往下打印二叉树bfs 就行了。没有难度。 JZ23 二叉搜索树的后序遍历序列一段小于末尾，一段大于末尾。只有这两种可能。递归下去。 JZ24 二叉树中和为某一值的路径没有难度。（没有考虑字典序，，， JZ25 复杂链表的复制神必题，，，深拷贝一个复杂链表，链表除了有 next，还会随机指向节点。开个 map 就行了。注意要立刻保存自己到 map，以免出现指向自己而死循环的情况，，， JZ26 二叉搜索树与双向链表把二叉搜索树转换为双向链表，可以保存子树范围内的最小最大节点到全局。最后返回最小节点。 JZ27 字符串的排列stl 拉满（）注意去重。 JZ28 数组中出现次数超过一半的数字摩尔投票法。可能不出现，最后再检验。 原理就是当前候选人和所有人轮番击剑，活到最后的人也不一定是众数，再检验一次。 JZ29 最小的 k 个数top k。看这个实现吧。 JZ30 连续子数组的最大和没有难度。 JZ31 整数中 1 出现的次数（从 1 到 n 整数中 1 出现的次数）简单的 dp，想清楚递推和递归。 JZ32 把数组排成最小的数首先肯定不能用字典序。然后要排序，那就字符串 a + b &lt; b + a 作为排序的依据吧。 JZ33 丑数丑数必定由丑数乘 2,3,5 得到，维护三个指针指向准备被乘的丑数，每次比较三个。 JZ34 第一个只出现一次的字符没有难度。 JZ35 数组中的逆序对没有难度。归并排序过程中求就可以了。 JZ36 两个链表的第一个公共结点双指针。两个链表为 Y 形，a 接 b b 接 a 就等长可用双指针了。（玄学错误） JZ37 数字在升序数组中出现的次数没有难度。 JZ38 二叉树的深度没有难度。 JZ39 平衡二叉树没有难度。 JZ40 数组中只出现一次的数字经典题。 JZ41 和为 S 的连续正数序列随便推一推。 JZ42 和为 S 的两个数字没有难度。 JZ43 左旋转字符串string，没有难度。 JZ44 翻转单词顺序列拿 python 做，go 神秘编译错误（） JZ45 扑克牌顺子出题人不会说人话吗？没有价值。 JZ46 孩子们的游戏（圆圈中最后剩下的数）研究一下约瑟夫环怎么推。$n$ 人报数 $m$，记 $f(n,m)$ 为从第一个人开始报数最后剩下的人的编号。 如果人从 0 开始编号，首先会干掉 $m\\bmod n$，从而 $f(n,m)=(f(n-1,m)+m\\bmod n)\\bmod n=(f(n-1,m)+m)\\bmod n$。$f(1,m)=0$。 JZ47 求1+2+3+…+n神经病啊这题。 JZ48 不用加减乘除做加法想一下，加用 xor，进位用 and： JZ49 把字符串转换成整数写就完事了。 JZ50 数组中重复的数字标答不好，随便做吧。 JZ51 构建乘积数组就前缀和后缀和吧。没有难度。 JZ52 正则表达式匹配暴力。 JZ53 表示数值的字符串来写正则（x JZ54 字符流中第一个不重复的字符有点技巧的暴力，队列和 map 结合起来。 JZ55 链表中环的入口结点双指针好题。设起点到环入口 $x$ 步，快慢指针相遇在环入口后 $y$ 步，环长 $y+z$ 步。慢指针在环上走了 $m$ 圈，快指针走了 $n$ 圈。 慢指针走了 $x+m(z+y)+y$ 步，快指针两倍快，走了 $2x+2m(z+y)+2y=x+n(z+y)+y$，$x+(2m-n)(z+y)+y=0$ 即 $x=kz+(k-1)y$，$x$ 刚好是 $k$ 圈 $y+z$ 减去已有的 $y$。也就是说，相遇以后把慢指针放回起点，两个指针每次均走一步，再次相遇的地方就是环的入口。 JZ56 删除链表中重复的结点没有难度。 JZ57 二叉树的下一个结点没有难度。 JZ58 对称的二叉树没有难度。 JZ59 按之字形顺序打印二叉树没有难度。 JZ60 把二叉树打印成多行没有难度。 JZ61 序列化二叉树没有难度。 JZ62 二叉搜索树的第 k 个结点没有难度。 JZ63 数据流中的中位数经典双堆法。时刻保持双堆 top 元素的大小关系。 JZ64 滑动窗口的最大值经典单调队列。 JZ65 矩阵中的路径没有难度。 JZ66 机器人的运动范围没有难度。 JZ67 剪绳子没有难度。 牛客NC50 链表中的节点每k个一组翻转想好怎么接链表。 LeetCode Microsoft8 字符串转换整数 (atoi)注意截断。如果新数超过了就要截断： 13 罗马数字转整数想好就行了。没有难度。 20 有效的括号没有难度。 21 合并两个有序链表没有难度。 23 合并 k 个有序链表用堆就行，扔进去 listnode，按 val 排序。 24 两两交换链表中的节点没有难度。 25 K 个一组翻转链表没有难度。 28 实现 strStr()kmp。 46 全排列没有难度。 47 全排列 II数字可以重复。导致排列重复的原因就是相同的数字出现的顺序不一样。因此先排个序，在 dfs 的时候额外加一个条件，就是前面的相同数字都选了。 71 简化路径拿 go 写（跑 91 解码方法没有难度。 94 二叉树的中序遍历迭代法怎么说？用 morris 遍历。 迭代法搞中序遍历的难点是一个叶节点怎么知道后序节点是啥，，，所以每次到有左子树的节点就先查询左子树的最右节点。把这个节点的右子树接到当前节点，然后去当前节点的左子节点。 这样一路向左，接完了叶节点的后序节点。到了最左的节点，因为它前面被接了右子树，会回到比它大的第一个节点。此时再查询左子树的最右节点会发现这个居然还有一个右节点（自己），便知道自己该进去了，然后取消掉左子树的最右节点的右子节点并把自己丢到 ans 里，去自己的右子树。 太精妙了。 时间复杂度，每一条边只会经过两次。所以是 $O(n)$。 98 验证二叉搜索树记录子树最小最大值就行了。 101 对称二叉树迭代法怎么做？设置两个待检队列，每次检查头部元素。放元素的时候一个左右一个右左。 114 二叉树展开为链表注意复杂度分析，2n 也是 n。 116 填充每个节点的下一个右侧节点指针利用好已经存在的节点。 117 填充每个节点的下一个右侧节点指针 II注意先右后左！！！ 124 二叉树中的最大路径和简单题目。 125 验证回文串没有难度。 146 LRU 缓存机制看前面。 151 翻转字符串里的单词可以先翻转单词，再翻转句子。 160 相交链表做过了。 165 比较版本号没有难度。"},{"title":"华科 Java 笔记 1","date":"2021-03-01T14:12:20.000Z","url":"/2021/03/01/course/hustjava1/","tags":[["Java","/tags/Java/"],["笔记","/tags/%E7%AC%94%E8%AE%B0/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"随便记一下 基础源代码 .java，编译成 .class。 applet 只能在网页里面运行。 javac 编译，java 运行，jdb 调试 java 程序。 Java 没有全局函数，没有全局变量。 main 函数签名一定是 public static void main(String[] args)。 .class 是字节码，可以在任何装有 jvm 的机器上运行。 命令行运行 java 程序的时候要指定 classpath。 在存放 net 文件夹的地方输入上述命令。 Java 有三种注释，第三种是 JavaDoc 注释 可以注释类，类的方法，类的数据成员之类的。 输入输出和成员System.in InputStream 的对象。 java.util.Scanner 读入。 Scanner scanner = new Scanner(System.in) scanner.nextDouble() 之类的。 java 标识符可以有美元号。 常量用 final。 函数里的局部变量在使用前必须赋值。成员变量有默认值。 值类型作为方法调用参数的时候是传值调用，引用类型作为方法调用参数的时候是传引用调用。 值类型 boolean,char, byte, short,int, long, float,double,void。 引用类型有 class，interface，array。 代码风格检查工具可以用 CheckStyle。 &amp;&amp; 和 &amp; 的区别（除了位运算）：前者会截断。 boolean 类型和其他任何类型不能相互转换！ 二元运算符必定先算左边，这个有规定，不像 cpp。 switch 不支持 long，只支持 char byte short int 及其包裹类、String、枚举。 从大类型转小类型要显示说明。 一个 Java 源文件可以包含多个类定义，但最多只能包含一个 public 类定义；如果 Java 源文件里包含 public 类定义，则该源文件的文件名必须与这个 public 类的类名相同。 函数和字符串Math.random方法生成[0.0,1.0)之间的double类型的随机数 由于字符串是不可变的，为了提高效率和节省内存，Java中的字符串字面值维护在字符串常量池中）。这样的字符串称为规范字符串(canonical string)。 可以使用字符串对象（假设内容为Welcome to Java）的intern方法返回规范化字符串。intern方法会在字符串常量池中找是否已存在”Welcome to Java”,如果有返回其地址。如果没有，在池中添加“Welcome to java”再返回地址。即intern方法一定返回一个指向常量池里的字符串对象引用。 字符串对象创建之后，其内容是不可修改的。 StringBuilder与StringBuffer(final类）初始化后还可以修改字符串。 StringBuffer修改缓冲区的方法是同步（synchronized）的，更适合多线程环境。StringBuilder 快。 形参不允许有默认值，最后一个可为变长参数（可用…或数组定义，参见第7章数组）。方法里不允许定义static局部变量。 子类实例函数里用” super.方法名“调用父类实例方法。 引用类型的实参传递给形参后，实参、形参指向同一个对象。但是，对于String类、基本数据类型的包装类型的实参传递给形参，形参变了不会导致实参变化。这是为什么？这是因为String、Integer的内容是不可更改的（里头是 final）赋值实际上是创建一个新对象，也就是指向变了包装类要和基本数据类型行为一致 java.util.Arrays类包括各种静态方法，其中实现了数组的排序和查找 二维数组每一行的的列数可以不同。也就是只指定第一维大小。不指定的为 null。 对象数组可以在声明后的花括号中提供初始值，int[] arr = {1,2};，int[] arr = new int[]{1,2}; 之类的。不能int[] arr = new int{1,2}; 当创建对象数组时，数组元素的缺省初值为null。 二义性只有当名字被使用时才被检测到。 数组的长度用 length，字符串长度 length()。"},{"title":"CS144 Lab 记录","date":"2021-02-12T15:26:44.000Z","url":"/2021/02/12/cs_notes/cs144lab/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"计算机网络课 Lab 0手工 telnet 发邮件来个 163 邮箱的 netcatnc -v -l -p 9090 监听 9090 端口，用 telnet/nc 连接成功以后可以互发信息。 webget使用文档中提供的包裹类即可 简单 stream先学个大括号初始化，这玩意又叫 initializer_list。C++ 11 的。 然后就拿一个 string 当作内部存储就好了。 Lab 1实现一个分组重排器： 一旦能够排好，立刻输入到 ByteStream 里头，这样应用层就可以读字节了。 Lab 2first_unassembled 即为 tcp 中 ackno，first_unassembled 和 first_unacceptable 的差即为 window size。 ack，ackno 都是 acknowledgement，代表已经全部收到小于 ackno 的字节。 ByteStream 的下标是 64 位，但是 tcp seqno 是 32 位的，需要转换。 一个字节一个下标，SYN 和 FIN 单独占一个下标。开头是随机的，也即 SYN 的下标为 ISN（initial sequence number） Lab 3lab 3 实现一个发送方，仔细看材料吧。 Lab 4把东西接起来，实现 TCPConnection。 文档摘编： 收到 segment 时：如果 rst 设置了，立刻结束连接；给 receiver 提供 segment；给 sender 提供 ackno（如果有）；研究是否要返回 ackno。 发送 segment 时：看 pdf。 tick 时：告诉 sender 时间流逝。可能提早结束连接，或者干净地结束连接。 主要还是看文档，，，然后写出来的东西肯定炸得一塌糊涂，不要慌，先 make check_lab3 确定都过了，然后一个一个慢慢修改。注意不要随便 debug printf 输出！不然后面的自动测试过不了。最终我的 benchmark 为 4.6 和 3.3 Gbit/s，很神奇。 Lab 5实现 arp 协议，通过 ip 找到 mac。很简单，照着做就可以了。没有特意降低复杂度。 Lab 6最长前缀匹配路由转发，好写。 Lab 7这个不用写。 结束啦，撒花～"},{"title":"面试突击人","date":"2021-02-12T10:22:15.000Z","url":"/2021/02/12/miscellanies/prepare-interview-1/","tags":[["杂","/tags/%E6%9D%82/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":" 4630436162ade97ba2718b7d0c4b3b6351e3b167c5c2d058e20f52aefac715f954cf5d6b47af194d7812b57d0d53702b499b74601b72f3948a3a759fb4baabb23fccfd17c80b1a1254efa13c5eed99aeb9c0a5e2ea22a3b6fc16059bd67fb15442e86c28a6426a58cbbbc816fb8a2924845e2e27f1160d1b8291d6a846ab9c644d5a4db1fc1240a8d63b746fd0c562b0378fc51993561c3994969733f0f8149725aa14dccb64dbaeaf2942a262aa5090dd28cee444d038058b8a1ff7103d825fc40273dbd19b8e61bbcd3b64d1703edf46ae20b3720f36f6ae246647fc0d99f568f223b7cccd8411999c31fb3523656bd2a4ed9ecb7f61f499be920d213893f4e00104d6241a43f48793a851275e25568eda9e6a0a7a02c93290c0612583eea7efac7aaeb0571cb93b70809349c82233152c8e81f1cfcd2be8f2390d7fa822114ee49547e18d3d550b564cee483fb00c08bd1c57c8a35f9e290dc8843fe9558d7298e098c7df536b278c6a987879f6ae2eea67fd57e075ac0e589900dd3454cf925932d43c0dd3823b82da71fe3fa6111fa0c306534d709b904fb63ae529ac0f1d066f43550e762466e3696e3f8d4a57bc574e18d4cc87fd44812c713ad2b527b682b8d96729144f7e5f71184dfe49076682a11ab72e2e5aab824c3ecf9da67541dfd17a410abf290697bee73acffd86e25f7b0eb063ea016324f92229edb94615dd7e7fb821209350c5d479488c2d5fdef37d16d5295161c0030e4652067220a4851f3468fba508639a9251b1491ce8d51a7c2ef51c3a2a9899b9dce6c2c425f12e8a18aa26d5cc8841dadc0f62ae684b7241fd73e152f1763e41fbdfede2c54d97a3aa12c069bc1280b55d03a3e12ec0b465494c2152b58ff8b2aec0ee04a531ab574e510a05c7564f2da21ad624f49515379577a9630176610545b4be99a2aebdb2238a4e755bb6814ff302a1bfc17cdeddc28ce2dcd81f6e1350d6a2537330160a191f069fabefc6d27df3e434838f2470843d5439235b0174016a77b6cc607e65c2abd5648f42b904d0db4a56819e1aa68c58fef4fdd99895b29bd9ff0cd2e106a8cfb34739f3d17a7ba35232342c8f591d4a472573698859511681844010e0971937162f0a6ded02ddf050623f6a5491236eea598153add3d26e4a1f8a3f3efa1cb10dc0e94a740cd9077268a74db0de5395e8e1859c4e5e94acb3673018a91eeac1912aeb025e64c004dffa432bb6619022c79ff5dd440f163c575d0396ff53c7978b6f345fec55fa1c684c45b0bd0e49a41998b22c324d180de3ac09f6d6392119f5d90e6e2e36bf99bac065e33bd077eac3b473e8efded789078fd22273f6ddb641446f0850b913366189da1634bbd441e5fcdba46ddad671f871b3477ef8432cc8b0d32f12c717eccfab25f27a0262695d5b30f0d662ae25dc120eb6447d18d35ec1d2498bebc8ccf5105c2c7072a263fb01d3b7d0e8ed78ce9242cb233162b12f25823fd961f18342cbf988de83802d54b063c02bfd5bfb10d38b8ff3ea940957bcb047c0a1813729b398f37064b9176a1aa76a14a80b24784984c13261af63be618e065a2f3ce3f17e50c349d310bf852f30cd310010c462db703db90e207d34df9080a12d8a7fb51a63cff712991138ebaa92fd0d36f4eca009c4772bf92f50fd2b0891493f133da4840e78f101e2890df914661fc4ca09ca8fb1690e96cc3e308e21d6a799a3d7638d492109cd4ef468b8663a191fafc5394a0ec646a2cacaec4089272c46d81eba96d1fc05ac8f518065dea58c61e321ebe7037b7ee8e728b1f2996a8fa1e7d782e47a70989ae2192c6a3a65023118541f0f3efdf8b8117e98361306f301b574b40017e02c58ac1ae72077deb8fdc8f2f362ad14fda623f03b287581794ab3dbf12eb99857b144932cac60cdbd48f4dbc2346eb23892a4ed17e1ea26dbd4b5dd27d1c0c2f02e2e3e4f3c1b6931fe2bfe1e4a5ac03d3a49814c497c96c17f2fee36d3dd08d78bf6ffe0426086f9d4791230dd36d249e4af910431224922cafbe412699e6a7eb81786352e7da45d03c7973520af333df262dc8d7ddbc6c73253921f79679d3cdf3251b073d32f2d71250a2e023b634f63e5f515e3a9e9097fde6d4566db78775e856031c71166a7fb623ca3e2fcc8e892a7e3fe11d704b72512cd0ce6516a91c6dd54119e2926418dba1fa38fe9312aec1d891d370baecd0610d4a3e21e9624ddc3fa33d496a13334ff8293bceffe33edcd3e11365f333dc755c59dda126cd634267fc0b5e5d59096da3e7400ac45eeea3d3538d581c1b06473cc08ae6ef7044415e244a11c423c64de830273e5461b5d9a5de0cc046bc11ab6a0f10c687e3c4b9fe716439828117918b38404e5c06a190abded4f85c7de881a81a1f13d7199b08c399f34e0a4fe958e06e23b8317e0470cd61ddd833929424b0df8269550baaba6389b9b300b0a06a3b33d2ca135a4c220592fc55d977ab6bfd79b8b30811e1d806186b8a35e6bb1d016c91f297fe49c8d7636df091290f3422706967cd1dc7d25642dfdfff240129198b5423af1a8449e9d11466768f789a37cf15d187080407e12027158bfd0911588887c855e281c9a5b6cea9b2b6d3c52ff1e8c94d31fa9aec541c44b7caac5d93bf082776b87f99776fb4d892cbf59aee546f49c1bb606d36451471ee357e80d2437d6c00b16b871a3bd07e29068de3554d8b1bbefb0da496ba8fb9e893c6249942099bb2a80a94c8042471ed1fa87aaa37e7bf13cf7da4b111370900cd591ace57ec2887a0b8284a510a894dfd8e66a681e6171c5e504e05fcb0b971f9869664d201acd7e0465c01e7a9cedf5ead8e7f115cc42b09c951fb4236e2fb06686495966cb2297acaf9367e4ad308c5d8b86d9f0b16289365430b5c7ca91fb657647b90a9cb84ba53fcef92452a246a5bb0886c5a7ef51ab6e58ffb061a1f1b4a24416b552f6a3e1081698e52d635e93b9c8e469917b66fd4fb8f606ecdde2cf386fc1fd95dce8aa79bd05d8e8d8cab350abecf6649b5fbf20361f545443e81e70ccf0f00398dc2e4fe1208991aa91545e4c75199aaf1f8f744574e76b344be601550faaf08b2c2f4489867156ebb4bd100c15091b1341e64db360739873b678eca52fab1becec1ef0bea0cb131685a5696e41487e787d6958632064ca657451b81a3b3cf387ce01580aaf26f6868545e9a49cf8bd05f7082defc56915a765244072690083eb88c55f466a21582fdb83b6b1c0db01a08774591b0f2a2991601793af26caddc190d22bda9b1bf7dd7163b0fe75c1fb1f7e44762440341cce9556524c0115757e428bf5176162d89d737cd474e2b453112350690dcedce3ccae05f7bab13c9d48ab1ee865e27e479a5387ee7ad4ca7cefb74fb941b3a12710bbdfc006aed6942d0d334ebd30591675db3cc2229b42cbe33ef31f8f2637d08cb9cb9f0bd32bf2f43bdb59eb1ec2ba1b60e6c9c435dfd4bddc5b554d8dd575cf17453fb1e81a8845078712bbdec945fbe9220a5e006981db876260b5fc978fbaf8ad0a7f27d34b8223c30b3e2ada9098e4cbfb1b468151e162581d5cd3d4f3791433360c0168eac72b5809787b86cbbd2e6d4b42578bf1b8d425993171a044102a591cc078c38aff18c65af4c8eea7a562b8acd146659e926cb132f83a55dcff63f5afb5815476eb1eea3dbe34de924a6a3ce8a6afaf10b15c67cc175db8084f4ed475a93445d719c451eeeae376e11292def6befc114736a3cd841d46e07feedd0ed201ebc6bc0fae8ce725856fee2756df21237c26374b9c73840e1d9079317dce4965316bd744b37ef1741a3281d0a633631ee757b210c58148674a4d958f83a1a842c18d8c1de69c1c20e6793c6c512a743dc97e5d8d78e5142a94d4e2a1af14ff397b3fb240837916e178d57abec0a8250b2d0d20963fe6f1f382148dd43680b9cbeaf5f12480e112fac3f5f4f3326897cf751855ab394868f7c9f0eed71a488054efe1c125170efe5df721a21fd10189393417116aacef06260ae0c774490046083bfd5effb95698b025358b361107d3c9d5b2983548a2da896940c779df73f39c85d4f56260f429d9322fa029b5a62feac918249c841f2e80221e38ca5b152264e9721b67a30c9924eb3cd50a68fe3711e23921900bb594c9406299967ca9293f17f5e93fa885fcc0c50cf57f80c4384369b706b02db4567b4776d02b9f4b6ac7e9b6a6cd0cb3194c6dc0981b3e1a87448991eb9e91a0e5765b0880f239a554dd728289a87efac1034df1d3370e7171382750db89ebcf7bb8c5718e06ebb2489a6f27d838abdfdb1c51dadef0d4e564281c345e3da2969120962b9a192103185e3b98e0cdcf00a6b7d3a8713f1dc5234ec64db5f8f03c1d80743a8d05e23dea9f67a0b3008159aca3bec878ea07c033f4c92eca401a2ce84cb3e1521d9ae6c1606bc0e1135af678c4368b12095d3d486bfc4663d2ff9f022a1ebc5e8f317e1b5ad24f212f4f2818f28991d91b7ae7380ccbde45842ea4b3abcff93dc99b9178ab11279ac4774d74d7dd44d2a3642383ddcfc259b3e610bb2a89d6c7328c6b196ce1c2ca72f8375765bcf18b0dc0474d4f6bbbc3c530a7a289f561eea0dd9bf314bb0cdc78d16c170017a9481dc397efca8c475ff24001d7151b972e8a86ea8c052d111e36064460d2adbd970dd7bb74b71b5a50b0d57ac0fd81b558ea6a1fd26690e5c63389f19a252caf1f5792516271b9b65172d11488e8307035c840a6fc645e39d80da95f55197b693073c361139224cb1fdf43be39f30b4d941cf7231120f100f97909072e1a3466cf4ed4a3a8164f16739f725bed7b3079758cbe41df31cbbef3abecc0abf82978fbbd1c8f4c066dfb4c09fe2834053325505c1e9db81bd405e411757d646c0c7e11d099a44f452c12ec1f8604d28539090982c508789fde8e3150605aeb24bc73380da7215579f269eb83a26ef253008c5d37b40060042242b9e47437e72b0c0bca5d0d2c0b09df0461714bb9cef0d54b9481e9719cd9be9d31837f2d80668e908e4b4a7bf0cae51141feb579585b98782af8e772a3c3efa4b35785b80973dde8bb9b13c6fb42f2058dd598a588a96fcab16e6ee8d9e9601947bfd684f40defe8ddb1d09af046c2229b2eabb4dfdc38e1560db73a9025bdf415707b65e9a78b68bdcd617e9baee74ec0cc76e8def1088cd6752b249a7b65c242dc6895e1cc7cb1505695b730bb17f7243e0e7cca9ff33955182c570fdc0628db40c527c5d10eca451fb919370968b9032101f282093ef6ac481f33a500e5c71d5efc8212488fc78dd82caef1ed50a3c2868dcbae02f330b36f1534c102597a39991455b0ade8753f00c4f2231c2e41016e3bbd96cdc0071198ca19a6d741bbf585a3b9452a83ac565045c9f0e4de75f5124bcbad6101336150e874c9f02aa13cdfdeb231d4ab3c2df1354f009b54527a4f9373e72c5212eecc1039e093d53059e9623a7ed436b4362f390843557eacd9d454176c33ee6b41f42be8abc46e45ebb77bc1f73cd1b2d80f2513a765f4167727cbb5b0105fe1bd0e46005734e5ace1627f5d7c6fa2caac986c981479759471ba761cb0f8cf3028448aa93575771f40c4a3ff99d7995f53d51ba63314d9b105b782bb7278093b0f5c1356837b85c774371e4275da2110dd5ac409411448f2f016098a8298488a791b64f71f7e8256a3242c2ec4deef3703a62067f6fd1e8d4e66858afb007388e3ce1c21bd88860f7f6cee91b4b5246404e18cf1c9039a914e5d74c76eb9975f12c39b4bb38cef0cda3f52ad5dbb1f237aa1610d904fc6e2dcbbd02c2258902bf7a6ebf803a749558456b77dc39934370274f3d11b5442e8561395043631a772827980eb28e9b1c729c461fa3143b30d14657ce300246184b231694dfcb4e20f8f07b9834085f765d21ad8e0183d224b0e609347c58d328c05d1f5f4e7d75d7774a22f9d4ca80914d71713fd7cd964c77b1d78d951731f9fb349357f12847c237308c98fec83ae6e1a9cf59fa94b25d3751168497f3d2e93dc1c271f90202e37acf0cdf5d6416b50c955e6588c0d83cd2a8a6f9ff97e641ccb0ed5764a0e3e90b9cfcc38e33a3ea199149830d3c1129afcc999410a2a56074b3ca454599b085b84a9d4e3cef3b09612ad906ba55b3bd9e3412525bd5c4b66e33e827e394027a84dd25e6bc5d11113be769eb5028e4c5e83a037165922d9baa915ed9338ab074704e17d11950606bcaa0bd60954212a1bdb9c2de2f0ee1803aefc4fcd4bc8893ba3a33afe16f179ddd7963e544108e630ceece2d51467afbfffc11a80d0ee720d81ac6c5ca6fd2b745e05293332543374100c89091f59c17dfa92bc44f96cb54ec609899f5b65ed585a76d7564112a6d90f299d7cef7a2d38be45ada1e5987bf7abda2db6558beb5ff0337a3056a7a832e7abc028d1138fe48774ad0c8b74fbbc0082737bb3e0c29eb0f90b50dcccc759a6813586de3a3534b8d8a0f101b84b842bf1637ecdfe0427d00d911b5a9750d70c952f2ac36b5932fcbf5121da55786343025c0b2e0cdf12bd8aa10bdb8c190c6618cf4a195ce9f2e7d8db8ba4d5c149a6d560f6f914858d90ffbe76dbe5dfda9c2cfd1e23b09529e082c6d33e2600d5614198c512e98f15b3afdadd117e3a0a9e8111e7e89cd488a915eb1057ec02bf73f62d84bfa9a3a73ec9eae9ca06bc7141dcc31a07a18e6778926f4276b2f8643a61ab2dbe4a3ff4c8db678e80b6b43302076372b49cace36ec3c89272a7b455f3adb1eeb6a8c864acfb81a5ce40483fe48d26f4c456f8a06d40467576f2f1ae9c3dcc918dbd8ad6f56eb6782be3ddf0d5ea861a004df493021a1d512fd552aba2bc33207fb2866ac6dd9dce9737c9402478132f7fca0e656fe9a467e6fe661d2500579b1c269daf3b450178c1c849a9a9ca48100dd43a5f5acd7634c866750f7fe3f95f1a680b121253a06e11748533b04eb2ece5a71647aefd5f52970645dae0bfa45e5a2d92a2da9df5ac0e58d8a2eb9f270d965c17f2ba55f10eed568f6e83eac1187116a60cb44eb0711e588a41a4a519b9c069dc442779114fce085d353ddb352aceb845d4fcb382b35f9917f124ce0638ab3c37a34f2bc4a651d58b2fec2e1831f0b838741af1eddee8235701f1ab7c8d0b5648772216ecbb8b99224e6716a0352817dc870ca2606821fdc7d54d4aa1329139d0c89e7b4bc31df255567f1f7929afa0de10e9f8aa8eeb36f78e5300bacef549d62ee9a37c1e079641b993c945a77f2bd2dacaf2ae4ffe7dcbc2092174edf4efcaf0cc58106f070ea8bd6652050649799a0071fcdf6f0543c72b19d1008cc82e9308a937debf31629aecc783d7a614fda4f3ec22fdcadd0d40b4dc74f116ddbc87c17fb480c01f45775c2456f4768e87c0be7bd72bebbf2b06800822d5c427047d80fb33868c07bc30a573ff68478268b200959b9a4bd1d9db5d40d56d0880c64c2d50c99cbf768b41c29a89454a15b49a880bf12e049ec7b6c56c2fb242d50aecfd465aa6eff9cecb8515d23c38c249775278441b7954d644f76d0449465b5b3961c5bf797cfdd6519fc271a7328c7f2d685a6a214d8ff98a8ba79206d637371b30643d43b668301831aa17caeb6754a47555e725eddb10c6f812c94b77e48a71a8ca526c762a71ad850ca2517c4404ac8c13ffd24dca5e149e4d6993cb20424e5f346fdbae55e09e8229effdd268d183044c00cb0b19eaac6e1628e1c0d3f74e8d22c3e1ee5e3f783708f9a774d305f0622dfcab1a74f7da77ca8cce482114850e0fede09733a8da667cf409c513e8cabbf94d2f7391cf31dff04cd7931a5a385990e4d3e5b018f6022fe4b1043dac35eaec9cd236b3ccbdefe4ab9aa3810bedbed40e7c7c0b71721dced3fc85208994ed24b0f2961c8d056b0a5eee8af2ef41c25f47b8ea0f9ec0b3beea5451a95fadf43d2a9ab0118070b2f829a4550bc07670c59df1bacc2f9d78f49b83fb666df4fec31187532c55be1256370929f43d52287d894042980cf9adfa560afca934e860295b85c2b9b2bcaa04e1fd72a1a00899fec75be209c10148abe8e94b40460a3e48ab568451b497fd050be8213575bec228874e08bfe4070a5938ceae18580618f297382125d6ef32f0082299c395a9478cf58d3a4adbbf8dfdca22eff977e0752105efcfd8ca826a32318afa00b76ff05e445e017e0ae0bade75bcc7fe0710b963d2b19abd73284f65ff274df0c9a65e146a0cae764f47376741129ed656f6c571ccbd973e0de1e531ec52dd96dca3364b8ee30c9444742e3f1c1f3e0f47f0271ee599569ebe4ebcceae03a2291455e21fedcfb21475c261162bcc1717f9597610fb4ade1506d727ea99f3a8616b5452de447ebfb71a05efa64d27dd8e9f1a80c07a1105e92a60f65d5ca3713cca0deddd4822b1df018394e9a8a04b640c8aabaf328b36df87177d399bf9aeaad6fae58be979775efb170d1e7467ff239ff047d09d6f41a7fb171283803f7b5628213e3ef2c91098bdd69190cc2f4035e93ae8040a3f779815914d3f46a82424df705fde62bba8128a484045b3bee4f9ae0ea601d7e4cdb819b92867a07a74b43d1f1a2d997d42c867fb44eb62095dbd57178ab5e3e09686cb8ca4f7118f37d58cd1bea1ef8510166b56695ff2a5f64c6d6281d9146368f33d4e3b2a29fa99295eae70bb8510d1fb21ed0adbcd483f3817580157ebdd9f6714c417b17c1066e92504360d4c2cf3462ea3cebfdf940451bb4063e280bda2041680c178fc143b7fd6342aa53ca2cf9ebcfe77b2947a18dfb1e9ba3f43ac4862bafb5ededca954d9b5dcacc821a1019d85101ee7d7329963660f324dfa589a3eb9e6c342bf194fe380cc1cf5a284d06258c29eb4260de1e70b0edd8645d7bde3797395806e16e82c40c7f93117abbc97ee1e36cfb9988f97c8ab197256f9f59d2acc63badb31b065d2435351a4cb73d7ae1553d38d812200bf100e4e0d5751e4a3e7d4eedb399e78bbdbdb7503de32f005d9bcf68a222c77401ec494e32c795b99fb7478b957c4e303a31b39f342497a61ebda24932b41c176d9230cd3ca17ef427d7fd233ee66f65a595fe25799ac1ae65dadc5290a56d369b85bb47f64a2fe77d271532cb1ee5c36ef971e9cb16930060c64036d7a28ab063d4004dc8995995c07efa260d7ba5b85744eb7d9053f2b56af5d9a59bee2601adfb309e70bc42470e0188ad1d6f186d764eceeb3e5ef4886928ecb4d5cec39d2db612de3ad42872c7f815979b6c4a7bddb41a5ddef7cc025232107951d3f564919606c7526d3d0f49bc80a02870cbd345049d0d927b0f46a35a6fd9630033928b87434d67bbc924ddf099ac7751633d4a173b821476156c12533ca0b6d0bd0341f63927313c437eee17caa9b613f6677f560a274ce68091113493440c280b9f55cac51246b9d5a174ae98c0c8150b534f2407ebd515a43c9c4d64231f9a50dbfa865274b65d1c71213e5c65de9abc80be221798659422b859d663010b5850c5c71bf4560e9e46fac21488894e4139ec230fbd6da87ae0169605708fcf1d4edb228c99e2d0b21d8f7c5ab3fc63de0d82156a3953440e145b52bde287a1ef157f6a5538ce08d4166087b9b9dd480d99b279ea54bb4a92e59ed0977d7de0087f365a5f5c4076160fa69147521dac3c8b5facb1bfc926e0f525901e7e6f6461fd86964d9c0edff9936d690aada402043c230acc938794b1ed499baa148fc25084f8c6cae664b6311814ae501f043c322248c2a27f6c045177f3e5d00bacae2b271cb591c0b5f8301c4c6c5d9d43765a1dac3984bf937973a607455824587da50d88f01832815a844108f7e3805ce694701a1463de1cd473ff6f0ab9c84e325ae89ae970cf2267b8c18443944d99191a724b5054ddbf937d272946dec7abba7b3e11e2a56d1b2a1c1e927d82dc6e8d013c1b756aba5acd292f294af613f6761160e5b2403ce6cd66684dea2e294b50b639d39174b77abae29233cbd6ff418c16c347055c5b581c913d3cb536d5fea74d29a25c8de01fda7df4428bff37759c0afabf535722c46eb3fc9a21d88d10f4ecdfe1be31fbc4e95739805a6126a77279327ed0f7c75cf140ee8172de9aeb1dfa9e706df6a1323e9eb945cdf46c976f05fc796a644005f739178088a65164f55c6ba9088498715aaa00f09150df1b73fc0077694d4c94ba4ce4919f333f652db4dcbd959231eff1ba0ba028e97bc5c4f3c22c5727149af3f3c6cb9f1d2387123ab6b736845ec0f85f03e775916a327c6abca05216cd481a9a771423aa967e39fb8f7bf5094e588985316a248723bd54e0ddc8c95483b68fe8327fc6ec06400598fa1ad7dab3a648581a2fb3c1d6edc4d42a7a1442110f59643a0b34ae65a6074a2b44245e61283e131ea3d36ae586c01c050c6b8fb5561478b9042dce3893aa7e06851059aa62442ce74ccb495666facf1ebeb60d38c4414ed57e4034f8ab57aecffe84665ed557c2793ed66e49aef1a29ceb2f66d2bbd29acc2c241aeadc0c9ec6044076a66f8b6b9beac60cb90a3527c452de9abdcf006cd29e0fc8992ab308d6b2eacb8b385ebbaf41ad4e49eb555f54b045867d5ef9c38adc2d9449782e7927990eb795608c003758e944b4fd6ca9261b0d56f223dce97759a383f9fd9bacbfa5df3a9ee4b264383914a8c24f35347884ce8ffdd8bc265ac079455b0e1bf9f392254b8ae7b69871914c31adb4bf7b7d8241230492df64aff3f77434f49ff681d94858b43625d928ff6e8a70420891a09d7cf94f108c5a48739034674fa5323223336645171f0a92e6c68bc09d2b9e532e135ef4ec9550acbacf6d4eb4ecf297ff89da49df8e0d4a48ce48c47e2dd99c8f24c7d184b274f731825d2145d45a01f1e3739a22521debd52669afefc53e2ecf1f6fa4bc56e049262144711d0941fc1f3857f82748cf34798eb106e3391997da84ef65ff10a28a8f720294aef21a48aa73ffe793f7378994cd0092c5bde7ba886699de00577ef9f2c95d9079ad7143529f4311018e3afe3accbd630b9cc448808222ca72c270397a3fbaff9f6f298e7fa784d969c9de41dc1476ba278cfabc925c16bd1f7f403148530bbb3624cf3fa4cf92539e1775773064a53b237d34e422f43989b7f4da3aa3ab74866afcc8ccebd75d15efd6b5a7beb36372abe66efcfa61e0500460739aa05515f92ff0ff3b837044ccaf5b2e6a2369e627ea0cc1d33d8cd93464695ee4a12dae50e8661fa0a25e50276fc12dec51db11507a0dc50aaf21769f0350068a2f0cdca342b329e6a901ac63355c6c062d99aa36438a0fcc51920fa09ce7dea03e33cf5ac9999001cc67e5491b739f5c5c099275d8837ee95bed45bd6208bf43c3b74b5fc3728383acc268b72ef30b6f781de69a95465dcbb7e53b706cb872e9dfce26f59adc702f56d28f40a1e1c163c91dc184a6fdd7f5a88c067c4361083335232924fc2a18f3272033ebd1bc61c26469e4695dd7a92f5d91875cc4ec2039e06cacab9954af8cab5c79bacdf86994fb341fddeb87c3c1789ccc3cc111bd1281394e19712774b8738153f6c2cb5c66128cfa04c4e4bffbe698e50d9188b033fd81e13d5c3c7682342f99c53fc82c9e77860d25035bd341df5381fe0d7522cfbb50a6531ee1bf537406ba7ef3099d2b0144b354f117ef2f10c3ba76d3d9e1b41939dff99deee7dfa5ed985db4033424e0360a79f3e0118ba1a977326f30ee846e19531031ff1d3fd57a9aa0a058426b3ce24ff3bc2d354c5f92994bdc859f5d89c9537890b39941615adeb344e417295f18b22fe193048eb10571b5dba05ca2bf5bea38329cc04c9a9279fb1a361dd880506241eaf0e526e8630760450fa5593d28c8e33aa6a7b31b1acf8dfe0b85c8a277be3a660d90e8da547da87ca2ef9fbbd3a9e6111308806afee4088df39b20913bc8e0a59e756c08f2879152339fe794c7704e046bd0fb20af901fe11ba9019d58b1d4873d539b9dc98b224c80f65a88043f147a0fcf305be61282fb96c004017cd4328cb650c124dd9c2b6dd83bf9c9c9c5d8e62d58d455a78156849ce3f7a0bfa1502220ea73cdc2f91628cd64088fa3ffa2922ea7968fbfda52672ef52ff0448e256a36d642ef98c4ec77e665b9b1947accaf724c2849d7dee849773a6b1d19c5cf56ad083dce491ddf48b37bb2a83808d5534cf3a4806c72713f16ac75b0a4687fa7e5ed2d5e77b964b1f13d28238643f7060fef9313da8e2ebf5cb2fd464cf7e548103a89b57640054110c35c710d27ac14dcd6cc1f3654f225e5f42a0c1c2c9758266908ae98d41a5c61f27e91c49ad3e393ec41f58572cd55034c7289245416396287a37d8a52066e1e38ac4c0cfa100c49e1182546a61939640d61198424695924403025bfb631ed7ccae66c6e84a6ccb205cb7222597ed126c964a226e16c9b32e7a8af1036a73d178d2235673dd072e2be648d49f65e90685db9046cdfc7d9ede29c3000598da9c71f9865df521825416233dd7de7a126e2b48a943d388182c0b2c7bb5f84357ee0f8e06f2282236fd90e3a1d2ce9e5abc198333f9d406543a28b0d1459b52211fdd52e2c0528902e657242d8f179ed7eda9d9281c66826a417fabec936ca31db9623d29fe61b2171c9da1d8d898c9e708d21152ff0c3c12c5e99b38552ae4dffcd0d04740d7f67b7678cdef120845df22205ac06d52ce884a13f641cb826a4661380bb8c80d802002a099df92daaa122ce505074b9055997191f29ab854d0340c60843def928b866228b1eb5b515b4ecb8f5a17283a11542f914cfbd803756e9e10933a2ae92d9e646b44ce6f736b8e0f95ece4499f274b875953f0e8a4fa2259fa147187af979233e46636db9cf56ae95aacf31be25b7b3ee474ddabdacb47b095585465ddbb95aa90b141c36ba48c9f810a57792b7435ccc9d98bee029bd2109677d7dc7f2e674a6f2428d100bcd603f9a84a58ac3e1750da484da934205cbf20c4dc7a8feeec7bb58b040b70b5e03bc9a7cbb91126021a316af7286612b7b1c7a60f0a9b5133184ac993b00c65abe12c55ab25de089ccf0b2a3e3c079b7abdafa767605cd372e7a804550e604367b5430495ac15ee31e89c028a0c4c7b9ced9b6b2de0c215bed2d162d826c61967e946975aa20e65767707bc30aa0c03cdd05d1fc6c6c3b5aa1d661ae045de7b6a24e43cbcd0b3a0a71a3f2daaf2924f4579295237b7345ab22b76264f1db56db1bb0e8fa28582806628caee4fd11ac59e72621f89c006af189b1cbb24a2e63a671715ceeda541c307bd76a3280e9f593586bbc297dffb3479a92acb7c516df8d17f6e456c2cc0430cedb8ae511483e5f4f5ece03f8c59e274edc108cb14f7abf3e17503f3c04bdefcc18f4115ea4076bf5dd8dff35b1d1cff89dc0d19cfc20fe2c70c44928b14088d73ff2000317fa687c3063a61e67dc061f5e0de641fe0d9e35ed4d1e9b221dbbf984babfcf8e92a1a519e697b5087e2cef0de3c00b9ca61c8f48a0c91899fd6db3718bc700035622b3dc1f539fc77a80d746c345fe3af1b3e21155d6d7af79b43398c297e9492dd340764496d8d5d3c17711d11509d60c375a4a7c616fc1db8cf0280fd296a0bf8738b6f7676d30424460e467d2181ca1435b5bd9c67f8fb64841ea5c60fea5ce5e6ee17e79c4e1e610db1a277364f7ac3229badbcbcc0f338974190d864dffc46b8d1a90486a896816914ff8078df05b499e6db963670dfcf8e9086bb55c6cb86f293b0c514a1aa7dcad3b8570c51f411dc8b32a9127348210e10f75abf8b31832ca749f090e7289ae30a7293ac7d1dc43254d8cfbc29ba0f556b5bd56eef7c220742857d75c4ad2c6c47dbdc7714ad8da651373383b5c7361f957b1983d6612b01fa78d9e9c557c2e1dc95cb8c2798e477a15152af84e0f06fff2afd978d3660ec8a4ccc87b89914c2cd9355294ebc6d068a6012429ce984649b2dbdd15ecc64d5db7f5dd3d06905c2f10e64a642097fb4e78a29801acc6176347e156e428b7799939ac07e624c7892fc6360dbe5c9655532a5e43c96044932285aa1dfa0612768e991a1cd32c0e3d774dfe140100af0194bdbfd2557fc5ad1caeeaa515894ca4a5ac6b9493b1cc4821b38d1955ae34cd670ff117f3df34e524331c460e7989e8dfcab68bd3dbc94df3e0cf4a37a6e20e9982bc1a5da7166516f7464d0d2348bac4a161e5266e1392d7ae16839450c170ddc1be72e68540efb2b5c189f340637f31a5bf7b87516afaa982e7f01859da481480db5e360e0ffe1e7c54cc16f378190874861e8e81698e01450b1d5f79c4a59b86413c34d739f5bd05271eed51ca303e245a177cacce59cd7d3fc08366de823807828e078fc8c7bd600559dbdd9bdd8584b460847ef490e621dc5bb63a695e247c6c5f9a3587a0cfb12fa2b0423d370ce599dce5a84d72bdf0b61698c7559490ac604ddcbc0be33179fb91747f6da15c5bb5291fd28ac29c64de9f89fd9f6af4a17d6dd86f9f75a80e28482e68298227e65f5cfd22f8652cfc2a5dcd3cc00620dd65c221c1e6014efffbb453c9acb313c4e7facfedfdf8a3be0205c9326feff9b591bdf8192be45cfb2ff7311d1af94bfb95a097d9f12f4ababf1703c153283353ccc638c5bd6963581814923fb563d061688cc212e183930ed6d2588a63e6e57bd8c4cfa9f0e308608044183f3f21319671e7dc00ee7d461e40d2181977805105815bc8c8ceaca51cea2efee712cc6ae3aadb3964c613ab2e681c3cf51d9ca5511975e3048e3dd64933d7bd9de5af1b48c412b34e9990b8dd71dd1b72fc4437ee6b0cfc9b12350dbba655e02cd90ad5e84ffd755c155364b65e0730d403209789054c6a01d442eadab6a3427b31da05f1a25424d70837139a362a532bb16504ef3b6ec33132208b5c7ecc91644997e8d3493be77020c429e9444ee33c84e4e1ef143ca0bb74061942934267beb6387d7243341ec5bf9afb62a9b74f4ce11a826f82fa05513c51a904574e1116df8659a5e32f72154b0a296b88f2fdac93893330f41023b42f54cd8b03f709076e9db3093c01bf2bae8000516810347ce191af952cf883f9cf11ed87a74d56cc0f95353974b3e920f682f216239b151048f060f75caa7177a4051206387f69fa38c1fe7ff690e027eb53ad89dcc6decb715a093248cc47d4f9807c3fb465c9d1c3d49934da161a167a330a71b7ce5df67c66047590b319ba1ba3f2cd5805c74b849af7f934244a03d2f404dd2c18ac94ef81ca73a176191a580f61b92af3b6edc56f836e161c7d92697e19d8b47d92c7279b2eb226335c4111a392037e2570d437744836d2427b88154a71c253b7822cd9dfae4a018918aa6f76fcb20e003e46fe38fbecccd508a9bf7b38a35382bbad808817ff413b76be69cf990c236ed0694c9cdd603e098636fa1297c673f608401251606dca773d57e7f0fdd803844cfa504ec3aae9e5a26628acf5e15f96d75de06af9fd070c5ab8c347bb77617012562acf922bc9a17f94c434a3df82e5c45888a2c61ea4e0b895532ee93cb3f57dcd136849eab3080a1fabf7e58dc68fd6238afb10f6672d9ccc36ee3a7262dc7d9d903baa7e3e66ff669063c819e9c51ceed93eae395201294d979d33ffc11b47738445181f6611e94a4a3d4d32c16b29c92b8ba3a45b23f96004b141e5bc1fef79f6fe0bbed466a6d3b12308b4d1fbe2266d2a3119fa9ef2485df6da0433fdb1923551968ac457a89bd4ee5b1c9930c0096f65512c3ebd3d869f28b5eb260eb54b8918e11e7a79bb9b08a7de9fa0009a8ab2c8a1f82e4f35f83f1a84f06cfd98e3f5556ea187fc9fac4aa06f45ef63a30f89601020a2e4739124e92f3230f1a51a16112af5971274b4fbf450a0dd0fdc75437f20f371b63a4dd5896b23b2f93eabb7e1d440e9973ce287d00b85c90a761ad12766dd678c18655bd6dca3cd0c3f67994a9ea634a8da6718e2e2327570c161128300979c166956abb52fa3b1597ea93194b1147b00a871ef72232cba72601877e5b8be3749deddfb864ef0732156c0d10f17384f0431fde757a7d7d771212ba48af8b2cf96f904135ba0f18bed3138a3f10dd3fa936778355f3466209cf2d42e20324697136e54f3f24bc8abca7ec165219444b0605feed37c077db10791e89729d1e5455cd274d0e5f75d79536199a1515e1ba05e8856af2148214ae2d570d6b6426bce9fc26fa83ecdd3e4c2329c3793f966a5679034613ea1d097c0fdc4ca7a573f2ca42cdcdfe483239644390f2f198494529cf7eb5554f4541c24b25cb772a340fd809ef275fa216b13a9545dc2ef14434e54db97732d76459098e7ecf06f5c2c4a75c3e70a8f06037822a9216ba57a2084309c3b971a4f207bc9dca41a82a87322dd308481f3267dce2ab89aa9cddb2a083b4401dc253565ee5be10ad8628e3862c9d0433679c3d22b1659c9f4f8f8fe26b2abe9203ee9c495dc1e5886ef5f21f4e6948164c7405b25bb9395ab810a86d97698f696e78a722b42486ad5e104e1f429000d01a15c9ea107f4568a0836d2f13bd701d33b424305f0533e498611a238189576d7858f0c74f6c0357b9b13decb912fd8ad573d454013dbb47c025826c9859a988afde74aaa7d3615b56bc831f1ac44f09338f2da55b53121da88d63eb5dc38172820382e1cf49c08cfa585b9801ab81eb24130fd5a3382da58bf61dcceec0362163af798fd32c4aa7e8643b26dc8a7ac0c6db8a70c5189ae3f0b3b205a570813124f7bd6b0d0fd9af2792801aeda8917bbfee94159ee214c10960afa74378488491f9370fa4e3104d31946f69410693db4372179cf08a245e687b2d964e897dc96ae4840ca739ae3170902786a6892e8af59810007951bad360bb2d2850cefccae81ba410521a318bbefbb2736f8c00609b4fa917f45e1e22e559d3c4d58606b5a82d1bb158166209da81e36797e4c9bf255ae62416fc528d02c7312213e4c0c5897c3c62c9c7d7eace6cfde23c59d6836e24b6493714e97da478648737e9c2df1932a5f14eb0f5d6bc80436edd8e5dc9f125b2900775ece41fea948042c359e4001fa140785f5f5e15868199ebd44749d962202f1ce053db44bcb73e90a656fb4b90dee3ab8c1b02aa776b2beca0fcba414784c0ab55816cab7c26647ed0376dca47e889ad6245455ecaf6cb474300b4d4ba5116bac01125a9b8ea1b690846e3550e87b8fe1244b4e9cfac5d4f4420ad7d29d7d466e78a4e440a2660969f8fa4ffdb84e514198a142101d429ee6d78b560b2a94a98eaa1fec4f830a977bfa9301519775e2d87c1893c06487709800e962768286e2c3bf7ca8deb81f18d35af4520347dd39ea046517f7db82fb327e62f1a2ffe85e48b7c3a06d40332f22db8444c6b123dbaab6b9245c0b00ca35e9fcd9f902e47b37016c6ccc01046367d395eb8bdc2f7c013cdab95d352235b3467b49e23f0a4b998e7eec8c4307d4bac86640740be84f1891f3ad6d74501f1edd1dffa3cf4ca764284b32c9ec76665f26989cdbbef263d29252370ebdaf5985add17553ae0b1817f5603a690b3cb3f9ee98be4e719a29816efc9630a902ac746b8532f5071104c0cfcf197e7e5f96be12a1427e97a02c52ba9e55bf3ff7460204292b589ca2d366c2494865f9470523d78b4d66dd2f5bdf9a836cb40135b8d98385d238f155bb78a68cb8e6b071dee5edc7a686bc4f22d4fc4926bda7ec56c25c00f08aa5f21ba46b03d82aa881ffc6f5442269e6127e63f18e4db4998e6a8e04c6f66e82cbc12b3c2112a74024c54ee08c77348a0de053977b35c042c3b59d618514060efe318eea6623a57a40a1340a9bb53fb11ee20d64d4c3108f41dcd82d47cece9376df94ca4c2c92f7a011f99685d38710a7ebf7414ccde4c6e093faec35bb102713cc792578f1f8010bdcc2757ef3eef2c39bc4074472579794f65ebd1c5f78e5632d6aec6c76141175a73401d34d207a5d0063a475e1cc540f73357374f941ea0a90bc4356cf6608d808c52c930d15c980ffbb807b85fd30936ed1813f7810d144811967cb8be140c0275cf09aecece960cce319cf2b020e7f3913d941cf96ff6b909f375e02aaab4ba1e14a8dbe61863fd7c2c0c8d0bbfbde38def4e933f10289bade1ad8e52301d28aa5d72d53d716235a5ffb1b1a708ee394e489cd345f71a91f37ae01f2ba7e54904d9b1868314cb1a9bd7adebedc856de502372d5e2f6d311f456f3e04ee32cb1f09449f5cac460cd4f788c4df7a53d7f4a3cba1bcdffb90e228cf01c4b8a19620950ecd7550520f2a86c9453d9b0d2ca5f1de338d3980dbf70d3ddd3e2ac497e4861c71c2d45dcaeb01ac6c82ee0e91d8c8b55c3fce3f72f737ee87a95925ea35f73a94a7913170d86cc949989a9d65a95390f5c90774cb96f53c9e6b45059c9c2251d032e0d9ff64c8ec27d87cbed0ad50de6984409acb06f4cbfae5adba41729aa56d8a7003a871ac97c7e666493e30e94984e3fed23ac7347a31a442eb5c1507c82a19f93710a2f291b4612d35d3da2d9dd2f2cc7e0731e1bf163c5f1a009a583133ac9b376957118484b403cdc756827cef238e47178e79b489a54cf3f90cfb8c016dd51280d9a2c6e4764704355b1211cf2fa01a2b98a119b3ced1833ee9744dd06e69cc4b5fc76678d3b75f81bb770409da07a5e874d9d791a8406193dc942aefbf000e7646abd52db8ec115e523ab01b9d0eccc9c7e530ccf43e8f1ffa3715c320fed085c73655ef21addeeae3570d8f8b3b1bcd1329b74181e345aec5df238adc4663680959fea9e699dab70d41506b1dd97fb45c89d5d44a63f73e7c6142370177b1425e8265256cc0d7de9b7180db526874d6c785bb4b4ba5d2e3045632a5ec217bc6f9801e41bd50478c3eeff10c016d23db7223b28a4c7327fc8332fada112560aa275d355bdbbb1c2f9a7cd168568ccb4c805fbce60423e36625f664d8e5108e16ad02ae33146c8474c8ad47a3e68f04a5099c6d74bbdc4d8b95ff3af6a6cee4fcf631e7648ed0bec9e969068404bd2d929eb92ab447500767c85c439a7910b8c7bffd7c0f19263f7fe4c5a4afbf1bb35b2222485ef89de212458430c58a9cf6c85ee2d0736f6d26ff3aa495c6ce987bf4005caa1d88ec2f59b51f646663245799561edceb9fb3e91478b050d555675b3d6251c6569a6a9495541a5966bde6f7e85542615662338d8d314e48a65ab704833f20d1e7137b32c8e304ea16f25c4dd1f93822d80ca128dcbe09f83a61ad1da2c7c4a0aa38d10277b328941835aa55d7ee421d0e5609c50cf0ffdc687e04c94b7d54a029dc1b7e1d813bbaff858c90ec21b021976e628aca17d5eb887d72e7fe7dd707ce6f85fad51743e8ad8cce908b5d4188cfc9136157ea5a88dfcd1c7002bf97812e8e12826aef0f2aab3b6f89fb0a2f3240f3b042b5a415b6fc1eeb0541faa53517b5ca66926ceb4fa18c78b1cff9431ce4897f065e7582a32e10115759e7edea7ed5cf4c09ceaf7e16ccf11c970cb255f8ced1e39c7b0d4bb80c945b6c960a52bf1a71ba866df31c5b42be86f516bd1658b8ddb282366e193abbd14e1b76fe7be2b7b5bfc8d6b24327a3b07d2b0ad610c587261b2cb4e81ade3c7c46e93a676e8a729c0b3b5941f6e6328b34445facb4ff852d73de1dda2399fadf1932b8d1e74fd9b1a0fadd9799984f300cf4f5c7dec1d9eef7774ec745ded93e26f68d2d0f2323db51ea71488f63baed31e768a2288402f207b0ee6c5c10f740215b0190e24492b1e2dcbb2a945796205fa83e70806b472b64a63ecce3176ca22a3315cb2bebffe993169cd11457999202a59a879a55677d3d3edc037068413dca5814c21cc729d2057d4d642c855fea33c6057a3e8cd86d93d3a3a9d43d3158ec2aee6339868d963d1216a3e38bad62e6bf411573accb7867bb32ef84a8c91079a2b0baf93ae2333c70d5d76c0c8fa0664aac59f4dd319da986e6aa3bf3a2acff7d347b073b736c1644e2dc6093db3c7d38cae2f263caab89bf5e131c947ebdda1d621b0c7428de958d08d7ff14265c522e4e43c73a4a0d6ba71349b0010e09786a7b915705d0eefe700a6ce1752de53a5bfe5f73e1e4201095ef39d086026b98ae1ebef2910f5eb4f4369c98a7f7f92886702b7f808ec35f48fe4463879dfdb09edbfbeaf92be173b00f732af129cb9f37c52bc4b9b6c7914f96133cd740271d1e90a2ec520effc7e98bb5e5a0cbde7344e1c1d6aaf526d32b9993f60fb4c17c588c587136455d3e056f87e86669126d9470a1cbda9ed95e2d1c815fc661752fba0883cef49fd9f8b3c0a085590a6a2d8b303f42547b3ab8ee30dff0c4580fdbead77ca9923ba86515152c1b13266385299c3863eea5494397a52ff111aa1024994f65c6a9d0712a8827496fabfd53da7eb4bd2f05f6f3d90ab8b0a72a12ba04a7740c0422b568d2cf18d546b1ff54f24962fc539a601e59a5d76f90ba8bce4fb7993476663df3e6400e1c5074847ff76aeaa9aa4241b205d2b42d8f1f5b990b7d369f4d6e4cd3542a7ee559127a8b8541f740ba40dd43e042881c2e842325bfa17f29bd4d99f6f5a51830eb0fbb96c47146103b460b7c341fe9fd417462d6a0d8fc99ea7341e812ab67f06846fada52c0a5c8792985737c4d832ef15a35ba3dce6b9bf2844a23b795cd756b4e28e0a0734a6575364e8c77db10d524abf47eb0545d9dd27816a059617fb051c799d261d609744f9843346549eff93b90f66e36637b7a6d27eefc94a8b6aab18cbe0415b967623e3d6576124e5574ca48dfe6070d1b15f82e023b87913be6af14d5856f1b30ea2dd09659dd5a7dfdc1cf813f1071a8ffc43fe2711f9f3095f1f5d9151ba69a58b181eb2eac8124421ed902b4192b35eff5b022b40ec2b18eb8a8aa3df6379e8d87154686f6a9cffb7b17c39432844717e7857fd824a95b8c99e9f7db1de93360c09a7e5db45a78d555d707a4e9fc7c863ef0bf53b21bc706f0fdc4ad622a9a5aa50417138b8a653c0e8ec2513c31dee54596ef79635c20dc2803316dd14b7fc4075d840f59daea937ea326ae55f03c0d71d7bd9351cbae8e8efa41f59b17de396eeb4ea3fc77c5bde0f4a5445f39edacecb679ee6aa07f698505b7ddce347d12851b1505161efb76f4ef08da24932cab453d9473ef72b6449e0e3074bddca31e274e7d2ed42628bc1bcd8b6b73848098fcb6cc7c553306e3990b7f19191bab2843bee1dd547ebecb1a3e8ddbc5d2655a4a26001355c49a02a002a3ec99e1387e2d0e03d63c4d038876fbd00cd92a60b1fa4a052ad9d5798ad9b3c5eb98887a50dafaf4497789c781d30db9c8a307f44dd8767ce6c721c4f0f12112172109d90e5d7a5e4840016a9fdf93f3e0ae20b9617cc4531677f873913c9a1f690feea922170cfea2715a6b9543383d90abd3c6e16760b425d05a44afbaa042f6c15c1c179b6aabf4af8692470df23ebc58f82ada7c83b5da3c1ba056f82abffd8ed4381e29bc5ef5eb435c7ea3b5bd733d33d7296d8baab3cd68e12ee457ec658a4877db1355dc97c99cd3d5ec6a00e1dfbf0fd63329cae094ea6dad750365def228c46345b4f4ed4f590a4d93ae2d83df9568f2e93f74f9f618a18b12e9c27ed93e86b421958a593426da5fd541dd188d914123fc6d410ada4573ac749af381ee902dea5bfd23b32ed7e08677bb90affe22a79fc043368eb1af6b96099f4528245395885dd0eade9bf439c93255b6ceee329717f61c2c440c97a0fb7b57bc2a17dc3a204543997056607a5d78d2c6fda2d3d13925a181e9c7ff86fd3db5b3656a0b34de03b16842fdd6fa7d56ea909364245ccd885bd9ce2b58fe52513f4215f85944555f4e3d787f03c5478e9e597e167fd75a082201202beaa6e87440231212eadb807c9be5c7c2e77ccb49254213cc5d2cc21949b3da10534a3e1e619fa6ac76317b6662dad3fc309c90d69f648c151736b16869f0a1266c4510bb7422bd90a59a9f1d1160b8e9aed9d8c8da4fc9dcc94f259254e5c429c692e3f772ba3c9992732949a6843c5fb500faea99e6e52e33114cb4a50a3694294c984b91fc1a216640a92cff2d09cb5ae4324bb65dc07ee3833ead51fba2e41783bd421413637222ae1aff0387ee97fa60d5c28c7025d7a987a98be4e73e9e41ab7f0e74f884c649951a0eae55bd38ad80ac50ee0bd566c832ae11ac622970da16e350ab7abf926c3c20e0311c49220e8f7a947b53f62a6b491a76e505edaaca63edf4de0214378cc78beb7bc98d70fd3707a2044f80e047c19147910f2ff485b088eacf88db6000359a63b84f97ac6fb793ba2da67c69124f96d2e82c8d18374f828e4fe2e78da4645dc43286d384542ea49e9c59fa69b2df85e5b0c9496414db5c2f0d7ec2b11fe0c85e7aa9e0642fb44228a2f4b50225fd6e77d4af133ab781967e6b2a643d1826499e63181a152c391b96ac7048f70d57b02f07269c9ddcf3b52cf9bb37def9ebd8057d01c1812902b81a857c93040db0a29b2781a7722d0b04d53f03e89181f00f8fced41906a751fd78719eced422f1cc764c0de3c0cd47e77296a35295963ca374d3fe822f7261ccb016418b0501b1a2c7a90c89ed66e975abd6f76cb28e65edd2626c46b9a19aa230414cf2b55b2293752574fb937d4c0ef3835c2cad8b7931484a443e669d87fe92e9c50b0eeb19e1d90b9fe4b3bd753f07ac04ba0efb14fdc350bfd242efcd5e36ab00dcc50cbdb09381cbb7c24d1e3026ceefe313bac3effdc4ee3ba6eeecec8c157062f74f17a907c1a3fbb5f142b24f6e5f7538cb5cd50e26f2fd6717b9b32d2c3936621149e0aabaf669e5a86c56fa31a7174ebcb0f484fb9d6d86575b334f3e6cf39dc1d12ca047ed9200a845983d05db790c68a27534ba436ea8e529aa88fc425bd1036137c414df40488865d2d544933bff2cf86c568bf85b8ec2affad94660190295b8418438fb6ad5a3bfddabc23d2cc7958e4cd074c11a768b66859b661ca63ae6934da7c5a49d507935059048219184fb68b4205887d897796fe6011032f8534a38e51bf3e2e6ade34c134b246fa502a526382a1ac0174e92d2dc8ad2dee08c8a3925355d3393a65d9e1718d8d7cccac05987b322321d6c2bb4160d4dd846e08de1712931986c43bebace86a78220e5305c3262226e6db24c74c08e5943a58fce0c16d4a9e88381245ce8adba54fa694d2577c38c833db17188ec16226106d2173b931220cb5e305d20d3c1415538c969b91f578de22f3d4b16134afd521d811f653a4d6e05397926d7ad003fd82364f8ae644cb8234e7369e5f4dd8352d70ff72632dfc10f6ca4f3c715c21fb2e62e015e9d456800ea996a3e6af43a36b1bcb19026509cbc5b58f41e1319527a5d82df9c4564cde6ea22c403d76f65a930bf8a4c527d63692e7e045ecbaadc9702bb6a1a7d8879e468658d47206f723227619605cc782a9aaff09040aeea52704b9a21450630f857b43df6f433e539c1b0bce19aa05e26aace0489a57c7f3ad9e7bcddbb09a9a67ba133a810c27db73cb0c3807f74379abca7d8a1eb4906f46228b0fd15b351851fe565987e4766b855d5676a2ee9db510a2e58bf445a350aea1941d7021c561afa2f3a4ac71bf134cffb526bcaa188377aab8732f766f40d0bb5b318ecdce7b5c4165a4f76ef92aaa72a26c356350c1a24e6c4a7e64cc0cbec2db35987a643ace8eca30c2dcd11f163e35f03a009946eddb4e80527432386fd8014ef654df8ac62de38dbf8393057db05a7fe94c5921b44f5295217dd957bdf5a1c543c7e8cb3962d177daf2785e308ed5d5070739d468663d6b25a6a374694f66fe6a0e68f39fc313e1dfc9af6e081a89f06fc67c61b0561a6e598cc83fc4b71259dd2e46ea5724c1f4fc86345553539ec1d369cde5e003b9784c1e0b8a9acde52deb5bc8b9ea67ccf3ea661c942cda1f5bf89d5bfabd7898066eb0a6978205bd58a80185d97c96826e20ce1037338cceea04a6f419828125b3702792520d7d937be33d1ec7de7647f70ea3a0277a91738fabaa557d918110542e1c2b0bef668b832dce3ff6f80e32b462a3ca1adafb7534cc13c0d459e50a2d8f74e21015c71477213b06bdb96a2c1d88dfb2c2c8cd201b90d1c7a19fdb4ffc8364982065f5bfdc7b456b4f3379ec475bb1103dcc0c25acde4955b330f5673966b742040bbb6e263a89ae2bd21fd7b42cc2e4746135d1fb98d8eea162ffabb64ad33ab84fd306903413890f3e42594b0c50558f4feec31da2a7a1e0afd8e78e26f69909913d31572f4c34f81b9251e06f059db172888124c95f4a8ba5a36d204a391da344422300055088028cb443196398c52544db319d2da26e6520412a1f050eaf9b9f5128700298666e14b3b8810dd5d44bfcde3a494ab70371b82f7638107128ad8207d8c51ca8108717d8700a1d16231983e3b62ea5f5d030fe1e98faec1ff0cca2d43ad85b9d7c15ef0b9bb7c2e5e78cae413769015ff4ffdbf876721df7425fcb7bdf56ccf6fa62a25e5c674ff8ea43f7514a0c54bc800bcf17bd1948735d9601a99590506d776d7b09b20e41f0d7de6ab2e4a0471a8439bd94a7c1832ed97af7aa6338fc59fcb769f27deb02a3b01bc7648807d4082ac46f03636b25e0cea1f78449b960584f6c2a789588da96330be1a3df6664fbff58b6698801cf72949f5581663872da7ff9e134cd5d340f11fd9ef624ac8ce12a24d523f48dd045483b6b36dda82d8e42ca2b705ba5c3ae1ee02dbfca2e17059681e543b30552600abedf247ee474157e7f2372bdaf711cd8f121fd782002683786b545f860a71e640d01760a3bfcda64ba6a2314ef656b0841c106bb08abfe146232c434703fff3f85bc48a28268bae21b408919aaa9ab5369dbf2c6a515e9dda788a5d2d7540d2b235f0e086cef863c9b1d0fed4f21d625a059459256c15541ae20316ae1929c2f3daf6bc46399d57e99c29ac44639e4519cba545c1e4d8b49fe347bf8210ff416b0e5868b7725bd8022617ebd1b74c6ff02eaedfc3928be9df1cef7b6482c00181e8a67a7097067febf0ff05d76a643c45b5ce58b80d742a8ef43abe3bcf07cc80fea98b81e99d9fd8bf685a285d1dc74bb542f94613e17b9e72d1b3d09e1699ce8eb0a0af74792e5043a098bc6c230c880a590fcfdc13031cc7ac467b60e84c2b62c1a9a423456ef3350dbeb03872685c6986c3e7388a4eac277f4f61f2f29d59cb713108cd172e3d46992a172f7c0c8ed68fe547aeb962ad63f1912941cd6f5af087e2f34e8a39f096fbf850a373f06db59a908ef3e636fc4b26edae7084cf57b17cb737a0ade5baa4033e746cdff1844ea056f34b6dd864fcb272cffa64ae87f11d0f2161b4702a202c237a2b3a1c68cd07a1127dee360b0813840b943171eea28e2782da28f87d32723daf8a99961d9a68eff8554f431522007a00117f3589523e9f7678a6f8db103f6f1fe0c000733ab1dff6a000a2aeeaf70476038bd0bcd7de4b6c67359ead5bcb8d7e9bb44ddb4625582ad51d7a54105df6dce55cf030adf0a5f55ac694d79713e27cc40bb442d10f865058a61b30de1a91964c594ad4640c3a4d25c3245d0a0e794646bf56993877510a047b68ad8650126404d588a248ba54242fb6df9dc769e7cf1ced502cd115a33d486db5ce8067a5c69627dea8b60bba69ba0f7d6d8bc92f4f81adb430b044ce1e1ef3299e4524eb448a70a669d3cef1ecc120e7de403e1d354826ad4fbdedb769e7d4190f33415e46c3c81594480df2cdcadd121bd516a0a5b87ace2f5262dcde4abc20411568a077d88f791e6bce85b481893cf6dc8806d66bf25909b7fd2a3a01027ce76ba0f89db036ff54ef17f088c6a4d99aedcd45d1ea672d6be2e4177dffca0c78b3f700f959f8b0af61dbc5dfd7e48617a14729f1d2471c3256e2e4d701d5b41bb172def998d9aaff217ae3ea48794f517dd8f649eda3d49850faa3067ecdfc959d5cb1fd12ebc26b485b409b35c0534f1ec1d843f11c66732f510d3e375892f3482fa1e4bf4a6301202c0a95f1dbdb069150b48274ad1e0c74196c380ab60a64770fb5145959c86f3dd2716cb7a342d377ef731f71154b70293b10553b7162b73e3e5c749746e14d65af8064e1e4ea1bb0254e6c7f20b9617b96390c3e560def3a1b3e62af6b94bb39533224954702a5d187284c4a2604dc47f3adf74944427dbeeb728e2bf21637150316cf0075ba3b6f30d63561c8a03bc5ec7a9a2505d59eb1e42edb90e42c6a8534a77654a12969daa3b7a429d795318b9d5867d9ce81405fdee65af61cd5d2b7fa612957cec4c0fc6e00b596d6b70ed25a4463d6befb64f70af2ebe42e2d6a0ad3c261dc160b954d2fffd0ca8b895bed08eb1755c4ce635af88354c296b1cd8e03e9a486cd125c69cbe6e18ee075664d0134f8d72adab16a2cd33820c09c5b4088a362aeaa1c0ede3231402e60fee62bace37f339730ecf4a1f609853bbd142babae7295ab8ce2233d3f71866b48c5dfdd335268209ce70b5ac914b70c11fbfea39c59b30677ac3af24dba552ac0047ba574cb162fa24c774b6255ca2d1feeea462b367834297579aa032738b6a66c2bed44f0dcfaf109d075d3b3fb0a6854ad0786072a4ec706c5d4e77cff9fe6cb3dc8be9e9e0e77df33ddeb9b07b2789c2c927468062022fb74a968274eb104efad648d2ba3e6da2d41b690e1ef3d38dca40f8bbf9d7f38d7083bf0293dfa7624220908028747a674e5af0176a187dd43f030d20d72694f1e933b52f489be61b9e7f4308d7519f92b4c506df41ea340bc260c14b88ffd0774bc45d8dca7b00ec7b38299a69cb2b6c5a40e31cd19fd619de70342b7be603bec85d002d189837d4ce736127c9bcf6e6dd6feac2538becf8a3b122e8109ce6003cdffc4724bf41e618bc928736d3ab77b71ffc43234dd0bcf6426d36f0458efa579b6cbc48aaece7de8459e8a5de3da3af3782cd6993e52299e6759860cbede38feed1b8fc853cb5b3ff3a06a0f7387079c91270e6a02c8e554fb2668c604825587c310e14091eba4afb67c8e6f4cac4ce9d99e48e324c0dd79ac53157aa382b791647a2e524aeeebbb4542a21e0e2e013671810aaa8a4ecdeb2888668da2c0f101f155d1dae9418b819f81cddce2b0be6d9c163f0c65f7be8f2932bf0277a6ed21208b9431fbe3af348e82fc73e8bbcb6c554e6ce2abf6944ac53792e884486518086de2223175470ac45cf14789e5752c970482ecac8028051ed22fa5465b8c1b3f6d570d45ee35b7baef6b6c14182989505619a5109c832ea7ab20dcb35c19fa93dfaa0882a99c333f256071768df62ee93290647d84dddc9d2ce9cc46e9f60b52a82f6210e980c4e28df84dba3e8692a2259020857b03ca6e98e6f15bd5e8a6b194cd624b6c1fa508e578eded037055e16546245d612958962a087878c7bf3b1a9a1881cba21fa13ef9611b918c4597a017f155ed9895ca1267b29fe27d1c110a60aad2e002874fc0fd9c924933a1b22ab0f9d27d120c71861dd7eb9da07d669083daecbf289412478676048fbcfa82b70e604e5c5999e11cd7bddcefacf8ff7b1ce6565b3716736e9cc66dc9153027faff8c5f05c290d66e04e659169ecfbfc82a28b145f763101b03ef833421361e611214d391274a5d0c16964250d1e5f195649bbeed021d16816642236e9f6586495e7c383afb7b584e6f51de2409b35fe102f05e7fce16c8e030a9e5420955d9eb4086a13fee958ec0e88a1efb7f66ea777ff0cba43aaca5993e7927d01e1e5e94c4eba8e012774b337c61097306dca7266e2acbfe52dbffc352dec97c1ee42d9b5f714b0b972a9579c09000f690470813740a20b03e9c71b9822aa6f9c987a46b2e049ae4a04ef1bf8882a1b5760f3aa60794582ef40be528b865bf4348bd08e755e646233a96010cb9fa4babd7052e31667e437bdd1298d6146d434fb02f5f2bf1da151c15d9cac96dcdb7d2ee6c1e42fa9171c7d12832f8f91822c840a1d6609970c202dc29a26ba723d1bab28b5a805baf9108829230cc7c27e0cd9ad4d5f89325f376cf5652faf9bbe0d9a6b7f3277a1d21d895e896de0b0e828d09f9f2dad41a8250e3b8cc67cf9ced72b08cbd06ffc694ae2597ba5d71d095dcd1a44126612d54c88a82c74dcb0fc77514ffeb827f74395d3463f7a855d0f525cc47cff62463056c892fcdf21e277f783873d17dfdd16303b6b63bb3c23640970c8fe3b0fd5ed5027a0ea741cf7fdfac51eb761a45826ea1b8d6710c4c352b0e749e5c120361a446650d798abb2e4e553626fdfe5f757f909f1991650d4fb88dc92823ce0f65728bf4f376926069803d7d8a51b408757de6fbd388c00168230d5d69a46681d2ee433ab876b8ee3205d84c552c0b6e0bf3ba61ff9908991a48807776e33c7745d279e34e65513a556af80ceab9a9fd78649a47cb04c1c4fb9d96857a422242acf918642ecc14227780b3007714bf9281d3be460f86bf5eb9295cb6c45a1ae2381011b016edb5178d4b180fdccbfb2980f4f6427bdabcaa43f41b83902ea071ffd72f83bc2e9cd4c4c0df2e47a56ea3837bee0bd72dfd87d795597b882b063876ea73f1f65e03fdf65b70b65daa89b4da0c81ebb9c206003657e094faac0ef074d731a90644ead30719ce676d8e34774896599918f13bc5e8b2e167a3a2698bdf6e97d36e52363ec98b1b53a7c11b625017d7c3a45546b421b67658fd901b5a1d6cb14ea279eca4a80686c88113dd6c3292871dc54c060e4d54122e29f749f4100ce2dff6efa615fcba00d888aab12d8b5277a3e01ef4c081faa49f126e7277de47f5229d7ce50eca35f41e1d0d48b18de369c07c798f26ef2491335aeaa02ba88d24c56070e088c3ec7865afcd204a7d6b3c968904ea19cf8ef03be62c0d8c2330f21cb33c98b892c5b7401ff16b0671054986f27740c87f71156521419df1bca59e5180679b4d4ddedead59aa153da12c1de8ccf4d854b00ed001928863db5fec9d3c98849d0c14aab4c8b5007fefad550aa04808faefdac567c5a04bdd07fe3f9672234a36e170fe92224a457ba9a2e2da57f7894f8efc50aa259102a835b6bce5cd1d83105755c7bbb8849a5a7d2cc54af8e76b83efbae5400b399f5b4edf6cdee01421eec5873dfea25e23c07fa39a707309fa0507da056b1f6cc6ddde0b92e30891c406820e8ed9189fb193f5036aaf3fb4949c3a8d5ea176f5e706c99d8ceb680efd10c4533f2f188d70411f7dccfdb0713ea6ecb66ca0a4a00312cdf8443f6f285d4f589e347cdff51bc768984d08d44d574c49769b3d40fa3098edc9708accf1dcfedece593c091927aec2d4cb59b32680b41378cee278ac3c34dbac6981cb2af36125d234c67fe7f2011d55360f4c72e1e47579249d7293b70299e2a9e880d084f8ad5001fee730574923a488a952eea14a9236d1b520eb0d5069bc7ab29843ff7243635d49165cdc02126c637784c107f075d54969ac1ffe852fbe45cf56d0b1c44abb764290086d2de90d448b8c740a26c7dcde57395758c85153f91b4931fc6c19e31eba2d27d6d49c2b73e9adbac0da2cdf16d2de248a31032d5993d039c6154e63dc758ccb5190c324b21916872ee73715f76fef614d6ad4fb790e667cb8645719e462ded0b00b07ba538bd07e3334ee48a8072f607857610b7e46f324351006c125776f1edd3bc654cd1949da0eea5e8e3b328dc41a907383e534ce56abab9149d1f5b2ce77dfc992601dd8c35ddd539ee0ec0d16f901d1b8d6dc4e2f957db3c4e9cb198575e9095ab1b5b2c857ab846e51cf74ebd19f7d5ec70aaef92982361a552ff15e3e7a1189984b879c22a319dcb6a2ee01ae845f55946e326497d2393188d35f3703cbb0ca7511ed7c45180c93b7d9898705de8891525a3faf35d129f96663dca17262eb2b711a8bbbb79096d5acbc2c7eaf0a255ab42faf5fdecff2483b7f2e7cd8715672c218234f15141f32505f7e080b833d6624edeb9bfba08e0aae34b6c1b3ee719091556ea6e89c2051aad3f123d1d84fef23975abe4a8a172b2745bfa46f451582c23261acc0d4358906c47bcbf0290819ab7f9d55154be21678b55cc70aa7fdd18f94dc23f0b6c7de7133d8645256dcac27edb6a7b82e4a03d999d43aa62e9c872af0ad12cab89fb01e4909a6d0912c12bd7a5334470d78db52629125f23567276f312292406c30c578fefc605f91b578ea11a2a0a62ba72ada935122183a89da18c36a5d202340e2e11dc3d55b0cd298096f27714b0eadeda0626539454d1f1719dcc73fb51bf518d99e785c30ef1430b94f87e5ce86ca42cc8a725d35161a8e4574766fc2494e5eeac9e5847cb49ea28b0a75c288aa92b5c33ad3333611aab64924bd01a8686cbbd7e6dbcd4d39b2848b2192183551bbe1a89a807fe5d2ac56f06b39d6e5f74d2c196f227e6729a1b329a8629f83da9f622c65f11dcd9531d3645b914b9f9d7c04354dbee338c0daa0a251bd05f20fab71dce3da22441f432cc512050fb4527714f0ce77c1a38ce7da2eaaf65640ae11045798e29d69fb919bb570928eb8be70ce03fc5a9397e01ea7e2b8357e2a8c3977d1b436bbb5cedaace09d904775485101ea6acff28ba9e21ad40fc00d27b74c89999dc23c2eab28166da6f0a6817252385ca079db3513c21a6a6d0c9a71ec4f62914a1e105d89806c0b387e2868395e31389d59534bc92fbb6c4212332c88b1213c2cb11e459e5f2977898cd5c709e920fb7b741e860f3dd7ad88e6e0b836b3387330c94b9a4d1d08d5b36455bd364a4cfc7dd3a12fce7d8b655d0cf457c8821fb3ceb3da450472f2d1733c633d9a40bc22f18621b218b11f3f6d43ec4cd3c542d63449a8b39c5cd5b4a86131d0b7581e06a59dbac1c13a197be315966ec66820b568c385111fdff762c7489feeb2d4e9351b8c8dc5aad6080aa4f5d878c8c19a9069371b0b93ef28b7ed9dcfc4a46e63f7c102e4ff6a522871e9cd25d0a3f18722ab44ea0b366e4dd73b7dac656dda4edf9da852cf3391fdd036b3b0a4554c5862ab2db760ca55fa53bd2afaf30891a831777761d80c2b7d2424cab1f19a7b16112fbd723eb84f35bfb566f9e618ca9d870bddb82b626ea3a5181a59ebbbcb43f9c8a9e1a60eaebd55e35d16e6d573eedee31507c9297e84d57ecc16ab41fa5b33a62cc60b31c124ba03797d047a7c8fe55fd9e8875c7cdabf524b5c890bc3b2774b6f1916d47b30af16e1393108143976d529f2b8a5d5d6303a6a752fd9207ce0a7dfa0ec9ac154652bc538300572be2386d12aef2f57472c7642e9fa618f4de9d03b431b3abc07464ab49d767424ea80374cf0d09b309a6616c47030933488d186b124d750d29c947d7644fdbf0e28d545b9a85d6f87cc08f454cc8aa749e056ecd163ac34d19e15a10141623e065719648ed2a5d52d3f6ed4c4d955abc7685b588c0fa020a09850dc218917f151807999b941040a6987b08ce94d7eb2ffa87f343ef9c1adf0b4c07b42e133d4187481ba151d6fdd2bc2c69b3c98d654e8a8ad87a77e988786aafde38f23725b1a5a37fe12b9c29f866a9cbb14423c14fde6de0d7e9b9def7856f2f4503beb25c08e0b69faeb8b781b2553ea896cb534abeb495082dcf5eff6f5880e62692fdfb2d7d0eb4067115aaf99e8680a1a8018447ae89d7f1b8f77d69a89422a0d0c2bb9f5cf2fd1943ccb8179674a1e8fa73be0f9906eefdbb271677e3647103dd9b3e3891c28b35a23da5ef5053d15d70031a85fa9fefc49acb7c3ea047d7aaa634cf52c0607e66dda14a0e05b29cdb64c679d98d4304a5f2e1979ad2be6facfa68182c35b40c415e8c52fe7daa55510e83462515ddb16d2e83f9c5d1eb35cd05481b1b5326593092ec1c4fcced3eaac368218cc8b88e5cddbe50f31bcbd0b74b71975ba2dfe753f67ed7cf4d38316f6bf418c87f84812b6232ad996e6fc76b0acbaeba80429fab56d6396ed390638e12259bfff42a6e0f6f2b00e054b72107a9f97c4d96078a47d033bfa66b7e34c5e86dc317d75e271e19fd1de9af9188b0bf94300b68d6b8312dc81451270246664d54e2d9eaac35567402b08e41afe5e281d7eeffb6c0912e6bb5029ef84e09130b224b04ac3971bb979260fdd0cd9e6b49582e57b954cda832d4ad6308e633e2fba56aa815ea358b08f45be342a929fe49fdb8e171664d67eb24b1e8e8a47063619cac4f4dda20fd9458963d7ac873f91d80087c366bf0d4339120cb80fb79791bd866db22e301fc62935a3a7117e9d0205f1d7d1ef6848c40f669f182fab584ba314c41b2130a39673a18727edf46a6ca7145d1c919f30f0b3f82796209386a4d3751b4fb3e0014cab04c4383c7d1077b5b92e1b8ffb6520f48fe7ed7310f2eb206e48345e0e9cc2a599427b4cfa56ea8d1a2d0b2d6b4de2885b3054e376e136ad4fb0a371f4ceca07b7697dfaa1feb684379c7f601445667a7ab985ec3444e55862c4964848fadf2ed8f01221319f15ef014ec045ade23a6baa2547de5cdf8c9f422bc9d417f41221f7681063f23da1885f1dc0e34a21a2c93b97d84a5df16f6be74f4808f0c17bccabf7c01d4e5798cc36d736b6476645005f3b5ed0ba3add5ae06738ec2f50b50013a019fab389bb8bf6e960dbcba7f751ed5b015cd27585c87398d8f386d6ed6d379f90dbd148acfe04f9068a61d4ff89d50ff565887a94004c5b6989ba21fbd1a7f7d8e2496648affab2e31954cc4a6c078894550341678b0ddbd61683876f4adc893d19250e2daf01b503051202d55713d37e12f671bafa00f565350a002d0985fad527c6328cd74c770afde0a27673a71a0aa60ba4d6960590f92bc05d7aa828dbd6473a677b877154aafc804285a85d28de96ee4aa40817db96e0151754672e10d71850103bb5eb539735190cb3449431158b1dd2df8a8aa92127c0c408370f277f0e47f7408ac10500caf85623ebe7d14d6d305f5b0f2ee76d40d567a9584ac2efe32fad48d9abe1cd08230ab0f314368e87839690e90943b953a33198d39c6f96b0b5d92fed35252be1dfdcf8573dd5c653b9297ad7750f27bcbcf5afc83e7477216263a1572c72666c501c4e285d6b62d0eaa2ff9375b1fba3400dc9116d9ec084603cfdd14ad40cc9277695b89a04dbef428adfed36aa8e22b4ad11aceaf0d39278c4bbca8cefb6f972522db1fc5736e9e714e32ceecac44b58a6b996dacfd968b9f42ab925e973e637251704ee0bc106cda7765a540836de35778e813efb30936c7ac031a7478495dd9a7b5d5c857cff6c618d323ea82b6e21e194cc09f825be073a81ed0e36efe96af5e3b6f29f8412ee3aa85da9789043e7ac16b134a3f07716396025c301ff39ecfe761618c8a3f87413c62fd28bcbc0834380288aef4a0ce5e845c9a55c058dd210889daef5092d2d54522a13eeef72ca9c3d4d29fd7fc81560375ea58b723ad310c1cb85b707b2248a2f08583c3e7dfea9d7f8746031cba8374fde86dcfce33e2aa68424afa11765227c792a28df13ef30ee7208beb88e91fd682d0f8de32711f622cd60d03aeb447047ea88529c5990f47042a0d56f4b74b83cf567bc60159411e9c8ac5126f7f8db9728114bdd6f8d419a75bc0f77d53ccc09b8435b289db729b662849d7c96ecb2f6da486f69cd9753cdc9657e8 Hey, password is required here. "},{"title":"模拟退火","date":"2021-02-10T13:59:27.000Z","url":"/2021/02/10/algorithm_contest/monituihuo/","tags":[["模拟退火","/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"]],"categories":[["OI","/categories/OI/"],["乱搞","/categories/OI/%E4%B9%B1%E6%90%9E/"]],"content":"其实这玩意很好理解，首先看：讲解 做题，luogu 1337，讲解 LOJ [BalticOI 2012 Day2]俄罗斯方块 （luogu 的不好使） 模拟退火能调出来五十分的 solver: mnth "},{"title":"《编译原理》第二版（龙书）学习笔记","date":"2021-01-27T15:53:36.000Z","url":"/2021/01/27/old_study_notes/compileprinciple1/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["编译原理","/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"因为做课设要用，先随便学一学 引论语言处理系统：预处理器，编译器，汇编器，链接器。 编译期把源程序映射为在语义上等价的目标程序，由分析部分和综合部分组成，也就是前端和后端。 词法分析编译器的第一个步骤是词法分析。每个词素产生词法单元（token），形如&lt;token-name, attribute-value&gt;。 position 映射成 &lt;**id**, 1&gt;，id 为标识符，1 指向符号表中 position 对应的条目。 后面是语法分析，语义分析……先不看了（） 一个简单的语法制导翻译器语法定义上下文无关文法。 用 expr 表示表达式，stmt 表示语句，则可以表示为 -&gt; 为具有以下形式，这样的规则是产生式。if、括号这样的词法元素为终结符号，expr、stmt 这样的变量表示终结符号的序列，为非终结符号。 最终要都是终结符号。"},{"title":"败亦可喜","date":"2020-12-20T22:57:14.000Z","url":"/2020/12/20/algorithm_contest/icpcnanjing2020/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["游记","/categories/%E6%B8%B8%E8%AE%B0/"]],"content":"如你所见在 icpc 2020 南京站（线上赛）我们队打铁了，但是我反而感觉不错，，？ 说感觉不错应该不是阿 Q，主要是因为我们队似乎已经做得还好了：我想起了相邻的数互素的结论，和 ljm 构造出了 K 的解，他一发过了。wsy 想出了 L 的解，也一发过了。我推出了 F 题的正解公式，因为不会三分用牛顿迭代法倒了倒，中间还绕了些弯路，WA 了几发过了。这期间 ljm 干 E，干了两百来行和无数个 WA。我也在最开始的时候贡献了两三个 WA。最后时间吃紧，三人一块讨论 E。我在纸上写了所有的情况并列了出来，在 ljm 和 wsy 的注视下写了程序，并被 ljm 找到的样例给干翻了。然后加了点魔法特判过了。此时离结束七分钟，罚时十四个小时直接爆炸，打铁跑路。后来看了看题解，别的题比较费劲，这四个题流畅地做出来就有银牌，但是我们显然没有这个水平。 说可喜，更主要是暴露出俺打 ACM 许多问题： 尤其是思维题做得不好，容易跑偏。像 F 一看到期望就要想到递推或者是移项求表达式，非常非常基础的套路。虽然在吃 bk 的时候想了出来，但是当时不知道怎么想的居然整了个求和，所幸发现应该是 min。 实现也不行。我第一个写的 E 是正解思路，但是挂了。写的 F 因为板子没三分居然用了枚举，后来换了牛顿迭代也没测试边界情况，白白 WA 几下。 团队配合有待加强，ACM 赛制不熟练。看到 E 过了那么多队伍，写出来的程序那么长那么复杂那么多 WA，应该赶快删号重来，至少也应该三个人或者两个人联合调试。没有牢牢把握通过少的题不一定难，通过多的题一定简单的原则。 不跟榜，妄图多线并行干出难题。 ACM 和 IOI 赛制的最大区别就是它没有部分分，可能这也是导致它思维题数量多，且思维题流畅做出来差不多能打银的样子吧。所以以后还是要多打 CF。虽然不一定参加算法竞赛——感觉好耗时间——但是也要偶尔刷刷题吧。最后感谢校 ACM 队给了我们这次宝贵的机会。"},{"title":"HUST ACM 2020 新生赛补题","date":"2020-12-06T19:32:01.000Z","url":"/2020/12/06/algorithm_contest/hustacm2020/","tags":[["算法竞赛","/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"categories":[["算法竞赛","/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"content":"虽然是老油条，但还是来玩了玩。题目在 hls 的 OJ。做出来了 A、B、C、E 四个题。补的题都有题意。 A. Chipmunk and Cakes二分跳石头，NOIP 题。注意最后一个不能删，要特判。 B. Chipmunk and Brackets暴力括号匹配。注意可以在栈里保存每一个左括号位置，这样就可以直接 $i-stack.top+1$。 C. Chipmunk and Ele.me感觉是个混合背包。用 0/1 背包解决用 $i$ 魔法值能得到多少能量，用完全背包解决用 $i$ 魔法值经恢复能到达多少魔法值。max 比值就是答案。 D. Chipmunk and Array题意：$[1,2n]$ 这些数划分成 B 和 C 两个等长单增序列，且要求 $B_i &lt; C_i$，问方案数（取模）。 看到取模数，应该想一想递推什么的。推不出来，就应当换一种思路（））发现条件就等价于依次填数，填完 $|B|\\geq |C|$。这不就是 Catalan 数吗！ $C_n=\\binom{2n}{n}-\\binom{2n}{n-1}=\\frac{1}{n+1}\\binom{2n}{n}$。这和出栈序列个数、合法括号匹配数是一种题。 E. Chipmunk and Wormholes可以按二进制位来构造。第 $i$ 次依据每个元素二进制表示 $i$ 位置上为 0/1 来划分，可以保证每两个不同的元素都会被分到两个集合一次。我是递归地划分集合，每次划分所给集合为两半，把这两半放到两个集合。总的来说就是划分第 $i$ 层有 $2^i$ 个小集合，把这些小集合轮流放到要产生边的两个大集合里。 J. Chipmunk and Hunters题意： 有 $n$ 个猎人和价值 $V$ 的钱币，每个猎人有权值 $a_i$ 和期望 $b_i$。可以选一些猎人去取钱币，每个猎人的钱币加权均分，也即 $a_iV/\\sum_{\\mathrm{selected}\\ j}a_j$。如果超过 $b_i$ 这个猎人就是满意的。最大化满意猎人的数量。 首先最优方案显然是选择的每一个猎人都是满意的。$a_iV/\\sum a_j\\geq b_i$ 即 $\\sum a_j \\leq a_iV/b_i=s_i$。选择的所有猎人，权加起来应该小于最小的 $s_i$，因此将猎人按 $s_i$ 降序排序并枚举 $i$，大于等于 $s_i$ 的都可以选，可以选择的猎人是连续的。用堆维护猎人集合，使得权和小于等于 $s_i$，非法时候踢权最大的猎人。维护这个过程中堆最大 size。 "},{"title":"CCPC 2020 长春站补题","date":"2020-12-06T19:15:42.000Z","url":"/2020/12/06/algorithm_contest/ccpc2020changchun/","tags":[["算法竞赛","/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"categories":[["算法竞赛","/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"content":"没去，自己做着玩。2020 China Collegiate Programming Contest Changchun Onsite A. Krypton枚举氪金的顺序，非首充通通充一块的 D. Meaningless Sequence观察到 $a_i=c^{d}$，$d$ 为 $a_i$ 二进制表示中 1 的个数，直接组合数来一套。 "},{"title":"Educational Codeforces Round 99 部分题记录","date":"2020-12-03T23:17:36.000Z","url":"/2020/12/03/algorithm_contest/edu99/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["算法竞赛","/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"content":"老年复健敷衍题解。 Eref "},{"title":"A tour of go 笔记","date":"2020-11-26T10:33:55.000Z","url":"/2020/11/26/old_study_notes/atourofgo/","tags":[["go","/tags/go/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"突击人 基础按照约定，包名与导入路径的最后一个元素一致。例如，”math/rand” 包中的源码均以 package rand 语句开始。 调用就 rand.Xxx 连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。 命名返回值： var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。 var a int 函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。 没有明确初始值的变量声明会被赋予它们的零值。 表达式 T(v) 将值 v 转换为类型 T。要显示类型转换。 常量的声明与变量类似，只不过是使用 const 关键字。不能用 := 可以省略一三个语句（及其分号）变为 while。可以全省略变为 while(true)。 在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。 go switch 默认 break。 defer 推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 类型 *T 是指向 T 类型值的指针。 指针访问成员也用点号。 数组 [10]int。 每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 a[low:high] 左闭右开。切片就像数组的引用。切片用法就像没有长度的数组用法。 切片拥有长度和容量。切片的长度就是它所包含的元素个数。切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 为了判断一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 "},{"title":"捡了一个路由器","date":"2020-11-20T10:39:46.000Z","url":"/2020/11/20/miscellanies/router1/","tags":[["捡垃圾","/tags/%E6%8D%A1%E5%9E%83%E5%9C%BE/"]],"categories":[["捡垃圾","/categories/%E6%8D%A1%E5%9E%83%E5%9C%BE/"]],"content":"最近买了一个路由器放在宿舍，第一次买这种东西，记录一下。 刷固件的主要操作是先接网线刷 breed，再在 breed 里头刷固件。 不要网上下论坛版固件，方便是方便，占用太大了。openwrt 官网自己下。"},{"title":"在线记俄语一到一千的数字","date":"2020-11-16T18:42:29.000Z","url":"/2020/11/16/language_notes/remember-russian/","tags":[["杂记","/tags/%E6%9D%82%E8%AE%B0/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"用 js 写的 var num_ge = new Array(\"\", \"оди́н\", \"два\", \"три\", \"четы́ре\", \"пять\", \"шесть\", \"семь\", \"во́семь\", \"де́вять\", \"де́сять\") var num_shi0 = new Array(\"\", \"оди́ннадцать\", \"двена́дцать\",\"трина́дцать\",\"четы́рнадцать\", \"пятна́дцать\", \"шестна́дцать\", \"семна́дцать\", \"восемна́дцать\", \"девятна́дцать\") var num_shi1 = new Array(\"\", \"\", \"два́дцать\", \"три́дцать\", \"со́рок\", \"пятьдеся́т\", \"шестьдеся́т\", \"се́мьдесят\", \"во́семьдесят\", \"девяно́сто\") var num_bai = new Array(\"\", \"сто\", \"две́сти\", \"три́ста\", \"четы́реста\", \"пятьсо́т\", \"шестьсо́т\", \"семьсо́т\", \"восемьсо́т\", \"девятьсо́т\", \"ты́сяча\") function get_num(x) { if (x < 1 || x > 1000) { return \"Error!\" } var ret = num_bai[Math.floor(x/100)] + \" \" x %= 100 if (x === 0) { } else if (x "},{"title":"《图解TCP/IP》笔记1","date":"2020-11-03T15:47:36.000Z","url":"/2020/11/03/cs_notes/tjtcpip1/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"看一看 网络基础知识OSI 七层模型"},{"title":"CSP2020-09游记","date":"2020-09-13T23:23:17.000Z","url":"/2020/09/13/algorithm_contest/csp202009/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["游记","/categories/%E6%B8%B8%E8%AE%B0/"]],"content":"感谢 wls 和学院让我白嫖一个考试机会（跑 因为封校所以只能在华科考。 到了才发现换了考场。 使用 tuoj 实时评测好评，相应地，大家的分数都高了很多。 第一二题秒了。我们几个搞过算法竞赛的坐在一块，开局暴力敲键盘，前面的人回头了两次（）。 第三题一看就是个大暴力，但是比去年的化学方程式要好做。慢慢做，第一次只有十分。第二次把判环去掉五十分，第三次修改判环八十分，第四次完善判环一百分。如果没有现场评测，这题我就要挂了。 第四题应该算计算几何，写了暴力不会写了。我感觉我的思路连写出来公式都困难，不知道他们怎么 AC 的。 第五题字符串，hls 说是 AC 自动机加 dp。我字符串本来学的也不好，现场想出来 AC 自动机更是不可能。所以就写暴力，最后又写了两个小点的特判，意外地多过了一个点，感动。 这次我做题因为实时评测变得顺利了很多。按部就班地做，普普通通的发挥。好像在华科排第五，挺普通的，在全国不知道排多少名了。但是这个分数已经够高，保研也早够用了。 这就是“历史的进程”啊（），上一次 csp 没有实时评测就个 345，这次 376，这也是挺难搞的一个点。要是哪一次不考 csp，指不定就要被这种情况搞了。但是我算法水平也就这样了，不会有什么提高，所以以后就裸考，也不算很耗时（）。 晚上去吃炸鸡，人太多，就没去。东一菜都冷了。只有一个木耳炒肉有点泡菜味，热热的，好吃。还在超市买了半升奶。昨天太困，一觉睡到十点多，所以早午餐合一了。"},{"title":"初秋杂谈","date":"2020-09-09T15:12:18.000Z","url":"/2020/09/09/miscellanies/zatan1/","tags":[["杂记","/tags/%E6%9D%82%E8%AE%B0/"]],"categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"一篇和技术无关的文章。 八月底终于回到了“英雄的城市”，学习生活步入了正轨。 在家里、宿舍学习不是不好，但是 810 显然是更适合学习的地方。我把显示器等等各种装备都搬到这里来，打造了一个奢华的工位。宿舍比家里更适合学习。在家里很容易就颓了，在宿舍也容易颓一些。在 810 看神仙，就不敢颓了（跑 回了华科，我会主动去操场了。不追求跑得多快跳得多远，享受运动的乐趣。运动的乐趣在学习压力小的时候才能体现。高中天天被神仙爆锤，根本没有心思去锻炼。上了大学也天天被爆锤，但是在家摸了，就会主动去锻炼，然后发现锻炼是有意思的。 还有吃早饭。打死我也不会喝粥的。 要不断认清自己是个普通人的现实，呃，也许是代码写得好一点的普通人（跑。在朴素的生活中寻找简单的乐趣，跟神仙还是跟菜鸡比较都木得意思，好好学习别颓了就完事了。 有一说一我现在就喜欢打打星露谷物语了，但是打两个游戏天就会腻了，所以就不打了（）（）（）（）（）（。 本来想着上学的时候游览武汉，然后“把好校门关”叉，“把校门关好”勾。 吃饭真爽。 但是我中午吃咸了，丢。 当个普通的大学生，将来当个普通的程序员，过着普通的生活。只要我不去超级带城市，这样的生活应该很令我向往吧。"},{"title":"关于 Android 的笔记 1","date":"2020-08-15T16:30:22.000Z","url":"/2020/08/15/old_study_notes/android1/","tags":[["Android","/tags/Android/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"来自《第一行代码》 基础控制语句Kotlin 的 if 可以有返回值，就是花括号里头最后一行代码。 when 比 switch 更高级。也能有返回值。如果不写小括号和里头的东西，就可以在条件的地方写上 someParam == 1 这种东西。不必使用 equals。 for-i 循环没了（震撼我妈，用： 两个点是闭区间。until 是左闭右开区间。在后头加上 step 2 可以设置步长。for (i in 10 downTo 1) 倒序。 对象定义类就： 直接点运算符访问、修改对象和执行函数。注意，类默认不可继承。要继承的话父类 class 前头加 open,子类用 class Student : Person() {... 这种东西。 构造函数分为主构造函数和次构造函数。主构造函数可以写参数 加了 val/var 以后的参数自动成为本类的字段。所以说 Student 可以改造为 class Student(val school: String, name: String, age: Int) : Person(name, age) {... 这种东西，不加 val/var 就能把作用域限定在主构造函数里头。 顺带一提每个类都可以写个 init{ ... } 执行一些代码。所有次构造函数都必须调用主构造函数。例如 Person 写一个 constructor() : this(&quot;&quot;, 0) {}。可以没有主构造函数。 修饰符就是把 java 四种修饰符的 default 变成了 internal。public 变成了什么都不写的默认项目（java 是 default），internal 是同一模块可见。protected 去掉了同一包路径可见。 数据类就像 java bean，前面加个 data 就行了，equals 什么的都不用写了……没有代码的话花括号都不用了（喜 单例类直接把 class 换成 object 完事（tql 接口没有 extends 和 implements 了，直接冒号后头跟上继承的类和实现的接口。逗号隔开。@Override 变成了扎起 fun 前头加 override。接口也可以有默认的实现函数。 LambdalistOf(a, b, c) 创建不可变集合，mutableListOf 创建可变的（当然也可以一个一个 add）。 lambda 表达式：{param1: Type, xxx -&gt; 函数体}。 函数式 api： lambda 表达式是函数最后一个参数可以把 lambda 表达式移到外头，小括号也可以省略，一个参数也可以直接用 it 表示。所以上面的可以写成 list.maxBy {it.length} 和 js 一样，也有 filter 和 map。用 any 和 all 做判断。这东西自行百度吧。来一段省略带师： 对一个对象使用 let 可将调用对象传递到 lambda里头，例子看下头。 空指针kotlin 把空指针异常消灭在编译期。Int 不为空，Int? 表示可以为空。敢写第二种就要判空了。 例如一个 student: Student?，直接 student.study() 是不行的。要么包一个 if 判 null，要么就用 student?.study()，非空才执行。用 a ?: b 表示 a 非空的时候为 a，a 为空则为 b。 字符串可以内嵌表达式，比如 可以用 lateinit 告诉编译器某个变量是延迟初始化的。 一些标准函数with 接收一个对象和一个 lambda 表达式，在表达式中提供那个对象的上下文并以最后一行语句为返回值。 run 差不多，不过是要 obj.run {xxx}，不能直接用。 apply 和 run 差不多，但是没有返回值而是返回对象本身。 静态方法kotlin 弱化了静态方法的概念，要么用单例类，要么套一个 companion object。（其实调用的就是这个伴生类的方法）。真正的静态方法加 @JvmStatic 或者是顶层方法。 高阶函数在参数列表里里头写 func: (String, Int) -&gt; Unit，表示接受一个以 String 和 Int 为参数并什么也不返回（Unit 类比 void）的函数（lambda）。引用一个函数可以使用 ::funcName。 输入输出对一个 writer 使用 use，例如 writer.use { xxx }，会在 lambda 执行完毕以后关闭外面的流。 Activity可以使用 Intent 来调起别的 activity。可以通过指定一个 action 多个 category（不一定都要有）来让系统找出合适的 activity 启动（隐式的），也可以直接钦点 activity（显式的）。自己的 activity 在 AndroidManifest.xml 里头对应的 activity 标签下写 intent-filter，用处看名字就能猜出来。 比如： 可以自己在 intent-filter 标签里头写上 data 标签响应 https 协议，之类的操作。（感觉这就是实现用别的应用打开的方式啊2333 intent 还能携带额外的 data。也可以用 startActivityForResult 来调用一个 activity 让它返回数据。 生命周期使用任务栈来管理 activity。activity 有运行、暂停、停止、销毁状态。 启动模式standard，singleTop（栈顶是当前 activity 就不会再创建一个了），singleTask（返回栈里就一个），singleInstance（存放在单独的返回栈） 类委托使用 by 关键字。 BroadcastReceiver属于四大组件。就像 activity 一样，继承 BroadcastReceiver 并重写 onReceive 方法即可。动态注册也一定要取消注册。 intent setPackage 以后变成显式广播，静态注册的 BroadcastReceiver 可以收到，然后 sendBroadcast。 有序广播可以截断，同步执行，标准广播不行。有序广播用 sendOrderBroadcast，在 AndroidManifest 中设置优先级，在 onReceive 中用 abortBroadcast 截断。 持久化存文件，SharedPreferences 存储键值对，数据库。 "},{"title":"《计算机程序的构造和解释》学习笔记 1","date":"2020-07-28T10:03:11.000Z","url":"/2020/07/28/unique_studio/sicp1/","tags":[["lisp","/tags/lisp/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"课程来源 基本lambda 一样的。 牛顿法平方根： 高阶函数：函数当成变量 牛顿法求解 自己的 cons，car 和 cdr 自己的 map： 符号数据 其实 &#39;(a b c) 就相当于 (quote (a b c))。以后可以用 &#39;() 来代替 nil 了。"},{"title":"vue 学习笔记 2","date":"2020-07-13T20:29:31.000Z","url":"/2020/07/13/old_study_notes/vue2/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["vue","/tags/vue/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"课程来源 基础部分slot这东西好像被废弃了，以后使用 v-slot（（ 比如淘宝手机版顶上，可能是搜索框，可能是没有搜索的导航条。这个地方就写个插槽然后插上对应的组件。 父组件模板的所有东西都会在父级作用域内编译，子组件的在子级作用域里编译。如果子组件有数据，父组件想把数据改一改放到子组件的插槽中去，因为编译作用域的存在，不能直接在父组件里头用 mustache 语法写子组件的数据。新版本作用域插槽要用 v-slot。 模块化 webpack.config.js main.js 顺带一提，箭头函数的 this 是向外层作用域一层一层查找 this，直到查找到。 Vue Clirouter单页面富应用 SPA，就是在前后端分离的基础加上了前端路由。"},{"title":"vue 学习笔记 1","date":"2020-07-08T17:08:41.000Z","url":"/2020/07/08/old_study_notes/vue1/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["vue","/tags/vue/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"课程来源 基础部分声明变量除了 var，还有 let 和 const。推荐使用后两者。let 有块级作用域。 在控制台改变 app.message = &quot;xxx&quot; 页面也会直接变化。加上 v-once 不会，此时元素和组件只会渲染一次。 mvvm：model、view、view model。 v-pre 会跳过自己和子元素的编译过程，直接显示本来的东西，例如直接显示 。 如果渲染时间很长，会让用户看到 这种鬼畜东西，非常不好。拿个 v-cloak（斗篷）覆盖住（好像也没啥用）。vue 解析之前有这个属性，解析之后没有。所以给有这个属性的都不显示： v-bind动态绑定属性。 v-bind 绑定 class 怎么做？显然不能和上面的 imgUrl 一样写个什么东西放在 data 里头或者是 在 computed 里头写一个函数。可以考虑使用一个 string-bool 的类，称为对象语法。true 的话就把类加上，false 就不把类加上。总的来说，就是通过修改 bool 值来修改 class。还有数组语法，用得少。 此时甚至可以在控制台通过控制 app.isActive 直接控制颜色的变化。 v-bind 控制 style 的话也有对象语法和数组语法。 计算属性 计算属性有 getter 和 setter，默认没有 setter 也就是只读属性。计算属性只有当开始或值变化的时候才会计算一次，是有缓存的。 杂项v-on:click=&quot;funcName&quot; 看起来像不传参数，其实会传一个 event 当参数。但是如果传参，就不会传这个事件。又有自己的参数又有时间，就 funcName(123, $event) 就行了。 .stop 可以阻止事件冒泡，.prevent 可以阻止默认事件，.once 确保执行一次…… 关于 input 复用问题，可以加属性 key（过 于 抽 象）。 v-if 和 v-show 当条件都为 false 的时候都不会显示，但是 v-if 压根不会渲染，v-show 只是将 display 设为 none。隐藏显示切换频繁用 v-show，否则使用 v-if。 v-for 遍历数组可以同时加上 index，例如 v-for=&quot;(item, index) in movies&quot; 之类的。也可以遍历一个对象，输出 key value等等。 过滤器在 filters 中写上，然后在 mustache 语法里头写一个 | 传给它就行了，就像是 pipe。 js 函数式编程filter、map、reduce： 也可以连起来写。 v-model实现表单和数据的双向绑定。 修改数据和表单的任意一个，另一个也会变化。 v-model 有一些修饰符，比如加上 .lazy 不会立刻变化，.number（类型是数字）。 组件 关于语法糖，Vue.component 可以注册全局组件，局部组件可以直接在上头的 cpn1 冒号后头放 cpn2 那个 extend 的参数。template 可以抽离。 子组件取得父组件的数据，使用 props： 子组件向父组件传递事件： props 得到的数据最好不要用于 v-model 双向绑定。在 data 里头再写一个。父组件方法里头可以用 this.$children 得到子组件的数组。使用 this.$refs 获得设置了 ref 属性的组件们，以 json 对象的形式。子组件用 this.$parent 获得父组件，但要避免访问父组件数据。"},{"title":"《深入理解计算机系统》重修记 1","date":"2020-07-06T13:06:55.000Z","url":"/2020/07/06/cs_notes/csapp1/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["底层","/tags/%E5%BA%95%E5%B1%82/"]],"categories":[["底层","/categories/%E5%BA%95%E5%B1%82/"]],"content":"课程来源 Machine Level Programmingrisc 精简指令集，cisc 复杂指令集。以 arm 和 x86 为代表。 编译过程：预处理——编译——汇编——连接。 分别对应： 使用 objdump -d qwq &gt; qwq.d 来反汇编。也可以 gdb 打开可执行文件以后 disassemble functionName 查看一个函数的反汇编。x/14xb main 检视从 main 开始的 14 个字节，十六进制形式。%rsp 是栈指针。%rip 指向当前在执行的指令。 8(%rbp) 就是 Mem[Reg(%rbp)+8]。D(Rb, Ri, S) 就是 Mem[Reg[Rb]+S*Ri+D]。有各种各样的精简版，套这个就行了。 如果用 movq (%rdi, %rsi, 4) %rax 取得的就是内存中这个地址的值。用 leaq 取得的是地址本身的值。 关于 swtich：值比较集中的时候会生成一个 jump table，直接根据被检查的值跳到响应的位置就可以了。但是如果是 0 和 1000000 这种数据就会变成 if-else。不过使用二分的思想，复杂度是 log。 %rsp 是从很高的值开始减。栈是倒过来的，高地址画在上头。 call 的时候会把栈指针减 8 然后写进去下一条指令的地址。ret 的时候 pop 出该地址然后返回。 存储器层次结构sram，静态 ram，稳定的，复杂的，昂贵的，快速的，应用于高速缓存存储器。 dram，动态 ram，便宜，慢，用于主存和帧缓冲区。 他们掉电就会白给。 闪存是一种 rom。 顺带提一下南北桥。（干 南 桥！不过这一套好像过时了。 计算机械硬盘容量的公式： （我怎么贴图这么多（（ 对扇区的访问时间由寻道、旋转、传送时间构成。主要耗时是寻道和旋转，并且它们时间大致相等。 通用高速缓存存储器结构存储器地址 $m$ 位，形成 $2^m$ 个不同的地址。存储器有 $S=2^s$ 个高速缓存组，每组有 $E$ 行，每行有一个 $B=2^b$ 字节的数据块，一个有效位，$t=m-s-b$ 个标记位。因此地址从高位到低位是 $t$ 位标记位，$s$ 位组索引，$b$ 位块偏移。 直接映射高速缓存，$E=1$。$E\\not =1$ 是 $E$ 路组相联高速缓存。"},{"title":"SSM 框架学习笔记 5","date":"2020-07-02T23:13:14.000Z","url":"/2020/07/02/old_study_notes/ssm5/","tags":[["Java","/tags/Java/"],["Spring","/tags/Spring/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":"课程来源 MyBatis动态 sql超级拼串王。 if 标签：比如说根据 bean 查询，不是 null 的就要作为条件去查： 嫌上面的麻烦，可以把 trim 换成 where 标签然后把 and 写在前头而不是后头，也可以。 foreach： ids 是一个 @Param(&quot;ids&quot;) List&lt;Integer&gt; ids。 还有 choose 标签，就相当于 switch。 还有 set 标签，用于 update。update 里头一堆 if 后头带个逗号，可以用 set 标签包裹起来，就能消掉逗号，像 where 一样。 缓存一级缓存：sqlSession 级别，默认存在。任何一次增删改都会清空一级缓存。 MBGmybatis generator，根据数据库表就能自动生成 bean、dao，非常方便。"},{"title":"SSM 框架学习笔记 4","date":"2020-06-30T16:46:49.000Z","url":"/2020/06/30/old_study_notes/ssm4/","tags":[["Java","/tags/Java/"],["Spring","/tags/Spring/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":"课程来源 SpringMVC拦截器就是高级 filter。 （/interceptor 将页面转发到 success.jsp） 可以看出，顺序是 pre-目标方法-post-加载页面-after。多拦截器就是谁先配谁先执行。谁不放行，以后就都没有了。但是以前放行了的拦截器的 afterCompletion 还会执行。 异常处理可以直接写一个方法处理掉特定类型的异常： 自然也可以写一个异常处理类 可以使用 @ResponseStatus 做一个自定义异常状态，类似于404-页面飞了 这种感觉，自己搜。 工作流程（非原创，来自课程的笔记） 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获； DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： 不存在：再判断是否配置了mvc:default-servlet-handler： 如果没配置，则控制台报映射查找不到，客户端展示404错误； 如果有配置，则执行目标资源（一般为静态资源，如JSP，HTML）； 存在：执行下面流程； 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter； 如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息； 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等； 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等； 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中； Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象； 此时将开始执行拦截器的postHandle(…)方法【逆向】； 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet，根据Model和View，来渲染视图； 在返回给客户端时需要执行拦截器的AfterCompletion方法【逆向】； 将渲染结果返回给客户端。 整合问题通常 Spring 和 SpringMVC 整合的时候会分别写配置文件，并且分容器。所以也不会写出来一个 xml import 另一个 xml 这种鬼东西。 显然不能把 component-scan 这种东西写两遍。我们让 Spring 容器管理业务逻辑组件，用 SpringMVC 容器管理控制器组件。 springmvc.xml spring.xml 在 web.xml 里头用 dispatchservlet 写 springmvc 容器，用下面的写 spring 容器： 两个容器同时存在，spring 容器为父容器，springmvc 容器为子容器。springmvc 能引用 spring 的 bean，反过来不能。 MyBatisMyBatis 是一种持久化层框架（SQL 映射框架）。 使用 jdbc 麻烦又要硬编码 sql 语句。Hibernate 是一种 ORM 框架（对象关系映射），这玩意太强了，居然写 bean 就能解决建表更新等等的糟心事情。它就是个黑箱，不会 sql 也行。但是也是因为黑箱，自己写 sql 也不太方便，所以也不太好。它还是个全映射框架。MyBatis 则是一台能把 sql 写在配置文件里头的半自动洗衣机。 从文档复制一份全局配置文件： 然后写 sql 映射文件，就相当于接口的实现类： 太方便了 qwq。 全局配置文件这些标签是有先后的： 可以使用 properties 标签指定外部配置文件。 settings 修改 mybatis 的运行时规则，比如可以自动驼峰（a_column 到 aColumn）。还有延迟加载和按需加载： typeAliases 给常用的类型起别名。不过 mybatis 给常用类型起好了，我们也没有必要给自己的 bean 起别名。 enviorments 可以配多个环境（然而还是 spring 的强） mappers 里头的 mapper，可以用 resource 写类路径下的配置文件，可以用 class 指定接口的全类名（然后把配置文件放到同一个包里头），可以用 url 写磁盘或者网络上的配置。可以使用 package 批量注册，但是这时候配置文件要写在包里头。但是把 conf 标为源根以后创建一个同名包会和 src 的同名包合并，所以也不是什么大问题。 sql 映射文件获得自增主键的值： 没有自增也有相应的解决方法。 传参的时候，多个参数只能用 #{1} 或者 #{param1} 这种序号。这是因为 mybatis 将它们封装到了一个 map 中，key 是序号。可以用 @Param 指定参数封装时候的 key。可以传 map。传 pojo 就用属性名做 key。 #{xxx} 里头可以指定 jdbctype，这个好像跟 null 有关。其实 #{xxx} 和 ${xxx} 都可以取值，但是前者是参数预编译，就是参数用?替代，不会出现 sql 注入问题。后者就是简单拼串。一般都是使用前者，不过表名这种不支持预编译的就用后者就可以了。 花式查询查询 list 和查询 bean 的配置一模一样，只不过方法的返回值变成了 list。如果查询的是集合，那么 resultType 写的就是集合里的元素的全类名。 可以把查询结果封装到 map 里头，属性是 key，值是 value。 上面的是查询结果一行的。如果多行呢？ 如果名字不一样呢，比如数据库是 youjian，java bean 是 email？可以使用 select 起别名： 也可以使用 resultmap 硬点对应： 联合查询 数据库中 t_key 没有 lock，有一个外键 lockId。 如果想级联查询到这个 lock 怎么办？其实能猜出来，用 resultmap 把 lock 的 id map 到 lock.id 就差不多了。 更好的做法是使用 association，这样更清晰了： 如果要查询集合呢？比如 Lock 里头加一个 List&lt;Key&gt; keys。那就用 collection 呗。 （不要在意套娃） 如果嫌写 sql 麻烦可以用分步查询： 其实也就是把自己钦点变成了再 select 一次，免去了 left join 之忧。但是效率低。"},{"title":"SSM 框架学习笔记 3","date":"2020-06-25T11:13:12.000Z","url":"/2020/06/25/old_study_notes/ssm3/","tags":[["Java","/tags/Java/"],["Spring","/tags/Spring/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":"课程来源 SpringMVCREST以前我们用 addBook?id=2 来表示添加图书 id 为 2 的图书一本，现在用 book/2 发 PUT 来修改。用 get、post、put、delete。一个 url 就是一个资源。 这么写： jsp 页面这么写： 然后惊喜地发现，put 和 delete 不能用……tomcat 只支持 get 和 post 似乎。也许还有一个 head。这时候就要使用 spring 的 HiddenHttpMethodFilter。 并且加上 _method 隐藏域，写下真正的参数。 这时候 success.jsp 还会 405，这是因为经过那个 filter，http 请求的类型就变成了 put 之类的 jsp 不支持的内容。只要在被转发的页面加上一个 isErrorPage=”true” 就好了（这个方法感觉一点也不优雅……） 炫酷传参获得参数：直接在参数列表里头写就好了： 可以使用 @RequestHeader(&quot;User-Agent&quot;) 之类的东西获得请求头。可以使用 @CookieValue(value = &quot;JSESSIONID&quot;, required = false) 之类的东西获得 Cookie（再也不用自己遍历辣！） 甚至能直接传 pojo！ （SpringMVC 真强） 甚至可以写级联属性。直接把 name 写成 inner.attr 就可以了。 还可以写原生 api，HttSession HttpServletRequest 之类的。 解决乱码问题，只要使用 CharacterEncodingFilter 就好了。注意这个 filter 一定要写在所有 filter 的前头： 把数据带给页面可以在方法传入 Map（jdk 接口）、Model（spring 接口） 或 ModelMap（spring 类）。 success.jsp 里头就正常写 el 表达式。这里存放的数据都在 request 域中。 其实不管是哪一个，真正的类都是 BindingAwareModelMap…… 也可以使用 ModelAndView 取代返回值 String 从而实现携带数据。 怎样往 session 域放数据？在类处写注解 @SessionAttributes(&quot;msg&quot;)，这样给 request 中的 msg 放数据的时候也会给 session 放一份。也可以在里头使用 value = {&quot;msg&quot;, &quot;qwq&quot;} 钦点多个。使用 types={String.class} 可以同时钦定要放到 session 域中的数据的类型。同时满足 value 和 types 才会放进去。 这么写可能会出异常，就用原生 HttpSession 就行了…… 全字段更新考虑这样的场景：一个书城允许管理更改书的信息，其中书名是不能改的。这样一来，修改的表单里头就是写死一个书名，不会有一个书名的 input 框。在 SpringMVC 里头使用参数 Book book 接收，接收到的这个 book 唯独书名是 null。 如果此时用写了每一个字段的 update 更新，那直接就把书名给搞没了，完蛋了。造成这样惨重后果的原因是 book 原来就都是默认值，看着 post 上来的信息一个一个 set 的。如果能根据书的 id 获得这个 id 的书的对象，就有原来的所有信息了。然后哪个要改，就 set 哪个。这样就好了。使用 ModelAttribute。 解决思想是，这个 book 不应该是 new 出来的，而是一个准备好的对象。然后使用这个对象封装请求参数。 顺带一提，这里的 map 也是 BindingAwareModelMap，页面中都能取得这个 request 域中的对象。 ModelAttribute 方法会在该类任何方法之前执行！ 请求转发和重定向return &quot;redirect:/hello.jsp&quot;; 是请求转发到 hello.jsp，return &quot;redirect:/hello.jsp&quot;; 是重定向到 hello.jsp。不加斜线就是相对路径。顺带一提，原生 Servlet 中 sendRedirect 的时候要有项目名，这里不用。还有这里不用拼串。 form 自定义标签 顺带提一下，如果想访问静态资源，在 applicationContext.xml 里头加上： 都不加的时候，动态资源能访问，静态资源不能；只加第一个，静态资源能了，动态不行了；都加上才动静态都可以。 数据转换传了一个字符串，却想获得一个对象，那就自己写转换器。 添加进转换 service： 使用的时候跟取出来一个字符串一样： 顺带一提，一个 Date 的属性，可以使用 @DateTimeFormat 注解钦点格式。 数据校验用 jsr303 规范来实现数据校验。 使用 hibernate validator。 校验非常方便，首先在要校验的字段加上需要的注解 在要校验的方法添加 @Valid 和 BindResult 这样就好啦。你甚至可以方便地显示错误信息： （这也太方便了……） 如果要原生的呢？result 有个 getFieldErrors 得到的 list 一个一个遍历过去丢进一个 map 传过去也很方便。 ajax原来的 java web 还要引入 gson 转成字符串再写回去，现在 springmvc 引入 jackson 就非常方便了： 哪个是 ajax 方法，就加上一个 responsebody 就好了，对象会自动转换为 json 传回去。这就是将返回的数据放在响应体里头。 有哪个属性不想传，用 @JsonIgnore 注解。指定日期格式也有相应的注解。 使用 @RequestBody String reqb 可以获得表单 post 上来的东西，样式就是 username=poorpool&amp;password=123456 这种。 如果 post 的时候是用的 ajax post 过来一个 json，也可以当成对象获取。ajax 差不多这么写： 上传下载文件可以用 ResponseEntity 返回数据和定制响应头。用 HttpEntity 获得请求头。这个自己百度吧。 例如下载文件： 上传文件还是 commons 的那一套，但是更方便。 设置一些属性： 获得文件就像获得一个 String 一样，多方便啊。"},{"title":"SSM 框架学习笔记 2","date":"2020-06-20T16:42:36.000Z","url":"/2020/06/20/old_study_notes/ssm2/","tags":[["Java","/tags/Java/"],["Spring","/tags/Spring/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":"课程来源 SpringAOP面向拉面切面编程。将某段代码动态切入到指定方法指定位置运行。 建议复习动态代理。但是默认的动态代理要求被代理的对象实现了接口……而且写起来非常麻烦。 来，咱来切一个拉面： 还有不要忘记在 applicationContext.xml 里头加上： 整个测试： 成功了。不要忘记导入 aopalliance,aspectj.weaver 和 spring-aspects 三个 jar。 一些细节如果打印一下 calculator 的类型，发现它是 class com.sun.proxy.$Proxy29 之类的。说明内部还是通过动态代理实现的。代理对象和目标对象惟一的相通点就是实现了同一个接口。 甚至把实现接口去掉也是可以的。这时候打印一发 getClass() 就是 class net.yxchen.util.impl.CalculatorImpl$$EnhancerBySpringCGLIB$$5b0b9650，说明是 cglib 干的。通过搞一个奇妙内部类和一些神奇的操作创建好了代理对象。 关于通知顺序：如果正常返回，就是 @Before -&gt; @After -&gt; @AfterReturning，出现了错误抛出异常就是 @Before -&gt; @After -&gt; @AfterThrowing。还有一种 @Around 环绕的，不说了。 获得切入点信息如下： 顺带一提，在 AfterRunning 里头还可以钦点某个参数来接受返回值。这个自己点进去看吧。函数可以写得乱七八糟，参数列表一定不能乱写。 如果想提取切入点表达式，可以随便写一个空方法然后加 Pointcut。 非常重要的 @Around，这东西看上去一个顶四，就跟动态代理特别像： 可以看出，在添加了环绕通知以后，顺序变成了环绕前置-普通前置-方法执行-环绕返回/异常-环绕后置-普通后置-普通返回或者异常。前置方法没有定论，都可能在前头似乎。 如果多个切面套娃？呃，其实是按照字典序来的。也可以用 @Order 钦点顺序。默认值是 INT_MAX，越小优先级越高，越先执行越“在外头”。就好像洋葱头，真正的方法在里头，从外头向里头 Order 的数字增大。 如果低 order 套一个环绕（低是说 order 数字小），顺序就变成了环绕前置-低 order 前置-高 order 前置-方法执行-高 order 后置-高 order 返回-环绕返回-环绕后置-低 order 后置-低 order 返回。 上面说的都是注解的。其实还有配置的，就是写在 xml 里头。非常重要的一定要写在配置中，普通的就写注解就很可以了。 声明式事务事务，就要操作数据库。用 Spring 提供的 JdbcTemplate 和那个 QueryRunner 差不多。但是不太重要。 声明式事务是和编程式事务相对的。如果在以前学的 java web 项目里头想要写一个事务出来，就得写一个 TransactionFilter 拦截所有的请求（哪怕是请求图片），在里头取消自动提交，try catch 一大堆……这就是编程式事务。现在来看一个例子： （druid.properties 省略了，按照指定的 jdbc.xxx 格式写就行了） 然后调用一发 BookService 的 checkout，很舒适。可是出现了异常该怎么办？ 回想一下，发现我们原来的 TransactionFilter 跟前面讲的环绕通知好像啊！能不能让 aop 帮我们做呢？ 配置文件中加入： 并且在事务的方法上加一个 @Transactional 就好了。非常地新鲜，非常地美味。 隔离级别数据库的概念。脏读、幻读、不可重复读、两类更新丢失之类的数据库并发问题。 Jdbc 中有四种隔离级别，可以解决这些问题。mysql 默认的是可重复读。 事务传播事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。 常用的是前两个。默认的是第一个。这种情况如果事务套事务，那么其实是一个事务，要爆炸全爆炸。 我们可以手动设置事务传播级别： 如果我在 updatePrice 里头加一个除零，那么 checkout 可以执行，updatePrice 不可以。这是因为 checkout 搞了一个新的事务出去顺利执行了。 但是如果换一下，checkout 是 requires_new，updatePrice 是 requires 呢？发现两个都爆炸了。这是因为 updatePrice 除零的异常抛到了 multiTx。注意requires_new 的挂起当前事务。建议看这里的图示分析和后三分钟的例子（112p）。 还有一点。如果是 required 嵌套 required，那么小事务的属性都是继承自大事务的。在小事务里头设置 timeout 什么的是没有用的。 requierd 其实就是用原来的 connection，requires_new 是开一个新的。注意上面的是两个类。如果写在一个类里头直接方法名调用方法，其实就是本类方法直接调用，不经过代理，自然只是一个事务。 SpringMVCspring mvc 的思想是有一个前端控制器智能派发请求。 贴一下 hello world 的代码。 pom.xml（部分） web.xml springmvc.xml HelloController.java WEB-INF/pages/success.jsp（部分） index.jsp（部分） 这里要提一下那个 / 和 /*。其实在默认的 web.xml 里头有一个 defaultservlet map 到 /，一个 jspservlet map 到 *。如果我们的 dispatcher map 到 /，就相当于所有的静态资源都被我们的 dispatcher 管控。这时候如果请求 index.html，必然爆炸，因为 dispatcher 没有写处理 index.html 的。但是 jsp 因为不会被拦截，所以正常。 顺带一提，RequestMapping 也可以加在类上。这就是钦点基准路径了。 想访问这个方法，地址就是 /qwq/hello。 可以使用 method = RequestMethod.POST 来钦点接受请求的方式。用 params={&quot;qwq1&quot;, &quot;!qwq2&quot;, &quot;qwq3=qaq&quot;, &quot;qwq4!=qvq&quot;} 表示参数必须带上 qwq1，不能带 qwq2，qwq3 必须是 qaq，qwq4 不得是 qvq（空串、null 都可以）。可以用 headers 钦点请求头。 在写路径的时候，可以用一个 ? 表示任意一个字符，用 * 表示任意多个字符，或者写在两个斜线中间表示任意一层路径。用两个 * 写在两个斜线中间表示任意多层路径。 可以使用 @PathVariable 在 url 中用占位符。 "},{"title":"SSM 框架学习笔记 1","date":"2020-06-18T16:06:34.000Z","url":"/2020/06/18/old_study_notes/ssm1/","tags":[["Java","/tags/Java/"],["Spring","/tags/Spring/"]],"categories":[["框架","/categories/%E6%A1%86%E6%9E%B6/"]],"content":"课程来源 Spring是一种容器框架。 第一个程序记得先换 maven 源并且不出现傻叉错误。 还有注意添加 junit5 的时候检查一下模块那部分依赖的 junit 是不是 compile。 src/net/yxchen/bean/People.java src/applicationContext.xml src/net/yxchen/test/PeopleTest.java 输出结果： getBean 的时候也可以用 Person.class 这种东西，但要保证只有一个匹配。或者你全都要，名字和类型都写上。 自然可以用有参构造器。实在不想写甚至可以省略 name，或者使用 index 指定顺序。也可以用 type=&quot;xxx&quot; 指定类型。只有神经病才会使用后头的东西。 超级样例： 使用 parent=”xxx” 可以继承一个 bean 的配置，这样就不用写好多。如果一个 bean 只想让别人继承，就加一个 abstract=”true”。如果有依赖（就是谁要在谁之前创建），就写 depends-on=”person1, book1” 之类的。 bean 的 scope加一个 scope=”xxx” 可以指定 bean 的作用域，常用的为 prototype 多实例和 singleton 单实例。还有 request 和 session 但是用得少。prototype 在容器启动时候不会创建实例，每次取得才会。 工厂类取得 bean静态工厂： 实例工厂，先搞出来工厂再创建 bean： 还有一个操作是实现 FactoryBean 接口： src/net/yxchen/factory/FactoryBeanImpl 别看长得像一个普通 bean，只要实现了 FactoryBean 接口就会被认为是一个工厂： 顺带一提，不要想着用 ${username} 这种东西，这是 Spring 的关键字……系统用户名。 生命周期可以使用 init-method=”xxx” 和 destroy-method=”xxx” 来指定创建和销毁 bean 的时候的方法。 可以添加后置处理器，在调用初始化方法前后对 IOC 容器里头所有的实例都搞一遍。 通过构造器或工厂方法创建 bean 实例； 为 bean 的属性设置值和对其他 bean 的引用 将 bean 实例传递给 bean 后置处理器的 postProcessBeforeInitialization() 方法； 调用 bean 的初始化方法； 将 bean 实例传递给 bean 后置处理器的 postProcessAfterInitialization() 方法； bean 可以使用了； 当容器关闭时调用 bean 的销毁方法。 自动装配使用 autowire。有 byName，byType，constructor 等等。 java bean 程序里头怎么写，这里的 id 就要怎么写。 constructor 的话，比如public People(Car car) 的话，首先按照有参构造器类型进行装配，没有就直接赋 null。有的话，如果有多个，就拿名作为 id，没有就直接赋 null。 SpEL就和 EL 表达式差不多。写法是 #{xxx}。可以写字面量 #{123.4*5}，其他 bean 的属性 #{book01.bookName}，其他 bean #{car01}，甚至是静态方法 #{T(全类名).静态方法名(args)}。动态方法和其他 bean 的属性差不多。 注解配置有四个注解：@Repository 给 dao /持久层，@Service 给业务层，@Controller 给控制层，@Component 给其他受 Spring IOC 容器管理的组件。 写的时候加上对应的注解： 当然也可以指定 bean 名和单例多例之类的： 然后在配置 xml 里头写上自动扫描： 可以排除不要包含的文件： 也可以指定要包含什么： autowired 注解通过 autowired 注解实现自动装配： Autowired 是根据类型自动装配，找到一个就装配一个，没找到就爆炸。找到多个就按照变量名的 id 找。如果找不到的话……用 Qualifier 例如： 如果没有那个 Qualifier，因为变量名叫 bookDaoExt，所以就会找一个叫这个的。但是有了 Qualifier，就会按照 Qualifier 钦点的找。 如果钦点了 Qualifier 居然还没找到就还是得报异常。可以钦点 @Autowired(required=false)，这样找不到就装配 null 不报异常了。 Qualifier 甚至可以在参数上写： 顺带一提，autowired 的方法，当 Spring 容器在创建这个方法的时候会自动调用这个方法。每一个参数都会自动注入值。 另外，@Resource 这个 java ee 中的注解也可以实现自动装配。比 @Autowired 要差，但是扩展性好（因为后者必须要 Spring）。 单元测试如果想在单元测试中使用自动装配呢？是这样吗： 发现死循环了…… 其实要这么做： 泛型注入 然后发现这玩意居然能够自动装配！结果是： 其实也很好理解。对一个 carService 执行 save()，自动装配的是 BookDao&lt;Car&gt;，自然回去找这样的类。"},{"title":"Java Web 学习札记4","date":"2020-06-09T18:21:57.000Z","url":"/2020/06/09/old_study_notes/javaweb4/","tags":[["Java","/tags/Java/"],["Web","/tags/Web/"]],"categories":[["Web","/categories/Web/"]],"content":"建议改名游记.jpg 课程来源。 Filterfilter是个接口。 可以做权限检查、日记操作、事务管理……比如某个文件夹下的东西只有登录了才可以访问之类的。 然后web.xml里头照猫画虎： 除了目录匹配，精准匹配，还有后缀名匹配。用法显然。 生命周期也是启动的时候init，每次doFilter，结束的时候destory。 就好像Servlet有ServletConfig，Filter也有FilterConfig。可以类比第二篇札记内容。 重点是右下角蓝字。 过滤器并不关心请求的资源是否存在。 JSONjson对象和字符串互转： 值可以是对象，数组，map……之类的。 和JavaBean互转： 要用到Gson.jar。 也可以实现list和json互转，map和json互转。不写了。 AJAX用例： 使用jquery： 非常方便。 有更进一步的封装，$.get(url, data, callback, dataType)和$.post(...)，顾名思义。参数变成了url, data, callback和dataType。 更进一步是$.getJSON，显然是get一个json。参数变成了url, data和callback。 如果你想用ajax做提交表单之类的功能，可以考虑使用$(&quot;#form01&quot;).serialize()之类的东西。序列化可以将表单项变成name=value&amp;name=value。 tomcat 只会将 post 的请求的数据封装到 map 里头，put 都不会。可以自己配了 httpmethodfilter 以后加上 _method，也可以再配一个 httpputformcontentfilter。"},{"title":"Java Web 学习札记3","date":"2020-06-02T20:15:57.000Z","url":"/2020/06/02/old_study_notes/javaweb3/","tags":[["Java","/tags/Java/"],["Web","/tags/Web/"]],"categories":[["Web","/categories/Web/"]],"content":"建议改名游记.jpg 课程来源。 JSP如果用Servlet动态回传html文件，那一行一行write，得写死程序员…… jsp的本质是servlet程序。第一次访问jsp页面的时候，服务器把jsp翻译成一个源文件编译成字节码。其实，底层就是把翻译出来的html一行一行回传。 jsp格式每个生成的jsp页面开头都是page指令： 还有一些属性： autoFlush，设置当out输出流缓冲区满了之后是否自动刷新冲级区。默认值是true。buffer属性，设置out缓冲区的大小。默认是8kb。errorPage，出错时候自动跳转过去的页面。（这时候地址栏不变） 比如说加上一个errorPage=&quot;/error500.jsp&quot;，出现错误就显示error500.jsp了。 还有isErrorPage属性，顾名思义，默认false。true可以获取异常信息。 还可以导包导类…… 甚至可以在里头写声明，形如&lt;%! xxx %&gt;。作用就是给翻译出来的java类定义属性、静态代码块、方法、内部类之类的。 就想这样： 主要用的还是输出表达式： 页面上就会显示12、12.12等等。 甚至可以写代码脚本： jsp里头可以写html注释也可以写java注释。都会被翻译到对应的文件中。jsp注释是这样的&lt;%--jsp注释--%&gt;，不会被翻译。 域对象pageContext，当前jsp页面范围内有效。 request，一次请求内有效。 session，一个会话范围内（有效打开浏览器访问服务器，直到关闭浏览器） application，整个web工程范围内都有效只要web工程不停止，数据都在。 用的时候就request.setAttribute(&quot;key1&quot;, qwq);之类的。 用的时候最好从小到大用。 Session 生命周期什么时候创建 session？当第一次调用 session 的时候。 什么时候销毁 session？过期或者 invalidate()（不是关闭浏览器之类的） 拿一个 HttpSessionListener 去监听。打开服务器，如果访问一个 html 文件，发现不会创建 session。因为 html 又不会调用 session。但是如果是一个 jsp 就会。因为 jsp 一般有个默认 session 对象。具体地： Servlet 调用 HttpServletRequest.getSession(true) 或者 HttpServletRequest.getSession() 这样的语句时； 若第一次访问某 Web 应用的一个 JSP 页面，且该页面的 page 指定的 Session 属性为 true，则服务器会自动为该页面分配一个 HttpSession 对象。 顺带一题，正常关闭服务器的时候并不会让所有 session 都消失。这些 session 会“钝化”，序列化地保存下来。重启服务器的时候活化。 标签静态包含： 就可以了。footer.jsp就正常写。如果是html可能出现乱码，这个自己百度吧…… 动态包含: 这个其实是把包含的jsp也翻译成java程序，然后传request、resopnse、out过去。 甚至可以加参数： footer.jsp里头加一个&lt;%=request.getParameter(&quot;qwq&quot;)%&gt;。 请求转发 相当于request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response)。 EL表达式主要用来替换掉jsp输出，因为它太麻烦了…… 可太方便了。还有它的值是null的时候输出的是空串，而不是n-u-l-l。查找的时候四个域对象从小到大来。 它也支持一些运算符，例如${3 &gt; 5}就是false（&gt;也可以换成gt这样的英文），还有&amp;&amp;逻辑与，%模之类的。除法是小数除法。 empty运算符，当后头的为null、空串、长度大小为0的list数组map之类的都是true。 当然也有三元运算符、点运算符、中括号运算符之类的。 隐含对象取得四个域对象的信息，可以用xxxScope： 可以用${pageContext.request.serverName}之类的语句获得服务器地址。 还可以用param获得请求参数，paramValues获得一堆请求参数……不写了。 JSTL标签库el表达式简化了输出，jstl标签库简化了脚本。 首先下载taglibs的impl和spec两个jar丢进去。 然后导入核心库： 也有前缀为fmt的格式库（后头改成fmt），前缀为fn的函数库（后头改成functions）。 set标签： if标签（并没有else）： choose-when-otherwise（相当于switch） 伟大的forEach标签： 文件上传下载首先需要common-io和common-fileupload两个jar。 下载则是这样的： 然而如果文件名带有中文会乱码（响应头只能是ascii），chrome使用URLEncoder.encode(文件名, &quot;UTF-8&quot;)来代替setHeader那个fileName，但是火狐这么搞就是一坨百分号。firefox用base64编码。长这样：filename==?charset?B?xxxxx?= 其中charset换成编码（UTF-8)，B是base64,xxx是内容。 一般用user-agent选择。 MVC模型、视图、控制器。可以理解为model是javabean，视图是jsp/html，控制器是servlet。 COOKIE是服务器通知客户端保存键值对的手段。 BaseServlet是重写了doPost/doGet用反射调用方法的抽象类，自己写的。 获得（浏览器请求中的）cookie的话，用req.getCookies()获得Cookie[]数组。每个cookie都有getName()和getValue()方法。 修改的话，直接创建一个同名Cookie对象或者是获得了Cookie对象然后setValue()，然后都要addCookie(yourcookie)通知浏览器修改。 顺带一提，cookie的内容要求挺严格。要是有空格逗号中文之类的建议用BASE64编码。 生命控制使用setMaxAge()，正值是指定秒数以后过期，0是立刻删除，负值是关闭浏览器以后删除。 可以设置路径，只有在路径底下cookie才有效 例如：成功登录以后记录下来用户名这样下一次登录就不用输入用户名了： SessionSession 是一个接口，是会话，是用来维护一个客户端和服务器之间关联的一种技术。每个客户端都有自己的一个Session会话。 Session会话中，我们经常用来保存用户登录之后的信息。 创建Session： session也是域，可以在java代码中session.setAttribute(“key1”, “value1”)，也可以在jsp中用${sessionScope.key1}之类的东西。 关于寿命： 要调整默认时间，在自己的web.xml里头写。 至于Session和Cookie： "},{"title":"JDBC 学习札记","date":"2020-06-02T11:09:34.000Z","url":"/2020/06/02/old_study_notes/javajdbc/","tags":[["Java","/tags/Java/"],["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"课程来源 编写JDBC程序的流程 获取数据连接厂商实现java.sql.Driver接口。对于mysql，是com.mysql.cj.jdbc.Driver实现了它。 各种连接方式递进地看看怎么写 1-显式出现了api。 2-反射 注意java.sql.Driver是一个接口。这样用反射实现，可以把这个字符串丢到文件里头去。 3-DriverManager 5-扔到配置文件里头。这个是坠吼的。 直接在src里头写jdbc.properties 操作和访问数据库使用普通的Statement 敢这么写的不仅要拼串还要被sql注入打爆。 PreparedStatement可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象。能提高性能，防sql注入。 不写了，直接调Druid连接池和dbutils吧（狗头"},{"title":"Java Web 学习札记2","date":"2020-05-30T18:38:58.000Z","url":"/2020/05/30/old_study_notes/javaweb2/","tags":[["Java","/tags/Java/"],["Web","/tags/Web/"]],"categories":[["Web","/categories/Web/"]],"content":"建议改名游记.jpg 课程来源。 XML和html挺像。用dom4j（第三方来解析吧）。 Servlet用tomcat容器。 生命周期构造方法，init()最开始调用一次。 service()每次访问都调用。 destory()销毁时候执行。 使用实际开发很少写一个类去实现Servlet接口，而是继承HttpServlet类，重写doGET()和doPOST()，然后添加到xml里头。 src/com/poorpool/servlet/HelloServlet2.java web/WEB-INF/web.xml 浏览器中访问http://地址（可能端口后面还有工程路径）/hello2就能在控制台看到doget了。 继承结构GenericServlet抽象类实现Servlet接口，HttpServlet类继承GenericServlet抽象类。HttpServlet类抛没有实现doGet()和doPost()异常，用户自己继承HttpServlet类override这俩。 ServletConfig比方说 输出就是 getServletConfig()也可以获得ServletConfig。 不过注意如果继承HttpServlet的类（其实是GenericServlet抽象类）要重写init()方法的话一定要super.init(config)。有操作哒。 ServletContext是个接口，表示Servlet上下文对象。一个工程只有一个实例。它是一个域对象。 域对象是可以像 Map 一样存取数据的对象。用setAttribute()，getAttribute()和removeAttribute()。 四大功能： 获取 web.xml 中配置的上下文参数 context-param。 获取当前的工程路径。格式: /工程路径。 获取工程部署后在服务器硬盘上的绝对路径。 像 Map 一样存取数据。web.xml ContextServlet.java 我感觉这个的用处就是比如自己想要根据请求修改一些文件，例如/img/1.jpg，但是我又不可能在代码中硬编码一个/home/.../web/img/1.jpg进去，所以就可以getRealPath(&quot;/img/1.jpg&quot;)这样的。 如果是像Map一样保存数据的话： 获得请求信息 获得GET的表单信息 post也一样，但是如果post直接搞含中文的会乱码，要设置req.setCharacterEncoding(&quot;UTF-8&quot;);。 请求转发 地址栏不变化 是一次转发 共享Request域数据 甚至可以访问WEB-INF。 但是仍然不能访问工程之外的东西。 关于第四条： 因为web-inf下,应用服务器把它指为禁访目录,即直接在浏览器里是不能访问到的.但是可以让servlet进行访问,如web-inf下有a.jsp则可以用request.getrequestdispatcher(“/web-inf/a.jsp”).forward(request,response);补充一下，如果你想访问web-inf下的htm文件的话，用request.getrequestdispatcher(“/web-inf/a.htm”).forward(request,response);是访问不了的。原因很简单，jsp就是servlet，会被编译成class文件，而htm的就不行了。所以需要配置以下conf下的web.xml文件才能去访问htm。具体实现如下：用打开tomcat安装目录下conf下的web.xml文件，找到&lt;servlet-mapping&gt;&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;&lt;url-pattern&gt;.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;然后在它下面添加&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;&lt;url-pattern&gt;.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet1.java Servlet2.java base标签设想这样的场景：web/index.html，web/a/b/c.html。index到c的超链接可以用a/b/c.html，c到index可以../../index.html。 但是如果使用请求转发，index.html中有一个朝向的链接，用这个链接转发到a/b/c.html，是可以的。但是如果c仍然使用../../index.html，因为此时的地址仍然是那个Servlet的，而不是，所以就不能正常返回了。 所以要么使用绝对路径，要么在使用相对路径的时候加上一个base标签。在head中加入 注意一下：/斜杠被浏览器解析就是ip+端口。被web服务器解析就是工程路径，但是如果要让它被服务器解析，就是response.sendRediect(&quot;/&quot;); HttpServletResponse它可以获得字节流getOutputStream()或者是字符流getWriter()，二选一，不能都取得。用法显然。 但是写中文会有乱码，可以用它解决： 请求重定向 地址栏变化 两次请求 不共享Request域数据 不能访问WEB-INF数据 可以访问工程外数据 直接 就好。"},{"title":"Java Web 学习札记1","date":"2020-05-28T21:09:47.000Z","url":"/2020/05/28/old_study_notes/javaweb1/","tags":[["Java","/tags/Java/"],["Web","/tags/Web/"]],"categories":[["Web","/categories/Web/"]],"content":"建议改名游记.jpg 课程来源。 HTML、CSS和JavaScriptiframe就相当于页面里的一个页面，套 娃。 点击link，iframe里头的东西就会变成test2.html。这是伟大的target的功劳。（顺便一提，target里头_blank是新标签页，_self是本页面切换）。 JS的可变参数其实是隐形参数，用arguments数组就可以啦。（顺带一提，JS没有重载。如果妄图这么写，后头的函数会覆盖前头的）。 JS的对象弱类型的秘宝。 事件onload（页面加载完触发） onclick点击按钮，onblur失去焦点，onchange发生改变，onsubmit表单提交的时候。只写前三个的动态注册。 DOMDocument Object Model 文档对象模型，把标签文本啥的统统作为对象来管理。 优先getElementById，然后getElementsByName，然后getElementsByTagName。也可以document.createElement(tagName)创建标签对象。要加载完才执行。 相当于这种结构 看一个用户名校验的例子 多选 jQueryjQuery里有个奇妙函数$()。 传入参数为函数时：表示页面加载完成之后。相当于window.onload = function(){} 传入参数为HTML字符串时：创建HTML标签对象。 传入参数为选择器字符串：可以是$(&quot;#someID)，$(&quot;someTagName)和$(&quot;.class someClassName&quot;)。 传入参数为DOM对象时:会把这个DOM对象转换为 jQuery 对象 jQuery对象是DOM对象数组加上一些操作方法。DOM对象转jQuery对象用$(DOM对象)，jQuery对象转DOM对象用$obj[下标]。 选择器#idName，.className，typeName，name1, #id2, .class3……之类的。*所有。 $(&quot;span, #two&quot;)就是选中所有span以及所有id是two的元素。 jQuery 还有一些杂七杂八的过滤器，比如:first，:last，:not(选择器)，甚至可以$(&quot;div:not(:animated):last&quot;)选择没有执行动画的最后一格div。 还有一些内容过滤器、属性过滤器[attribute]，[attribute=value]，[attribute!=value]（不含该属性或者含有属性但不为value的都被选中）。 还有一些表单过滤器，匹配文本框密码框选中的东西之类的……太多了自己翻文档吧。 还有一些元素筛选方法。$(&quot;p&quot;).eq(1)和$(&quot;p:eq(1)&quot;)就是一样的。太多了不写了。 jQuery属性 html()是获得里头的html代码（dom的innerHTML），如果带上参数，就成了设置。同样的还有text()（dom的innerText）以及表单中的val()。 val有诸多妙处： attr()一个参数是获取属性，两个参数是设置。例如attr(&quot;name&quot;)和attr(&quot;name&quot;, &quot;checkbox&quot;)。 但是attr有一个问题， alert出来居然是undefined，这到底是未定义还是false？这种情况用prop()。prop只推荐操作 checked、readOnly、selected、disabled 等等。 使用jQuery的全选反选不选： 增删改查a.appendTo(b) 把 a 插入到 b 子元素末尾，成为最后一个子元素。a.prependTo(b) 把 a 插到 b 所有子元素前面，成为第一个子元素。a.insertAfter(b) 得到 ba。a.insertBefore(b) 得到 ab。a.replaceWith(b) 用 b 替换掉 a。a.replaceAll(b) 用 a 替换掉所有 b。a.remove() 删除 a 标签。a.empty() 清空 a 标签里的内容。 实例：表单添加和删除 操作CSS样式addClass(“someClass1 someClass2”) 添加样式。removeClass()删除样式（有参数就删参数，没参数就全删掉）。toggleClass(“someClass”) 有就删除，没有就加。offset() 获取和设置元素的坐标。不加参数返回一个{top: xx; left: yy;}，加上这样的参数就是设置。 动画show()，hide()，toggle()是显示隐藏切换（像是连续调整div长宽），fadeIn()，fadeOut()，fadeTo()，fadeToggle()是淡入单出淡入到切换。都能接收两个可选参数，第一个时长（毫秒），第二个回调函数。fadeTo接收0-1之间的半透明值。fadeToggle也可以有”slow”、”linear”。之类的东西。自己翻文档吧。 和原生js区分jQuery的页面加载完成是创建好dom对象之后。原生js的页面加载完成是dom对象创建好和显示的内容也加载好了才执行。 jQuery多注册几个页面加载完成的都执行，window.onload就最后的执行。 其他事件click带参数就是绑定click事件，不带就是触发。还有鼠标移入移出之类的。 bind可以绑定事件，例如bind(“mouseover mouseout”, someFunction)之类的，unbind解绑。one是绑定但只执行一次。 live也绑定，它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出来的也有效。 事件父子元素同时监听同一个事件。当触发子元素的事件的时候,同一个事件也被传递到了父元素的事件里去响应。 在子元素事件函数体内,return false; 可以阻止事件的冒泡传递。 至于function获得事件，加一个event参数就行了。下面是“鼠标放到小图上的时候就会出现跟随着小图的大图”的实例。 "},{"title":"Java的一些知识2","date":"2020-05-20T14:47:37.000Z","url":"/2020/05/20/old_study_notes/javaknows2/","tags":[["Java","/tags/Java/"],["面向对象","/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"杂项 国际化 ThreadLocal先来看一段明显错误 输出全是you。 用ThreadLocal每个线程就能保存自己的东西： Timer类干守护线程类似的任务。 schedule方法有挺多，可以看看。 流OutputStream字节输出流 InputStream字节输入流 Writer字符输出流 Reader字符输入流 字节流和字符流的区别因为字节流是字节，字节输出流便可以直接与目标介质进行输出控制。字符流要有一个内存缓冲区，flush一下才会写入目标介质。具体地，写了不close，字节输出流的文件有东西，字符输出流的文件没东西。中文主要用字符输出流。 转换流 顺带提一下transferTo。这样能很轻松实现文件复制。 内存流 还有管道流，用于多线程or进程之间的输入输出。这个不写了。 RandomAccessFile实现文件的随机读取。 打印流 Scanner 这个最好使。不行就BufferReader。 输出可以考虑PrintWriter。 序列化 不过，像是总价=单价*数量就没有必要序列化，可以用transient关键字。 网络编程 Java里头有ServerSocket和Socket，挺方便的。 多线程也好处理，每次accept一个client的socket就把它扔进一个Runnable里头跑起来。 也可以使用udp的socket。 "},{"title":"Java的一些知识","date":"2020-05-07T21:01:37.000Z","url":"/2020/05/07/old_study_notes/javaknows/","tags":[["Java","/tags/Java/"],["面向对象","/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"杂项 继承继承的方法的公开程度，子类不得比父类局限。 如果父类的方法是private，那么其实哪怕子类写了一个参数名字一模一样的public也不算覆写。 泛型 枚举java的枚举强得很。它这么强主要是靠Enum类。 外部类内部类访问外部类 超级无敌内部类接口大杂烩 输出结果 多线程继承Thread类然而显然不推荐……因为java是单继承。 使用Runnable接口 其实看源代码能发现Thread类里头有 共享数据 用一个实现Runnable的类扔到多个Thread里头的方法比较常见。上面就是三线程卖票（虽然有一点碰撞）。 Callable接口实现返回值 Callable是一个FunctionalInterface，FutureTask是一个实现了RunnableFuture接口的类，RunnableFuture继承了Runnable、Future接口。get方法会阻塞，从而实现异步返回。 生产者消费者模型实例 资源文件 文件存放在相应位置的properties的文件，形如hello.mgs=Ni hao，等号不能有空格。"},{"title":"《计算机网络：自顶向下方法》笔记8 计算机网络中的安全","date":"2020-05-01T10:00:07.000Z","url":"/2020/05/01/cs_notes/topdown_chapter8/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第八章 安全通信需要具备机密性、报文完整性、端点鉴别、运行安全性 密码学的原则这一部分解决了机密性的问题。 在对称密钥系统中，alice和bob的密钥相同且秘密；在公开密钥系统中，一个密钥全世界都知道，另一个密钥只有alice或bob知道（而不是两个都知道） 对称密钥密码体制对于凯撒密码或者单码代替密码，攻击手段： 唯密文攻击 已知明文攻击：攻击者知道(明文，密文)的一些匹配的时候 选择明文攻击：如果攻击者能让alice发送The quick brown fox jump over the lazy dog，那么加密方案就能完全破译。 多码代替密码：顾名思义，就是用多个单码代替密码，换着来。 块密码要加密的报文处理为$k$比特的块，每块独立加密。 这是一个块密码的例子，密钥是8张排列表。 怎样使相同的明文的密文不同？可以引入随机性。通常使用密码块连接CBC的计数，具体思想是仅第一个报文发送一个随机值，然后让发送方和接收方用计算的编码块代替后续的随机数。 公开密钥加密bob有全世界都知道的公钥和只有他自己知道的私钥。alice想跟bob取得联系，就先获得bob的全世界都知道的公钥然后用全世界都知道的加密算法加密发给bob，bob用全世界都知道的解密算法和只有他自己知道的私钥解密。 但是这样也许会出现选择明文攻击，攻击者对所有怀疑可能被发送的报文编码。还有此时无法验证发送者的身份。 RSARSA几乎成了公开密钥加密的代名词。 生成公钥私钥的步骤： 选择两个大素数$p$和$q$ 计算$n=pq$和$z=(p-1)(q-1)$ 选择小于$n$且和$z$互质的$e$ 求一个$d$使得$ed\\bmod z=1$ 公钥是$(n,e)$，私钥是$(n,d)$ 明文$m$的加密值：$c=m^e\\bmod n$ 密文$c$的解密：$m=c^d\\bmod n$ 在应用中，rsa比较慢，通常和对称密钥密码结合做。比如alice设置一个会话密钥，用rsa这一套传给b，然后用会话密钥进行加密数据传输 RSA的工作原理加密解密的结果是$(m^e\\bmod n)^d \\bmod n$也就是$m^{ed}\\bmod n$，考虑欧拉降幂，$z=\\varphi(n)=(p-1)(q-1)$，于是$m^{ed}\\bmod n=m^{ed\\bmod z}\\bmod n=m\\bmod n$。 你甚至可以发现先解密后加密结果一样。这个按上面的自己推一遍就好了。 rsa的安全性基于大数因式分解是困难的。 报文完整性和数字签名这一部分解决报文完整性的问题。 密码散列函数散列函数以$m$为输入，计算得到一个称为散列的固定长度字符串。 因特网检验和和CRC都是。因特网检验和显然是一个劣质的。 它还要求对于$x\\not=y$，$H(x)\\not=H(y)$。 广泛使用的MD5得到128比特的散列，SHA-1生成一个160比特的报文摘要。 为了报文完整性，alice和bob还要共享秘密$s$，鉴别密钥。 alice计算散列$H(m+s)$，它被称为报文鉴别码MAC，生成扩展报文$(m, H(m+s))$发给bob。bob得到扩展报文$(m, h)$，因为知道$s$，所以计算出$H(m+s)$，如果等于$h$，那么一切正常。 数字签名这个签名应该是可以鉴别的，不可伪造的。bob为了签署一个文档，显然需要将一些独特的信息附加上来。 所以bob直接用私钥加密（回想rsa的工作原理这一部分，先解密后加密结果一样），这样如果用全世界都知道的bob的公钥解开了这个密文，那么就能知道这个是bob签署的了。 不过因为加密解密代价昂贵，没有必要完全签名数据。对报文的散列签名就可以了。 显然数字签名比MAC更高级。 公钥认证将公钥和特定实体绑定由认证中心CA完成。 端点鉴别这一部分解决端点鉴别的问题。 研究一个自己的鉴别协议：AP ap1.0：我宣布我是alice，我就是alice。 ap2.0：alice有一个总是用于通信的周知网络地址（比如ip地址），bob可以检查报文的ip数据报源地址和alice的周知ip地址是否匹配。 ap3.0：使用秘密口令。嗅探数据分组存下来就破了。 ap3.1：用加密口令。回放攻击就破了。 ap4.0：使用不重数nonce。一个协议的生存周期中只使用一次的数。 alice发送“我是alice” bob发送不重数$R$给alice alice使用和bob共享的对称秘密密钥加密不重数，发给bob bob解密收到的。如果等于，就鉴别了alice的身份。 安全电子邮件我们需要什么？第一机密性，第二发送方鉴别，第三报文完整性，第四接收方鉴别。 机密性最直接的方式是对称密钥，然后是公开密钥密码。为了克服效率问题我们使用会话密钥。这个前面说过了。 要结合机密性、发送方鉴别和报文完整性的话，就把上面这套和数字签名和报文摘要加上。安全地分发公钥可以使用CA。 使TCP连接安全：SSL安全套接字层ssl，ssl版本3的稍加修改版本是运输层安全性tls。 宏观描述握手： bob要和alice创建一条tcp连接，验证alice是真的alice，发给alice主密钥，用这个主密钥生成ssl会话所需的所有对称密钥。 密钥导出： 两边都根据主密钥生成四个密钥： $E_B$，从bob到alice的会话加密密钥 $M_B$，从bob到alice的会话MAC密钥 $E_A$，从alice到bob的会话加密密钥 $M_A$，从alice到bob的会话MAC密钥 数据传输： ssl将数据流分割成记录，每个记录附加一个mac用于完整性检查，然后加密记录+mac。为了产生这个mac，bob将数据连同密钥$M_B$放入一个散列函数中。为了加密记录+mac这个包，bob使用会话加密密钥$E_B$。 序号可以防止重放攻击。 更完整的描述其实，真正的握手是： 客户发送支持的算法密码的列表和一个不重数。 服务器选择对称算法、公钥算法和mac算法，连同证书和服务器不重数返回 客户加密地发送前主密钥给服务端 客户和服务器独立从前主密钥和不重数中计算出主密钥，划分出四个密钥。 客户发送所有握手报文的mac 服务器发送所有握手报文的mac 在ssl中，不重数用来防御连接重放，序号用于防御在会话中重放个别分组。 网络层安全性：IPsec和虚拟专用网这个看不懂 使无线lan安全WEP协议 无线主机请求鉴别 接入点以不重数响应请求 无线主机用和接入点共享的密钥加密不重数 接入点解密加密的不重数 802.11i协议更加安全，主要是靠鉴别服务器。 运行安全性：防火墙和入侵检测系统防火墙的目标： 从外部到内部or内部到外部所有流量都经过防火墙 仅被授权的流量允许通过 防火墙自身免于渗透 防火墙也分为三类： 传统的分组过滤器： 例如，防止网络被跟踪路由，可以丢弃所有出ICMP TTL过期流量。 状态分组过滤器： 这个在访问控制列表中包括了一个新栏“核对连接”。 应用程序网关 入侵检测系统为了检测多种攻击类型，我们需要执行深度分组检查。常用入侵检测系统ids。 一个机构可能有多个ids传感器，划分为高度安全区域和低度安全区域，前者有分组过滤器、应用程序网关和ids系统，后者没有应用程序网关。 ids系统大致分为基于特征的系统和基于异常的系统。"},{"title":"《计算机网络：自顶向下方法》笔记7 无线网络和移动网络","date":"2020-05-01T10:00:06.000Z","url":"/2020/05/01/cs_notes/topdown_chapter7/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第七章 概述三要素：无线主机、无线链路、基站。 蜂窝网络的蜂窝塔，无线LAN中的接入点都是基站。 基础设施模式是所有传统的网络服务例如地址分配和路由选择都是网络通过基站向相连的主机提供，自组织网络是主机自身提供路由选择地址分配等服务。 移动主机从一个基站的覆盖范围跑到另一个基站的覆盖范围是切换。 按照跳数和基础设施分类： 单跳，基于基础设施。平常的802.11网络、4G LTE网络都是。 单跳，无基础设施。蓝牙和具有自组织模式的802.11网络。 多跳，基于基础设施。一个基站有线地连接到较大网络，但是某些无线节点不得不经过其他无线节点中继来经该基站通信。 多跳，无基础设施。 无线链路和网络特征对于无线网络，重点是链路层： 递减的信号强度 来自其他源的干扰 多径传播（经反射等） 它更容易出现比特差错，所以用crc错误检测码加上链路层ARQ协议来重传受损的帧。 信噪比SNR是所收到的信号和噪声强度的相对测量，单位是分贝dB。 比特差错率BER大致是接收方收到的有错传输比特的概率。 对于给定的调制方案，snr越高，ber越低。 对于给定的snr，具有较高比特传输率的调制技术将具有更高的ber。 物理层调制技术的动态选择能用于适配对信道条件的调制技术。 还有隐藏终端问题和衰减使得多路访问在无线网络中更复杂。 CDMA码分多址CDMA属于信道划分协议族，挺有意思的，虽然现在好像要退网了…… 比方说一对男生一对女生在一个地方同时谈话，男生谈球鞋型号，女生谈口红色号，虽然他们同时同频，但是他们都能获取到自己的信息。 在cdma中要发送的每个bit都通过乘以一个信号（比特）的编码来进行编码，这个信号的变化速率（码片速率）比初始比特序列的变化快得多。为了数学的方便，我们把0比特取值为-1。 如图。稍微详细一点的看书。 如果有干扰呢？如果精心选择发送方的编码，那么有干扰也会被干掉。 WiFi：802.11无线LAN802.11设备工作在2.4-2.485GHZ和5.1-5.8GHz两个频段（2.4GHz和5GHz），2.4GHz频段无需执照，电话和微波炉可能会争用频谱。5GHz对于给定的功率等级有更短的传输距离，受多径传播影响大，但是传输速率高。 802.11体系结构802.11体系结构的基本构件模块是基本服务集BSS，一个bss包含一个或多个无线站点和被称为接入点AP的中央基站。 每个无线站点都有一个6字节mac地址，在适配器固件中，每个ap的无线接口也有一个mac地址，这些地址由ieee管理，理论上唯一。 信道与关联每个无线站点在能够发送接收网络层数据前必须和一个ap相关联。当网管安装一个ap时，为该接入点分配一个单字or双字的服务集标识ssid，为该ap分配一个信道号。在2.4-2.4835GHZ这85MHz的频段内，802.11定义了11个部分重叠的信道，1、6、11是惟一三个非重叠信号的集合。所以网管可以在同一个物理网络中安装3个802.11b AP，每个ap都连到一台交换机上。 WiFi丛林是一个无线站点能从两个或多个ap中收到很强的信号的物理位置。你的无线站点需要加入其中一个子网因此需要跟其中一个AP关联。802.11要求每个ap周期性地发送信标帧，包括该ap的ssid和mac地址。你的无线站点为了得知在发送信标帧的ap，扫描十一个信道，找出可能的信标帧。然后选择一个ap关联。 扫描信道和监听信标帧是被动扫描，当然也能主动扫描，就是向位于无线主机范围内所有ap广播探测帧。 无线站点鉴别自身的方法是mac地址或者用户名+口令。 802.11MAC协议随机访问协议：带碰撞避免的CSMA也就是CSMA/CA 。802.11使用碰撞避免而非碰撞检测。并且使用链路层确认/重传ARQ方案。 站点包括无线站点和ap。一旦站点开始发送一个帧，它就完全地发送这个帧。 链路层确认： 目的站点收到一个通过crc校验的帧后等待一个短帧间间隔SIFS，然后返回一个确认帧。发送站点在给定的时间没有收到确认帧就假定出现了错误并重传该帧，使用CSMA/CA协议访问信道。如果若干固定次重传以后仍未收到确认就放弃发送并丢弃该帧。 如图是csma/ca协议的示意图，具体看书。 为啥要等一段时间？假设两个站点各有一个数据帧要发送，如果不等，检测到信道里第三方传输完毕后它们立刻开始发送，那么这两个碰撞憨了。所以它们立即随机回退，希望借助不同的回退值来解决碰撞，也就是（如果两个站点没有对对方隐藏）让“失败站点”听到“胜利站点”的信号。当然，这种情况不一定能完全避免。 处理隐藏终端：RTS和CTS 如图，h1和h2都没有对ap隐藏，但是对对方隐藏了。这样等待一个difs就是无用功。 它允许站点使用一个短请求发送RTS控制帧和短允许发送CTS控制帧来预约对信道的访问。 如图，广播的cts帧有两个作用：给发送方明确的发送许可，指示其他站点在预约期内不要发送。 rts/cts交换仅仅用于为长数据预约信道。 IEEE802.11帧 尽管有效载荷的最大长度是2312字节，但它通常小于1500。 地址1是要接收该帧的无线站点的mac地址。 地址2是传输该帧的mac地址。 地址3，回想一下bss，它是无线站点和ap所在的子网与其他子网相连的路由器接口的mac地址。 考虑R1发报到H1来回的过程。 路由器知道h1的hp地址（从数据报目的地址得到），使用arp确定h1的mac地址。r1将该数据报封装在一个以太网帧中，源地址是r1 mac地址，目的地址是h1 mac地址。 以太网帧到达ap以后，被转化为一个802.11帧，地址1是h1 mac地址，地址2是自身的mac地址，地址3是r1的mac地址。 h1发报给r1：h1生成一个802.11帧，用ap mac，h1 mac，r1 mac填充地址123。 ap接收802.11帧时转化为以太网帧，源地址是h1 mac，目的地址是r1 mac。 在相同的ip子网中的移动性 如图，h1检测到来自ap1的信号逐渐减弱并开始扫描更强的信号，收到来自ap2的信标帧（ap2和ap1的ssid常常相同），h1和ap1解除关联，和ap2建立关联。 交换机怎么知道呢？一种解决方法是新的关联形成以后让ap2以h1的源地址向交换机发送一个以太网广播帧，交换机收到该帧以后就更新转发表。 蜂窝因特网接入走向4G：LTElte在下行信道使用tdm和fdm结合的方法，叫正交频分复用OFDM。 移动管理：原理 考虑这样的情况：一个移动节点有归属网络和归属代理，所在网络在外部网络或被访网络。 寻址某节点位于一个外部网络的时候，所有指向此节点固定地址的流量要导向外部网络，一种方法是外部网络向其他网络发通告，告诉该移动节点正在他的网络中。 一种替代的方法是将移动性功能从网络核心搬到网络边缘，外部代理的作用之一就是为节点创建转交地址COA。coa有时又称为外部地址。外部代理的第二个作用就是告诉归属代理该移动节点在他的外部代理网络中有给定的coa。 移动节点的间接路由选择 如图，通信者只是将数据报寻址到移动节点的固定地址，而归属代理除了跟踪coa的变化以外，还监视到达的数据报。要是数据报寻址的节点的归属网络和归属代理所在网络相同但是节点却在某个外部网络，归属代理就将数据报转发给外部代理，外部代理转发给移动节点。为了使数据报到达的时候不变，还需要封装，相当于4.3节中的隧道。 移动节点的直接路由选择间接路由选择有三角路由选择问题：即使在通信者和移动节点之间有一条更有效的路径，数据报也要先发给归属代理。 所以引入通信者代理，这需要一个移动用户定位协议，以便通信者代理向归属代理查询获得移动节点的coa。 使用直接路由选择的时候归属代理仅在会话开始的时候被通信者代理询问coa一次。因此如果在归属代理中更新coa并不能解决数据路由选择到移动节点新的外部网络的问题。 解决方法是使用锚外部代理，它是首次发现移动节点的外部网络中的外部代理。如果移动节点发生移动，就让新的外部代理向锚外部代理提供移动节点的新coa。 移动IP三部分：代理发现、向归属代理注册、数据报的间接路由选择。 代理发现： 一个移动ip节点到达新网络，首先要知道相应的外部代理or归属代理的身份。 要么使用代理通告： 代理周期性地在所有连接的链路上广播特殊的icmp报文 要么使用代理请求：移动节点广播代理请求，收到请求的代理发送代理通告。 管理蜂窝网中的移动性这一段比较繁琐，但是能解决“边打电话边开车”的疑惑，建议看书。 无线和移动性：对高层协议的影响影响不是很大，不过tcp的拥塞控制反应在无限情况下可能会有问题，解决方法是：本地恢复、tcp发送方知晓文件线路、分离连接方法。 还有需要考虑，无线网络通常带宽要小。"},{"title":"《计算机网络：自顶向下方法》笔记6 链路层和局域网","date":"2020-05-01T10:00:05.000Z","url":"/2020/05/01/cs_notes/topdown_chapter6/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第六章 链路层概述链路层在何处实现链路层的主体部分是在网络适配器（网络接口卡）实现的。大部分链路层是在硬件中实现的。 差错检测和纠正技术链路层有比特级差错检测和纠正。在发送节点，为了保护bit免受差错，使用差错检测和纠正比特EDC来增强数据。 不过即使使用EDC也有可能未检出比特差错。 奇偶校验假设 $D$ 有 $d$ 比特，那只需要一个附加的比特，使得 $d+1$ 个比特中1的总数是偶数。若接收方发现1的bit有奇数个，就是发生了奇数个比特错误。如果出现了偶数个比特差错，会导致一个未检出的差错，但是这个概率是极小的。然而差错经常“突发”地聚集在一起，所以这个不太健壮。 如图，二维奇偶校验能够检测并纠正一个bit错误，能检测（但不能纠正）两个bit错误的任意组合。 接收方检测和纠正差错的能力叫前向纠错FEC。它们可以减少发送方重发的次数，避免了往返时延。 检验和方法$d$比特数据被作为一个$k$比特整数的序列处理。因特网检验和就是将数据的字节作为16比特的整数求和取反码。接收方对接收的数据（和检验和）求和取反码，有0就出现了差错。在tcp，udp中对所有字段求因特网检验和。 循环冗余检测循环冗余检测CRC编码也称为多项式编码，它把发送的比特串视为0/1系数多项式，对比特串的操作解释为多项式算数。 发送方接收方首先必须协商一个$r+1$比特模式称为生成多项式，表示为$G$。 考虑$d$比特的数据$D$，发送方要选择$r$个附加比特$R$，把他们附加到$D$上，使得到的$d+r$比特模式（被解释为一个二进制数）用模2算数恰好能被$G$整除。 接收方用$G$去除接收到的$d+r$比特，如果余数非0，就是出现了差错。 所有CRC计算用模2算数来做，加法不进位减法不借位，其实就是个XOR…… 乘$2^k$就是比特模式左移$k$个位置。 我们要求出$R$使得对于$n$有$D2^r\\mathrm{xor} R=nG$，$D2^r=nG\\mathrm{xor} R$，也就是用$G$除$D2^r$余数刚好是$R$。 所以$R=\\mathrm{remainder}\\dfrac{D\\cdot 2^r}{G}$。 国际标准已经定义了8、12、16、32比特生成多项式。$G_{CRC-32}=100000100110000010001110110110111$这种。 每个CRC标准都能检测小于$r+1$比特的突发差错。长度大于$r+1$比特的突发差错检测到的概率是$1-0.5^r$。每个CRC标准也都能检测任意奇数个比特差错。 多路访问链路和协议有两种类型的网络链路：点对点链路和广播链路。要通过多路访问协议来规范共享的广播信道上的传输行为。 因为所有节点都能传输帧，所以多节点可能会同时传输帧，这时所有节点同时接收到多个帧，传输的帧在所有接收方碰撞，结果没有一个节点能有效获得任何帧…… 信道划分协议一种做法是划分信道，时分多路复用TDM和频分多路复用FDM。 tdm非常公平。但是节点总是被限制于$R/N$的平均速率并且总是需要等待它在传输序列中的轮次。 fdm的平均速率也被限制。 第三种是码分多址CDMA，tdm和fdm分别为节点分配时隙和频率，而cdma对每个节点分配一种不同的编码，然后每个节点用唯一的编码来对发送的数据编码。这样不同节点能同时传输并且各自的接收方仍能正确接受发送方编码的数据（如果接收方知道发送方的编码）。 随机接入协议一个传输节点总是全速发送，碰撞时等待一个随机时延然后重发帧。 时隙ALOHA协议：菜菜的。要求所有帧由L比特组成，时间划分成长度为$L/R$秒的时隙，节点只在时隙起点传输帧，每个节点都知道时隙何时开始，如果一个时隙中出现了碰撞那么所有节点都能在该时隙结束前检测到该碰撞事件。 操作是有在一个时隙开始的时候传输整个帧，要是有碰撞就以$p$的概率在后面的时隙重传，直到传输成功。但是效率非常低。纯ALOHA就更加白给。 载波侦听多路访问CSMA：说话之前先听（这是载波侦听）。和他人同时开始说话就停止说话（这是碰撞检测）。 大致过程：侦听到信道空闲——传输——没有检测到信号能量就完成传输，检测到就中止传输，等待一个随机时间量重传 选择随机时间量用二进制指数后退算法。该帧经历了一连串的$n$次碰撞，就从${0, 1, 2, \\ldots, 2^n-1}$里选择一个$K$值。 对于以太网，一个节点等待的实际时间量是$512K$比特时间（发送512比特进入以太网所需时间量的$K$倍），$n\\leq 10$。 轮流协议ALOHA和CSMA协议不具备“当有$M$个节点活跃时，每个活跃节点的吞吐量接近$R/M$的特性。 轮询协议：指定一个主节点，以循环的方式轮询每个节点。先给主机1发报文，告诉它能够传输的帧的最多数量。节点1传输了某些帧以后告诉节点2能传输的帧的最多数量…… 令牌传递协议：没有主节点，一个被称为令牌的特殊帧在节点之间以某种固定次序交换。一个节点要是没有帧发送就立刻传令牌给下一个节点，有的话就发送最大数目的帧数然后传给下一个节点。 交换局域网MAC地址主机或路由器的适配器（网络接口）具有链路层地址，但是链路层交换机并不具备和接口关联的链路层地址。这是因为交换机透明地执行在主机和路由器之间承载数据报的任务。 MAC地址长度6字节，有$2^{48}$种可能的mac地址。它被设计成永久的，但可能通过软件修改它。 一个生产适配器的公司购买前24个比特固定下来，自己生成后面的24个比特。 mac地址具有扁平结构（而不是ip地址那样的层次结构） 适配器接收到一个帧时检查帧的目的地址是否和自己的mac地址匹配，匹配就提取出封装的数据报并将它沿协议栈向上传递，不匹配就丢弃。当然也有mac广播地址FF-FF-FF-FF-FF-FF。 地址解析协议在网络层地址（ip地址）和链路层地址（mac地址），这是地址解析协议。 用ARP将一个ip地址解析为一个mac地址。跟dns挺像，不过arp只为在同一个子网上的主机和路由器接口解析ip地址。 arp表有ip地址，mac地址，ttl（寿命，常为20min），但是这张表不必为该子网上所有主机和路由器都包含一个表项。 要是arp表里有目的ip地址的条目好说，没有的话就使用arp协议来解析这个地址。发送方构搞一个arp分组，指示适配器用mac广播地址来发送这个分组。arp即插即用，是跨越链路层和网络层边界两边的协议。 发送数据报到子网以外 如图，从左上到右下，先发给111.111.111.110（用arp得到mac地址，创建一个帧，发到子网中。路由器看到这个链路层帧向它寻址就把这个帧传给路由器），然后路由器查询转发表， 知道了要在右边的接口发送……就发成了 以太网以太网是目前最流行的有限局域网技术。 以太网帧结构： 数据字段承载ip数据报，长度在46-1500之间，多了分片少了填充。 类型字段允许以太网复用多种网络层协议。 crc用来循环冗余检测 前同步码：前七个字节为10101010，最后一个字节是10101011，目的是唤醒接收适配器并将它们时钟和发送方时钟同步。 所有以太网技术都向网络层提供无连接服务，提供不可靠服务。 链路层交换机交换机转发和过滤：过滤是决定一个帧应该转发到某个接口还是要丢弃，转发是决定一个帧应该被导向哪个接口，并把帧移过去。它们借助于交换机表完成。交换机表有内容，接口，时间。 假设有一个目的地址为DD-DD-DD-DD-DD-DD的帧从交换机接口$x$到达，如果 表中没有对于它的表项，就向接口$x$以外的所有接口前面的输出缓存转发该帧副本 表中有一个表项联系它和接口$x$，丢弃 表中有一个表项联系它和接口$y \\not = x$，该帧放到接口$y$前的输出缓存 自学习：tql 交换机表初始为空 对于每个接口接收到的每个帧，在表中存储源地址字段中的mac地址，到达接口号，当前时间 一段时间（老化期）以后，没有接收到以该地址作为源地址的帧，就在表中删除这个地址 所以交换机也是即插即用的。它还是全双工的。 性质： 消除碰撞。没有因为碰撞而浪费的带宽 异质的链路。交换机将链路彼此隔离，局域网中的不同链路能以不同的速率甚至是在不同的媒体上运行 好管理 比较： 交换机即插即用，有相对高的分组过滤和转发速率；交换网络的活跃拓扑限制为一棵生成树，要求在主机和路由器中有大的arp表，对广播风暴不提供任何保护措施。 路由器没有生成树限制，可以以丰富的拓扑结构构建因特网。对第二层的广播风暴提供防火墙保护；不是即插即用的，催每个分组的处理时间比交换机更长。 集线器 路由器 交换机 流量隔离 Y Y 即插即用 Y Y 优化路由 Y 虚拟局域网支持虚拟局域网VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网。 接口由网管划分成组，每个组构成一个vlan，每个vlan中的端口构成一个广播域（来自一个端口的广播流量仅能到达该组中其他端口） 至于vlan之间的通信，看书吧。 链路虚拟化：网络作为链路层多协议标签交换多协议标签交换MPLS云里雾里，跳了 数据中心网络数据中心的主机称为刀片，每个机架堆放20-40台刀片，每个机架顶部有一台“机架顶部交换机”，它们和机架上主机互联，和数据中心其他交换机互联。 负载均衡外部请求首先被定向到一个负载均衡器，它平衡主机间的工作负载，还提供类似nat的功能。 等级体系结构 图为示意。 发展趋势全连接拓扑和模块化数据中心。 回顾：Web页面请求的历程掏出你的电脑，连到以太网交换机，开始冲浪（x 超绝详细的部分看书 准备：DHCP、UDP、IP和以太网先用udp和dhcp让你的电脑知道ip地址，在ip转发表中安装默认网关。 仍在准备：DNS和ARP在浏览器敲入www.bilibili.com的时候，浏览器生成tcp套接字，向bilibili发送http请求——在这之前要知道bilibili的dns。 电脑生成一个dns查询报文丢进udp报文段向dns服务器丢过去——在这之前你需要用arp知道网关路由器的mac地址。用arp一通操作成了。 仍在准备：域内路由选择到dns服务器网关路由器接收到包含dns查询的报文，查找目的地址（比如dns服务商comcast），发到comcast网络的边缘路由器，根据转发表确定出接口发过去（转发表已经被rip、ospf、is-is、BGP这一套东西填好了） 经过一番dns查找，确定了google服务器的ip地址，返回，准备连接 Web客户——服务器交互：TCP和HTTP生成tcp套接字，建立连接，发送http get报文，获得http响应报文……一通操作，你看到了2233。"},{"title":"《计算机网络：自顶向下方法》笔记5 网络层：控制平面","date":"2020-05-01T10:00:04.000Z","url":"/2020/05/01/cs_notes/topdown_chapter5/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第五章 路由选择算法分类方式多样，可以集中/分散，可以动态/静态，可以负载敏感/负载迟钝。 链路状态路由选择算法链路状态广播使得每个节点都具有网络的统一完整的视图，每个节点都可以运行LS算法并计算出相同的最低开销路径集合。 其实就是个dijkstra。 如果链路开销等于链路上承载的负载这类的东西，就有可能出现振荡。 距离向量路由选择算法距离向量DV算法是一种迭代的、异步的、分布式的算法。这个又和bellman-fiord方程相关。 每个点维护自己的距离向量：到所有节点的最低开销路径的开销（估计值），然后时不时给邻居发送方向向量副本。任何节点$x$从邻居$v$收到方向向量的时候更新自己的方向向量：$D_x(y)=\\min_v{c(x,v)+D_v(y)}$。要是$x$的距离向量因为这个更新步骤改变，就向另据发送更新以后的距离向量。 其实$x$真正想知道的是沿着最短路径到$y$的下一跳路由器邻居节点$v^*(y)$。 路径开销降低好说，但是增大就…… 原来的话$D_y(x)=4$，$D_y(z)=1$，$D_z(x)=5$，$D_z(y)=1$。更新以后$D_y(x)=\\min{c(y,x)+D_x(x), c(y,z)+D_z(y)}=6$，距离向量发生变化，通知$z$。然后$D_z(x)$更新，……居然需要44轮迭代。这有时被称为无穷计数问题。 毒性逆转如果$z$通过$y$路由选择到目的地$x$，那么$z$通告$y$ $D_z(x)=\\infty$，这就让$y$不可能通过$z$到达$x$（这就成回路了）。但是它没有解决一般的无穷计数问题。涉及三个或更多节点的环路没法检测到。 优劣ls算法是求$O(NE)$个报文的$O(N^2)$算法。dv报文少，收敛慢，会遇到选择环路。LS的路由计算某种程度上是分离的，一定的健壮性。DV却可能向任意节点通告不正确的最低开销路径。 因特网中自治系统内部的路由选择：OSPF开放最短路优先OSPF，路由器向自治系统内所有其他路由器广播路由选择信息。每台路由器确定一个以自身为根节点到所有子网的最短路径树。链路开销由管理员配置。 当一条链路的状态发生变化或者是每个一段时间，路由器就会广播链路状态信息。 它安全，允许使用多条相同开销的路径，综合支持单播多播路由选择，支持在单个AS内的层次结构。 一个ospf自治系统能配置多个区域，AS中只能有一个ospf区域配置成主干区域，包含本AS所有区域边界路由器和一些非边界路由器。主干区域为AS中其他区域之间的流量提供路由选择。AS中区域间路由选择要求分组先路由到一个区域边界路由器（区域内路由选择）然后通过主干路由到位于目的区域的区域边界路由器，然后路由到最终目的地。 ISP之间的路由选择：BGP所有AS都运行相同的AS间路由选择协议：边界网关协议BGP。 BGP是路由到CIDR化的前缀，例如138.16.6.8/22。 他使得AS可从邻居AS获得前缀的可达性信息，确定到该前缀的“最好的”路由。 通告bgp路由信息对于每个as，路由器要么是网关路由器，要么是内部路由器。网关路由器直连其他as中一台或多台路由器。 跨越两个as的bgp连接称为外部bgp连接（eBGP），自然也有内部iBGP。 确定最好的路由bgp前缀和属性称为路由。比较重要的属性是AS-PATH和NEXT-HOP。 当一个前缀通过某AS时，该ASN加入AS-PATH的现有列表。 例如在AS1，AS2，AS3构成的环路中从AS1到子网x（在AS3内）可以有两条路，AS-PATH分别为AS2 AS3，AS3。 如果一台路由器在路径列表里看到了包含它自己的AS，它将拒绝通告，这样避免了环路。 NEXT-HOP是AS-PATH起始的路由器接口的ip地址。 NEXT-HOP属性是不属于AS1的某路由器的ip地址，但是包含该ip地址的子网直接连接到AS1。 路由选择算法热土豆（烫手山芋2333）路由选择：对于一个路由器来说，它选择的路由到开始该路由的NEXT-HOP路由器要有最小开销。哪个开销小选那个。 真正的路由选择： 路由被指派一个本地偏好值作为属性之一。最高的将被选择 余下路由（如果没选好的话）选AS-PATH最短的。如果该路由是路由选择的唯一规则，那么bgp用dv算法决定路径。距离测度用的是AS跳数而不是路由器跳数。 余下路由（没选好，这时候最高本地偏好值和AS-PATH长度均相同），热土豆 还有就用bgp标识符选择 IP任播一个例子：CDN公司给多台服务器指派相同的ip地址，并且使用标准的bgp从每台服务器通告该ip地址。配置路由选择表的时候每台路由器将本地化地使用bgp路由选择算法来挑选到该ip地址最好的路由。 路由选择测略路由选择算法先根据本地偏好属性选择路由，本地偏好值由本地AS策略决定。 如果一个AS，自身是进入/离开它的所有流量的源/目的地，它就是桩网络。它可以向邻居通告它没有通向任何其他目的地的路径。 SDN控制平面这东西太难懂了，不看了。 ICMP：因特网控制报文协议icmp被主机和路由器用来彼此沟通网络层的信息，例如差错报告。 icmp报文作为ip有效载荷。 traceroute用icmp数据报实现。每个数据报携带一个具有不可达udp端口号的udp报文段，第一个数据报ttl为1，第二个为2,……第$n$个数据报到达第$n$个路由器的时候刚好过期，返回一个icmp告警报文，包含路由器名字和ip地址。源主机从定时器得到往返时延，从icmp报文得到第n台路由器的名字和ip地址。停止的时候收到的是端口不可达的icmp报文，知道不需要再发送另外的探测分组。 网络管理和SNMP网络管理的关键组件是管理服务器，被管设备，管理信息库（MIB），网络管理代理（被管设备中的进程）和网络管理协议。 简单网络管理协议SNMP是个应用层协议。常用的是请求响应模式：SNMP管理服务器向snmp代理发送请求，代理收到请求执行动作发送回答。还有陷阱报文，用于通知管理服务器异常情况导致mib对象值改变。 snmp定义了7种类型的报文，一般称为协议数据单元PDU。通常作为udp数据报载荷运输。"},{"title":"《计算机网络：自顶向下方法》笔记4 网络层：数据平面","date":"2020-05-01T10:00:03.000Z","url":"/2020/05/01/cs_notes/topdown_chapter4/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第四章 网络层概述两种功能 转发。当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。这个是数据平面的唯一功能。当然也可能被现有的路由器阻挡或者可能是冗余的并经过多条出链路发送。 路由选择。当分组从发送方流向接收方时，网络层决定这些分组采用的路由or路径。这是在控制平面中实现。 转发这个路由器本地动作时间尺度很短，常用硬件实现。路由选择是确定分组从源到目的地的端到端路径的网络范围处理过程，时间尺度长（几秒），软件实现。转发就是走一个立交桥，路由选择就是规划路径。 控制平面的方法传统方法： 路由选择算法决定了插入该路由转发表的内容。路由选择算法运行在每台路由器上。 SDN（软件定义网络）方法： 这是路由选择厂商的传统方法。远程控制器计算和分发转发表供使用。 网络服务模型因特网的网络层只提供尽力而为服务…… 路由器工作原理路由器结构 如图。在输入端口还要执行查找功能，决定输出端口。 输入端口、输出端口、交换结构几乎总是用硬件实现。交换可以用内存/总线/互联网络之类的。 输入端口 输入端口，线路端接（物理层）、数据链路处理（链路层）、查找转发排队。 转发表转发表通常用最长前缀匹配规则。 输出端口 排队输入排队：交换结构不能快得让所有到达分组无时延地通过它传送。有时候一个分组的输出端口没有竞争，但是统一输入端口前面的分组应为竞争而等待导致它也要等待，这叫线路前部HOL阻塞。 当然也有输出排队。 现在研究出缓存需要的数据量是$\\dfrac{\\mathrm{RTT}\\times C}{\\sqrt N}$。$N$是tcp连接数量。 分组调度先进先出：FCFS（也称FIFO） 优先权排队：分几个优先权类，先执行高优先权的，同权就fifo。 循环和加权公平排队：分组被分类，每个类轮着来，但是不允许链路空闲（保持工作排队）。 网际协议：IPv4、寻址、IPv6及其他ipv4数据报 版本号 首部长度 服务类型 数据报长度（总长度）。理论最大长度65535，但很少超过1500 标识、标志、片偏移（和ip分片有关） 寿命TTL。TTL减为0时数据报必须丢弃。 协议。通常到达目的地才有用，6是tcp，17是udp。 首部检验和。只对首部计算检验和。每台路由器都要重新计算并写入检验和。 源和目的ip地址 选项（如果有） 数据（有效载荷） 一个ip数据报首部20字节（如果没有选项），加上20字节tcp首部，则每个（没有分片的）数据报共有40字节首部。 数据报分片由于最大传输单元MTU，数据报可能会被分片。但是数据报的重新组装在端系统中。发送方生成一个数据报，就贴上一个标识号，标识号每次+1。具有相同标识的多个分片，最后一个片的标志bit为0，其他的为1。为了让端系统按正确位置组装，偏移字段指定该片该房在初始ip数据报的哪个位置。 ipv4编址主机和物理链路之间的边界叫接口。一个ip地址和一个接口相关联。 如图，左边三个主机接口和一个路由器接口的网络形成一个子网，为223.1.1.0/24，24是子网掩码。就是最左边24bit定义了子网地址。 因特网的地址分配策略是无类别域间路由选择CIDR。 一个组织通常有一块连续的地址。 剩下的$32-x$比特可以认为是区分内部设备的。 广播地址255.255.255.255，目的地是它时，报文会交付给同一个网络中的所有主机。 路由聚合 单个网络前缀可以通告多个网络，这就是地址聚合/路由聚合/路由摘要。 如果有人想路由选择到200.23.18.0/23里的某个地址，那使用最长前缀匹配，会朝着ISPs-R-Us前进。 动态主机配置协议dhcp是个即插即用/零配置协议。子网中要有一台dhcp服务器（或者dhcp中继代理，通常是一台路由器） dhcp服务器发现。客户广播一条dhcp发现报文，向端口67。 dhcp服务器提供。dhcp服务器广播一个dhcp提供报文。 dhcp请求。客户从一个或多个服务器提供中选一个，并以dhcp请求报文响应那个服务器。 dhcp ack。服务器用dhcp ack报文证实要求的参数。 网络地址转换nat路由器对外界的行为就如同一个具有单一ip地址的单一设备。用一个nat转换表。 IPv6 地址容量扩大了。还引入了任播地址，将数据报交付给一组主机中的任意一个。 首部长度固定40字节。 流量类型类似于ipv4中的服务类型。 下一个首部：数据字段交付给哪个协议（tcp、udp） 跳限制：转发数据报的每台路由器对该字段的内容减一。到0丢弃。 ipv6没有分片/重新组装，没有首部检验和，没有首部了。 一种从ipv4到ipv6的过渡方法是建隧道，不支持ipv6的地方把ipv6数据报套在ipv4里头。 通用转发和SDN匹配加动作转发表在openflow中称为流表，包括首部字段值的集合，计数器集合，动作集合。 可以实现简单转发，负载均衡，充当防火墙等功能，具体看书吧。"},{"title":"《计算机网络：自顶向下方法》笔记2 应用层","date":"2020-05-01T10:00:01.000Z","url":"/2020/05/01/cs_notes/topdown_chapter2/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第二章 应用层协议原理应用程序体系结构有客户-服务器体系结构和P2P体系结构。 进程通信任何给定的一对进程之间的通信会话场景都能将一个进程标识为客户，另一个标识为服务器。发起通信的是客户，在会话开始的时候等待联系的进程是服务器。 socket是同一台主机内应用层与运输层之间的接口，也是应用程序和网络之间的API。 一些对应用程序服务要求的分类可靠数据传输、吞吐量、定时、安全性。 TCPSSL（安全套接字层）不是和TCP、UDP同级的，而是一种对TCP的加强。 Web和HTTP基本信息web页面是由对象组成的。一个html文件，jpg图形，一个视频片段都是对象。并且它们都可以通过一个URL地址寻址。一般是一个HTML基本文件和几个引用对象。 www.someSchool.edu 是主机名hostname，/someDepartment/picture.gif 是路径名path。 http是一个无状态协议，因为http服务器并不保存关于客户的任何信息。 非持续连接和持续连接每个请求/响应对是经过一个单独的tcp连接发送就是非持续连接，每个都经一个单独的tcp连接被称为持续连接。 http默认使用持续连接，但是客户和服务器也能配置成使用非持续连接。 往返时间RTT一个短分组从客户到服务器然后再返回客户所花的时间。 三次握手的前两部分占用了一个RTT，第三部分（确认）发出的请求和响应用去了另一个RTT。 请求报文 第一行叫请求行，包含方法、URL和HTTP版本三个字段。 后面的行叫首部行。 第三行是高速服务器不要使用持续连接。发送完请求的对象就关闭这条连接。 在首部行（和回车换行）以后还有一个实体体entity body。GET方法的时候它为空，POST字段时候才使用这个。例如用户在表单字段中的输入值。 响应报文 状态行：协议版本、状态码、相应状态。 date是服务器产生并发送该相应报文的日期和时间。 last-modified是对象创建或者最后修改的日期和时间（对缓存来说很重要） cookie cookie计数有四个组件： 在http响应报文中一个cookie首部行 在http请求报文中一个cookie首部行 在用户端系统中保留一个cookie文件并由用户的浏览器进行管理 在web站点的一个后端数据库。 书上说的挺清楚的。想一想这个是不是能用来做没有登录情况下的购物网站购物车。 web缓存web缓存器也叫代理服务器。工作过程大概就是浏览器先向web缓存器问问有没有某对象，缓存器有就给它发来，没有就去获得这个对象缓存下来然后发来。 条件GET缓存器发送一个条件GET，首部行有一个： 意义显然。然后要是没有修改，服务器就返回一个： 没有修改过，也不用重新传一遍对象了。 因特网中的电子邮件构成 三部分：用户代理、邮件服务器和简单邮件传输协议（SMTP）。 邮件发送过程：发送方用户代理–发送方邮件服务器–接收方邮件服务器–接收方用户代理。发不成就在发送方的报文队列中保持这个邮件。 SMTP SMTP也要建立TCP连接，使用持续连接。 邮件并不在中间的某个邮件服务器停留。 http主要是一个“拉协议”，smtp是“推协议”。smtp要求每个报文（包括体）采用7bit ASCII编码。smtp还把所有报文对象通通放在一个报文当中。 邮件访问协议主要是POP3和IMAP。 DNS：因特网的目录服务定义域名系统dns是： 一个由分层的dns服务器实现的分布式数据库 一个使得主机能够查询分布式数据库的应用层协议 dns协议运行在udp上，使用53号端口。 过程 主机上运行着dns应用的客户端 浏览器抽出主机名www.someschool.edu，将主机名传给dns应用的客户端 dns客户向dns服务器发送一个包含主机名的请求 dns客户最终收到一个含有主机名对应的ip地址的报文 浏览器接收到ip地址便可以发起一个tcp连接 dns一些重要服务 主机别名。比如说给规范主机名dala.bongba.qwqwqwqwq.bandebeidi.com起个主机别名叫tank.com，多棒多好记。 邮件服务器别名 负载分配。比如繁忙的站点cnn.com冗余地分配在多台服务器上，有不同的ip地址。所以一个ip地址集合对应同一个规范主机名。客户发起dns请求的时候服务器以整个ip地址集合响应，但是在每个回答中循环这些地址次序。而客户总是向排在前面的ip地址发起http请求。 dns服务器 由上到下为根dns服务器，顶级域服务器，权威dns服务器。 当然还有本地dns服务器。 图例是cse.nyu.edu想知道gaia.cs.umass.edu的ip地址的过程。 dns缓存在一个请求链中，某个dns服务器接收一个dns回答时它能将映射缓存在本地服务器中。然后下一次对相同主机名的查询到达该dns服务器时就能提供ip地址了。不过dns服务器将在一段时间丢弃缓存的信息（两天）。 dns资源记录形如： ttl是记录的生存时间。 Type=A，则name是主机名，value是对应的ip地址 Type=NS，则name是个域（foo.com），value是个知道如何获得该域中主机ip地址的权威dns服务器主机名。例如dns.foo.com Type=CNAME，value是别名为name的主机对应的规范主机名 Type=MX，value是别名为name的邮件服务器的规范主机名 如果一台dns服务器是用于某特定主机名的权威dns服务器，则其含有用于该主机名的A记录。 如果不是，则将包含一条NS记录，对应包含主机名的域；还包含一条A记录，提供NS记录中value字段dns服务器的ip地址。 例如一台服务器不是gaia.cs.umass.edu的权威dns服务器，则它含(umass.edu, dns.umass.edu, NS)和(dns.umass.edu, 128.119.40.111, A)之类的。 CDNcdn是内容分发网。 两种服务器安置原则：深入和邀请做客。邀请做客就是在IXP之类的关键位置建造大集群来邀请ISP做客。 这是netcinema雇佣kingcdn的例子。第三步中netcinema的权威dns服务器并不是返回ip地址，而是向ldns返回一个kingcdn域的主机名，例如a1105.kingcdn.com。 套接字编程：生成网络应用udp和tcptcp中server往往是一个欢迎套接字listen，然后accept出一个连接套接字。"},{"title":"《计算机网络：自顶向下方法》笔记1 计算机网络和因特网","date":"2020-05-01T10:00:00.000Z","url":"/2020/05/01/cs_notes/topdown_chapter1/","tags":[["笔记","/tags/%E7%AC%94%E8%AE%B0/"],["计算机网络","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"第一章 什么是因特网分组交换机常见的有路由器和链路层交换机 网络核心存储转发传输在交换机能够开始向输出链路传输一个分组的第一个bit之前必须接收到整个分组。 例如，要进行端-----交换机-----目的地发送一个$L$比特的分组，链路传输速率为$R$比特每秒，那么使用存储转发传输的用时就是$L/R+L/R=2L/R$，但是不使用（而是收到比特就发）的时间是$L/R$。（注意这里的$L$不要类比成长度了）不懂就想想网络流。 电路交换与分组交换电路交换就是必须电话预订，预订了必定有座位的饭店。分组交换就是不必预订，但是不一定有座位的饭店。 传统的电话网络是电路交换。发送信息前在发送方和接收方之间建立一条名副其实的链接。在网络链路上为它预订了恒定的传输速率。分组交换只有尽全力实时交付分组，但不保证。 分组交换中的时延、丢包和吞吐量时延处理时延、排队时延顾名思义。 传输时延：假定分组以先到先服务方式传输，$L$比特表示分组长度，$R$比特每秒表示从A到B的链路传输速率，则传输时延是$L/R$。 传播时延：一个比特被推向链路，从链路起点到B的时间就是传播时延。 传输时延是分组长度和链路传输速率的函数，与两台路由器之间的距离无关。传播时延是一个比特从一个路由器传输到另一个路由器的时间，是距离的函数，与分组长度和链路传输速率无关。 汽车上收费站的耗时是传输时延，在高速公路上跑的时间是传播时延。 协议层次及其服务模型5层因特网协议栈 位于应用层的信息分组叫报文。 位于运输层的信息分组叫报文段。 位于网络层的信息分组叫数据报。 位于链路层的信息分组叫帧。 网络层将数据报的从一台主机移动到另一台主机。在一台源主机中的运输层协议（TCP、UDP）向网络层递交运输层报文段和目的地址。 封装 链路层交换机实现了一二层协议，而路由器实现了一二三层。所以后者能实现IP协议但是前者不能。（尽管前者不能识别IP地址，但是能识别第二层地址如以太网地址） 每一层，一个分组都有首部字段和有效载荷字段。有效载荷字段通常来自上一层的分组。"},{"title":"Java反射胡探","date":"2020-04-25T19:00:14.000Z","url":"/2020/04/25/old_study_notes/javareflect/","tags":[["Java","/tags/Java/"],["面向对象","/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"先康康这个视频。 获取一系列信息domain/Person.java reflect/ReflectDemo.java反射应用：从配置文件里执行任意类的任意方法 reflect/ReflectDemo1.java获得class reflect/ReflectDemo2.java获得field。 reflect/ReflectDemo3.java获得constructor。 工厂类 多线程和单例设计模式 reflect/ReflectDemo4.java获得method。 ClassLoader类加载器。有三个：Bootstrap、PlatformClassLoader（以前叫ExtClassLoader）、AppClassLoader。分别为JVM系统提供的、平台类的、应用程序类的加载器。 null就是Bootstrap。 自定义类加载器先编一个Message.class丢到合适的地方。 动态代理推荐一下java3y的文章，讲得很棒。转载的一个链接。 使用CGLIB可以避免上面使用接口的情况，避免了代理设计模式和接口的强制耦合。 自定义Annotation 自定义Annotation和工厂类结合，取消Message和Factory任何直接耦合。 "},{"title":"go语言中方法的接收者","date":"2020-03-26T20:34:25.000Z","url":"/2020/03/26/language_notes/gomethodvalueorpointer/","tags":[["go","/tags/go/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"玄之又玄 最近在看go语言实战，这书太猛了，看得我整个人都倒过来了。 先看一段能正常运行的代码。没有什么特别的，不说了。 然后是第二段，也能运行 接着是第三段 慢着。前两段是大扒鸭，第三段变成了奥利给。run它会出错 这个涉及到一个叫方法集的玩意。讲一讲它的规则： 比较好理解的是下面这个 也就是说值类型的接收者可以用那个类型的值和指针实现对应的接口，指针类型的接收者只能用那个类型的指针实现对应的接口。 这个也比较好理解。假设你是go run工具人，要搞一个值类型的接收者，那么传进来值直接用，传进来指针的话*操作也能用。 但是获取一个值的指针并不是总能成功的。比如要搞一个指针类型的接收者，那么传进来指针直接用，传进来值呢？有时候编译器并不能自动获取一个值的地址。再想一个例子，传个24进去，难不成编译器还能晓得24的地址咯……"},{"title":"一个C++小问题","date":"2020-03-24T22:04:14.000Z","url":"/2020/03/24/language_notes/alittlecppproblem/","tags":[["C++","/tags/C/"]],"categories":[["编程语言","/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"content":"关于C++中的模板 C++用template的类不能拆成多文件 "},{"title":"Linux命令行与shell脚本编程大全 一些奇妙的写法","date":"2020-03-12T16:58:44.000Z","url":"/2020/03/12/old_study_notes/linuxshell/","tags":[["shell","/tags/shell/"],["Linux","/tags/Linux/"]],"categories":[["Linux","/categories/Linux/"]],"content":"牙疼不是病，疼起来真要命。 处理命令行参数可以使用getopt，太菜了，不说了。 读入 重定向2&gt;是重定向stderr，1&gt;是重定向stdout。&amp;&gt;是重定向stderr和stdout，但是err会有更高的优先级，也就是出现在更前面。 有意地输出错误信息，例如&gt;&amp;2 上面是临时重定向，下面是永久重定向。 把本来发给stderr的通通重定向到test。顺带一提创建文件描述符也是这个语法。 这个体现了保存、恢复文件描述符的过程。关闭就用 exec 3&gt;&amp;-。 sed、gawk与正则^$分别是锁定在行首和锁定在行尾的锚字符。它们也可以组合起来用（他俩连用过滤掉空白行）。 方括号里加个脱字符表示一个除了c和h之外的任意字符。但是要有一个字符（空格），不然就不行（例如at在行首）。 区间：[a-ch-m]是a到c，以及h到m的并。 &amp;表示匹配的模式。 字符后面放星号表示该字符出现0到任意多次。放星号甚至可以用在点、区间后头。 你看，多么奇妙。 下面是扩展正则表达式了。sed不支持，gawk支持。 后头放问号是出现0、1次，加号是至少出现一次。 后头加{3}这种的花括号是刚好出现3次，{3,6}是出现3到6次。注意gawk使用这个的时候应该加上 --re-interval。 管道符号|表示或。它和正则表达式之间不能有空格不然就被认为是正则的一部分了。 可以拿圆括号分组。(urtay)?表示urtay出现0或1次。 匹配美国电话号和电子邮件： 给数字加逗号 波浪线将正则表达式限定在特定数据字段： "},{"title":"tastyPOST 开发笔记 1 —— 基本构想","date":"2020-02-18T16:54:28.000Z","url":"/2020/02/18/projects/tastyPOST-1/","tags":[["开发笔记","/tags/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"],["tastyPOST","/tags/tastyPOST/"]],"categories":[["开发笔记","/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"]],"content":"开发目的这是一个上传图片并且分类（哪个食堂）和打 tag（什么菜）的美食相册。同时，它还提供帮你随机选菜的功能。 开发技术这个是我做着玩的练手项目233333，可能要用到： 前端：HTML, JS, vue, restful后端：go 瞎糊了一个动态网页，不玩了"},{"title":"malloclab","date":"2020-02-12T18:31:09.000Z","url":"/2020/02/12/unique_studio/malloclab/","categories":[[" ",""]],"content":"首先从 csapp 599 页开始照着抄，用的是隐式空闲链表。 发现没有 realloc，那只能自己捏造一个了…… 这样你的 perf 能获得 66 分的好成绩，感天动地。 书抄完了，开始抄网上的代码吧。 这个看一看，那个看一看，懒得写平衡树，那就随便糊一个显式空闲列表+分离适配吧（603页，605页）。 在我的代码中，块的格式是： fill(*)是填充的，有可能没有。 然后抄一遍代码，自己糊一个有讨论的 realloc 就可以拿到 89 分的好成绩了。我怀疑这是因为俺的 Intel© Core™ i5-8250U CPU @ 1.60GHz × 4不太行，所以也不改了（ "},{"title":"shelllab","date":"2020-02-09T11:43:16.000Z","url":"/2020/02/09/unique_studio/shelllab/","tags":[["多进程","/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"],["信号","/tags/%E4%BF%A1%E5%8F%B7/"]],"categories":[["OS","/categories/OS/"]],"content":"首先定义volatile sig_atomic_t fg_stop_or_exit; 然后照着抄（不是），这个讲得好，程序也跑得好。建议先自己阅读他的代码，然后自己写。 这些是你要实现的函数 "},{"title":"CSP2019-12游记","date":"2019-12-24T19:10:25.000Z","url":"/2019/12/24/algorithm_contest/csp201912/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["游记","/categories/%E6%B8%B8%E8%AE%B0/"]],"content":"没想到上了带学也要打CSP（ 不过这个CSP是“专业组”的，就是比“非专业组”还蔡的那种。 考试时间是12月15日。然而我悲剧地发现华科考点满了……满了……不得已报了武大考点。 考试那天上午，我和margatroid和ks在东一食堂会合。学子烤坊大胜利（不 然后我们坐地铁去武大。在街道口下了地铁，意外地发现计算机大楼不在信息学部……本世纪最大迷惑（不。然后我们在本群唯一去过武大的mgt带路下成功摸到了学大汉武立国的牌楼下，接着走向计算机大楼。 感想是，武大的游客太多了……甚至还有兜售武大地图、武大纪念品的。华科就很好，根本不会有人来参观（。感慨是武大的绿化不是很好，跟一中一样。这样一看华科的树真的好多呀23333（醒一醒，海军工程大学绿化74%，比你科还多2%。因为秋日之萧瑟，感觉也没有武大官网上的那么好康了。 走入考场，准备考试。因为这个考试不像NOIP、NOI那样决定命运一般，所以大家也都轻轻松松的，不很紧张。（到大三下能考八九次呢，给CCF送钱无数……领到题，开干。 前两题水题切了，感觉没啥坑点，不像什么小中大之类的玩意，不管了。第三题，判断化学方程式配平未……好嘛，传统艺能大模拟。看第四题，题面也好长。想来想去，好像没啥算法，也是大模拟……看第五题，数字一个一个都长得一批，一股子数论味。我是不会的，所以也是模拟。这样一看，本次CSP是模拟考试……白给了。 根据以往惯例，我跳过第三题直接日第四题。我想了一下，拿一个set维护一下就差不多了吧。于是我写啊写，写完就调，仍然boom。此时已经过去两个半小时。我觉得我不应当再耗时间了，我立刻回去看第三题。 考虑到时间因素，我果断放弃AC，只追求部分分。部分分很好写的，一个小时少一点就写完了60分的。 这时我面临这两个选择：改T4/开T5。因为T5我还没动，所以我开了T5。这么大的数不太会研究，找规律也没找出来什么规律……果断放弃，开始调第四题。期间修改了多次排序依据，总代码行数一度突破210行（连同调试）。终于，我通过了样例一。我兴高采烈地测试样例二，然后booooooooom。但是没有办法了。时间只有十几分钟了，我必须提交本题然后进行T5。 提交完，打开T5，留给我的时间只剩10分9秒左右。我必须立刻写下暴力算法。面对这样大的模数，我的脑子立刻跳出龟速乘。我写了最朴素的一个暴力。然而此时仍然错误！我想：无所谓，暴力没多少分。脑子虽然这么想，但我还是在查bug。突然我查出来了！我立刻修改了程序，得到了正确的结果。我马上交了上去。我提交了五个题的程序，此时离考试结束余一分钟。 考试没有那么重要，所以考完心情也没多沉重。我和mgt和ks去恰饭！银泰创意城，选了又选，选了橘味餐厅。是一个江浙菜餐厅。鸡汤好喝。后来我又想吃冰激凌了，去买了一杯独角兽冰沙，好冰……喝得我头疼。 CSP出分快。第二天我便查到了分。100+100+60+60+25=345，十分意外。这相当于我前三题没有翻车，第四题骗到了60分，第五题10分钟糊的暴力拿了暴力分。分虽然不高，但是本次全国排名有0.35%左右好像，也不算特别差吧。这个分倒是给我以后考CSP减轻了心理负担qwq。总的来说考试体验还不错ovo"},{"title":"联创OS任务——多线程和锁","date":"2019-12-19T14:52:25.000Z","url":"/2019/12/19/unique_studio/suodxc/","tags":[["多线程","/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"],["锁","/tags/%E9%94%81/"]],"categories":[["OS","/categories/OS/"]],"content":"扔完代码就跑 socket通信 文件锁 多线程与锁 "},{"title":"联创OS任务——多进程与信号量","date":"2019-12-17T20:00:49.000Z","url":"/2019/12/17/unique_studio/dxc/","tags":[["多进程","/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"]],"categories":[["OS","/categories/OS/"]],"content":"重点是共用内存还有信号量 参考1和2。 "},{"title":"CSP201909-05 城市规划","date":"2019-12-03T11:36:58.000Z","url":"/2019/12/03/algorithm_contest/csp201909-05/","tags":[["树形dp","/tags/%E6%A0%91%E5%BD%A2dp/"]],"categories":[["算法竞赛","/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"]],"content":"考虑在一个结点对他的儿子依次扫描的过程。 要在这个结点的子树选出 $d$ 个结点，我们可以在已经扫描过的子树（连同当前结点）中选 $p$ 个，在当前处理的子树中选 $q$ 个。且 $p+q=d$。 考虑它的代价。显然是选 $p$ 个的和选 $q$ 个的和“要走的这条边（edge[i].val）乘以要被通过的次数”这三部分加起来。这条边要被计算多少次？是$q(k-q)$次。也即内外相乘。理解了这一点，这个题就很简单了。 "},{"title":"联创计网笔记2——总体架构","date":"2019-11-26T11:00:27.000Z","url":"/2019/11/26/unique_studio/network-2/","tags":[["网络","/tags/%E7%BD%91%E7%BB%9C/"],["联创","/tags/%E8%81%94%E5%88%9B/"]],"categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"记得做好数据持久化，比如/etc/quagga/daemon里ospfd=yes hust部分HUST-LYJ IP 202.114.12.2/24HUST-USER1 IP 202.114.12.3/24HUST-USER2 IP 自动分布HUST-ROUTER-USER 对学生 202.114.12.4/24HUST-ROUTER-USER 对border 202.114.9.254/24HUST-ROUTER 对学生 202.114.12.6/24HUST-ROUTER 对服务 202.114.10.3/24HUST-ROUTER 对border 202.114.9.3/24HUST-HUB IP 202.114.10.2/24在HUST-ROUTER HUST-ROUTER-USER 上开ospf。注意HUST-ROUTER-USER的ospf只有user的！没有border。注意手动删掉HUST-ROUTER-USER里ip route的202.114.12.0/24 src为 202.114.12.254那个，不然全白给。HUST-ROUTER-USER-WIRELESS 对外ip 202.114.12.7/24HUST-ROUTER-USER-WIRELESS 对内ip 10.1.1.2/24 把hust-lyj那几个的ip route 的default统统搞到他对接的那个端口去（ip route replace default via 202.114.12.4之类的） HUST-ROUTER-USER-WIRELESS 安装好iptables和dhcp直接自己搞一个镜像commit一下。 （小型测试网络：A-B-C，添加网关为B上相应的端口 route add default gw xx.xx.xx.xx/yy能ping通服务器上另几个端口（user2 ping wireless其他端口可），然后路由转发都打开，就双向ping通了。 iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE，eth0是外网端口，ip出去的全伪装成外网端口出去的了。要开nat后头dhcp分配完10.几的ip以后才能ping出去dnsmasq搞了dhcpHUST-ROUTER-USER-WIRELESS里头/etc/dnsmasq.conf 然后dnsmasq网上复制一份/usr/share/udhcpc/default.script于HUST-USER2，然后udhcpc就自动获得了ip（别忘了增加执行权限 WHU部分WHU-ROUTER 对border 202.114.64.254/24WHU-ROUTER 对内 202.114.65.2/24WHU-USER1 192.168.30.3/24WHU-USER2 192.168.30.4/24WHU-STUDENT-NAT 对内 192.168.30.2/24WHU-STUDENT-NAT 对外 202.114.65.3/24WHU-DB 202.114.t65.4/24WHU-WWW 202.114.65.5/24WHU-BAKCUP 202.114.65.6/24WHU-BAKCUP的ftp用户为www，密码123456 GOOGLE部分GOOGLE-ROUTER 对外ip 8.8.7.3/24GOOGLE-ROUTER 对内 8.8.8.3/24GOOGLE-DNS 8.8.8.8/24GOOGLE-VPNSERVER 对外8.8.8.9/24 NAIVEKUN对外210.173.0.2/24 运营商CHN-MOBILE-BGP-10087 对 HUST-BORDER 202.114.9.5/24CHN-UNICOM-BGP-10010 对 GOOGLE-BORDER 8.8.7.2/24CHN-MOBILE-BGP-10086 对 WHU-BORDER 202.114.64.4/24NAIVEKUN-TELECOM-BGP-23333 对 NAIVEKUN-BORDER 210.173.0.4/24 CHN-MOBILE-BGP-10087 对 CHN-UNICOM-BGP-10010 10.233.251.2/30CHN-UNICOM-BGP-10010 对 CHN-MOBILE-BGP-10087 10.233.251.1/30CHN-UNICOM-BGP-10010 对 NAIVEKUN-TELECOM-BGP-23333 10.233.253.1/30NAIVEKUN-TELECOM-BGP-23333 对 CHN-UNICOM-BGP-10010 10.233.253.2/30CHN-UNICOM-BGP-10010 对 CHN-MOBILE-BGP-10086 10.233.252.1/30CHN-MOBILE-BGP-10086 对 CHN-UNICOM-BGP-10010 10.233.252.2/30CHN-MOBILE-BGP-10086 对 NAIVEKUN-TELECOM-BGP-23333 10.233.254.2/30NAIVEKUN-TELECOM-BGP-23333 对 CHN-MOBILE-BGP-10086 10.233.254.1/30//01001111 BGP配置参考 注意，单纯的neighbor只是一跳，要想天2xx.x.x.2/301010.0101.1010.00000010"},{"title":"联创计网笔记1——OSPF","date":"2019-11-23T14:34:04.000Z","url":"/2019/11/23/unique_studio/networks-1/","tags":[["网络","/tags/%E7%BD%91%E7%BB%9C/"],["联创","/tags/%E8%81%94%E5%88%9B/"]],"categories":[["网络","/categories/%E7%BD%91%E7%BB%9C/"]],"content":"docker实现OSPF测试通信（以下内容复制自网络并根据实际情况修改） docker-compose.yml 执行docker-compose up -d于存放该yaml的文件夹。 我们的设备位于这条专用链路的两端。下面提供了IP地址的信息信息。 Site-A：192.168.1.0/24 Site-B：172.16.1.0/24 两个Linux设备之间的对等：10.10.10.0/30 Quagga软件包含有几个协同运行的后台程序。我们在本教程中将着重介绍设置下列后台程序。 Zebra：核心后台程序，负责内核接口和静态路由。 Ospfd：IPv4 OSPF后台程序。 第一个阶段：配置Zebra我们首先创建一个Zebra配置文件，然后启动Zebra后台程序。要是已经启动了就不用了。 这里的路径可能不一样，要自己找。 在配置路由前，如果你是用docker启动的，先ip route show看一下，要是有什么default via 什么什么之类的，第一步先删了它！不然你的流量就会通过这个跑到物理机上头然后nat跑出去，简直白给。 启动vtysh命令外壳： 首先，我们为Zebra配置日志文件。为此，输入下列内容，进入vtysh中的全局配置模式： 并指定日志文件位置，然后退出该模式： 永久性保存配置： 下一步，我们在必要时确定可用接口，然后配置IP地址。 这里哪个eth配那个也不一定，要根据互相ping出来的确定是哪一个配置eth0参数： 继续配置eth1参数： 现在验证配置： 永久性保存配置： 针对site-B服务器，也重复IP地址配置这个步骤。 要是一切顺利，你应该能够从site-A服务器来ping检测site-B的对等IP 10.10.10.2。 请注意：一旦Zebra后台程序已启动，用vtysh的命令行接口进行的任何更改会立即生效。不需要在配置变更后重启Zebra后台程序。 第2个阶段：配置OSPF我们先创建一个OSPF配置文件，然后启动OSPF后台程序： 现在启动vtysh外壳，继续进行OSPF配置： 进入路由器配置模式： 手动设置router-id： 添加将参与OSPF的网络： 注意这里的网段，如果不是8/16/24,就要手动考虑一下是不是要更改倒数第二位/第三位之类的了 永久性保存配置： 针对site-B，也重复类似的OSPF配置： OSPF邻居现在应该会出现。只要ospfd在运行，通过vtysh外壳所作的任何与OSPF有关的配置变更都会立即生效，没必要重启ospfd。 在下一个部分，我们将验证已安装的Quagga环境。 验证 用ping来测试 首先，你应该能够从site-A来ping检测site-B的局域网了网。确保你的防火墙没有阻止ping检测流量。 检查路由表 内核和Quagga路由表里面应该都有必要的路由。 3．验证OSPF邻居和路由器 在vtysh外壳里面，你可以检查必要的邻居有没有出现，是否记住合适的路由。 "},{"title":"斐波那契堆（简单版）","date":"2019-11-02T21:28:14.000Z","url":"/2019/11/02/unique_studio/fibheap/","tags":[["斐波那契堆","/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/"]],"categories":[["数据结构","/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"这个只有搞priority_queue的插入和删除，别的没有 "},{"title":"Linux奇妙命令","date":"2019-10-24T13:54:00.000Z","url":"/2019/10/24/old_study_notes/commands/","tags":[["shell","/tags/shell/"],["Linux","/tags/Linux/"]],"categories":[["Linux","/categories/Linux/"]],"content":"世界真是奇妙 findfind: find [-path] expressionfind里头有 -mtime, -mmin之类的，形式上就是 "},{"title":"skip-list","date":"2019-10-18T20:01:03.000Z","url":"/2019/10/18/unique_studio/skip-list/","tags":[["跳表","/tags/%E8%B7%B3%E8%A1%A8/"]],"categories":[[" ",""]],"content":"联创考试的时候让学跳表，学了以下。 跟 $k$ 有关的操作可以查indexed skip list之类的？ 写了好久（摔！ "},{"title":"NOI2018 游记","date":"2018-07-16T14:15:18.000Z","url":"/2018/07/16/oiblogs/noi2018/","tags":[["游记","/tags/%E6%B8%B8%E8%AE%B0/"]],"categories":[["OI","/categories/OI/"],["游记","/categories/OI/%E6%B8%B8%E8%AE%B0/"]],"content":"天下没有不散的筵席。我的 OI 生涯，终于要结束了。 day-2 飞向长沙上午收拾了收拾东西，下载了动画《爱吃拉面的小泉同学》的前五集。 吃过午饭，就准备坐车去运城机场。高铁飞速，转眼间就到了。我没坐过几次飞机，而且比较恐飞，就很难受qwqwq。在飞机场给老韩测试了一下新高一的报名系统（他们似乎是有一个暑期课堂，先上一个月的课，这样就很棒啊qwq）。还围观了一下数学老师（就是数学老师，据称“他对这方面有兴趣”）写 hello world。不得不说 devcpp 对于初学者来说还是很棒的，能把精力放在写程序上面。 登上飞机，阅读了一下安全指南，看了一会儿关于安全的东西（上面说了我恐飞了TAT），吃了点飞机餐（真香），跟陌生人聊了会儿信息学竞赛（他好像跟计算机沾一点边），看了一会儿云，然后就到了黄花机场（真快）。 我们提前到的，所以没有地方住，住酒店。老韩找了一家小吃街附近的。到了一看，好家伙，真的是在小吃街里头。那天晚上，我吃了小排骨、麻辣香锅（有贵又少我又饱了）、臭豆腐，好几瓶饮料…… 然后就是洗漱和聊天。在qwq圣殿裙里头语音了一会儿，膜拜dkw和ks，说了会儿骚话，看了会儿代码直播，然后问候了一下某某，就去睡觉了。 day-1 报到早上起来吃了点东西，出发去雅礼洋湖报到。 雅礼洋湖还是熟悉的样子，只不过更加漂亮了一点？报道处门前彩旗飘飘，十分好看。进去办手续。志愿者给了一根笔，我在签名板上写下了“陈奕骁\\npoorpool”。写完这一笔，这次以后，我也许就再也没有机会参加到这样宏大的信息学盛会，再也没有机会签名了……今年报到没有包QAQ！QAQ！QAQAQ！！！但是有两件衣服qwq。我能一耳朵分辨出长沙人和外地人qwq。 进宿舍。艹啊，雅礼洋湖半年了，宿舍还是没有电？？还是在最里头……反正比我wc时的住宿条件差多了。我社保ccf。去超市买拖鞋，感觉像是碰见了杨澜佬爷？？问了一下似乎是似乎不是，去给签名板上的“杨澜”加了一个“AK NOI orz”，希望她不要看到这篇博客…… 吃饭。 下午去阅览室背笔试颓废。 吃过午饭，前去排练开幕式。这个狗屁主持人就是傻叉。她是瞎了吗看不到所有人都不愿意跟着她傻叉？她以为自己是个什么东西？NOI选手是给yali领导ccf领导拍照炫耀的布景板吗？我们是来切题的还是来一遍一遍地喊口号的？C N B B。 嘛不过还有好几个队的口号有点意思。比如广东的“打是亲，骂是爱，炜隽哥哥好坏坏”，四川的“比赛第二，修涵第一”（不过wxh后来似乎很生气，就换回去了），以及我们山西（临时想的）“华夏古文明，山西好鸽王，咕咕咕咕”，还有粤语的澳门香港队，以及唱歌的香港队…… （汾酒红枣老陈醋，山西太阳ljt qwqwq，ljt佬爷tql） 晚上切了一道unr的贪心，做了一道傻叉题，洗了个澡，就睡觉了。明天还有笔试呐。 day0 笔试第一次参加NOI的考试。 笔试题挺傻叉的，轻松 AK。联系赛是九省联考day1。 然后就去阅览室颓废。 下午是开幕式……谜之口号，谜之灯光，皇家制冷（冰块加风扇）……dzd秘书长妙语连珠，最后“太热了，我不讲了”结束。 嘛我没啥好说的。明天 NOI 第一试，祝我成功！ day1 第一试早晨起来吃吃饭洗洗漱，信心满满地去考试。 我不知道我哪来的谜之自信…… 开始机试！进入系统，狂敲vimrc。看题。第一题是啥啊，题面挺长的，看一看。强制在线？图？lct？想一想部分分。诶海拔一种的好简单，写一下。诶可以暴力啊，写一下。诶这不就是并查集和spfa搞一搞就能过离线了吗。不过在这期间我写了个： GG。我在ubuntu18.04下试验过不会覆盖的啊艹。不过我的代码修修补补，应该重构了，顺便重构一份吧。（顺便说一下，我其实是有备份的） 第二题啥，冒泡排序，发掘性质题？数位dp？瞎jb推性质搞不出来，暴力告辞。 第三题啥，字符串？想一想后缀数组这么简单？写完了，艹，是错解，没救了，暴力。艹暴力写不出来了，零分告辞。 （上面的时间乱序） 出来问了一下山西队，似乎是垫底？艹。 下午出分，沉重的事情来了。 53分。 丢脸！ 出来给我妈打了个电话。本来觉得我的心态很好，但是一打电话就崩了，泪奔回宿舍。在宿舍哭了好一会儿。和教练谈了一会儿去听讲题。讲题没怎么听。但是最后得知ABCD类0.85线是45分，也许我还有救？ 虽然听见几个老哥炸得很惨，但是有更多的人比我厉害。希望爆炸的老哥们和我day2都发挥正常！ day1.5 社会活动没意思。去了韶山，走马观花了一下。饭挺好吃。 山西那一桌教练们互倒苦水qwq。 day2 第二试，决战今天是 NOI 2018 第二试，是我决战的日子。 第一题看看题，傻逼同余方程组合并，秒了。但是并秒不掉，三小时过去了，放弃。 艹赶快打暴力。打暴力打了 45 分，回去改第一题。 下考二十分钟前手工构造数据把自己卡掉了，差点哭在考场。赶快写数据分治。 下午出成绩。那组手工数据救了我的命，$100+53+65+5=223$，铜牌线 $199$，我有牌了！ 晚上去看签约，被浙大赶出来了，上交人太多，去看了人大南大。南大给了面试机会，祝我好运。 哪个都没签，凉凉。搞文化课。 day3 闭幕式上午去阅览室充电打游戏。 后面没什么好说的了，就到此为止吧。 回顾 OI 生涯我从高一下学期开始学 OI。学校也是第一届开展 OI。 NOIP2017 SX rank3，当时确实是非常开心的。 WC2018 惨挂，离铜牌线差 $1$ 分。 SXOI2018 rank2进队。 APIO2018 Cu滚粗。 NOI2018 Cu滚粗。 我学了一年半 OI，取得这样的成绩，不知道是个什么水平。还是比较菜的吧。 致谢感谢父母。 感谢 CCF、学校领导。 感谢山西省临汾一中和其他学校的选手和教练。 特别感谢我的恩师韩晓栋教练。他带领我走进计算机科学世界。 我再也不是 OIer 了。从现在起，我是一名文化课选手了。NOIP2018 回见！"},{"title":"uoj386 【UNR #3】鸽子固定器","date":"2018-07-14T21:22:44.000Z","url":"/2018/07/14/oiblogs/uoj386/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"NOI 攒人品…… 先按大小排序。然后考虑一下枚举左端点和右端点。发现若这里头夹的小于等于 $m$ 个就一定要都选上，大于 $m$ 个就一定是选固定值最大的那 $m$ 个。 算法就出来了，先枚举一下 $nm$ 个区间，然后依次按照固定值删数，每删一次最多搞出 $m$ 个区间。总复杂度 $O(nm)$。 "},{"title":"cf1004e Sonya and Ice Cream","date":"2018-07-14T14:38:54.000Z","url":"/2018/07/14/oiblogs/cf1004e/","tags":[["图论——树论","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%A0%91%E8%AE%BA/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"大力猜结论：这 $k$ 个点一定在树的直径上。 然后就是单调队列爽一发了。 "},{"title":"cf1004d Sonya and Matrix","date":"2018-07-14T10:50:52.000Z","url":"/2018/07/14/oiblogs/cf1004d/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"首先如果有答案的话，那我们一定能旋转到 这样的位置。 那么我们设离左上角的距离 $a=x-1+y-1$，右下角的 $b=n-x+m-y$。 $b$ 就是最大的数字，$x$ 就是不满足 $cnt_i=4i$ 的第一个 $i$（显然）。 然后我们爆枚 $n$，算出 $m$，推出 $y$，然后检查一下就行了。 "},{"title":"poj3415 Common Substrings","date":"2018-07-10T15:40:51.000Z","url":"/2018/07/10/oiblogs/poj3415/","tags":[["字符串——后缀数组","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"计算两个串各取出一个字串作为一组并且这一组的最长公共前缀大于等于 $k$ 这样的组数。 ref "},{"title":"luogu1477 [NOI2008]假面舞会","date":"2018-07-09T16:54:53.000Z","url":"/2018/07/09/oiblogs/luogu1477/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"ref and ref "},{"title":"cf996f Game","date":"2018-07-09T14:44:59.000Z","url":"/2018/07/09/oiblogs/cf996f/","tags":[["数学——概率与期望","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"大力猜结论：所有位于定义域内的数的取值的概率都相等，所以答案就是平均数。 ref "},{"title":"cf996e Leaving the Bar","date":"2018-07-09T11:42:05.000Z","url":"/2018/07/09/oiblogs/cf996e/","tags":[["乱搞","/tags/%E4%B9%B1%E6%90%9E/"]],"categories":[["OI","/categories/OI/"],["乱搞","/categories/OI/%E4%B9%B1%E6%90%9E/"]],"content":"鬼畜随机化 正解是每次把三个向量选两个出来合并，三个向量的最大值是 $r$，那么必定能合出一个 $\\leq r$ 的向量。这个画一个圆就好了。 但是这样很难写。考虑贪心。每次走“使得走完所到的点距离最近”的向量。显然是不对的。那我们随机化就好了（误） "},{"title":"luogu4202 [NOI2008]奥运物流","date":"2018-07-09T09:15:35.000Z","url":"/2018/07/09/oiblogs/luogu4202/","tags":[["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"论文 和 题解 "},{"title":"luogu4201 [NOI2008]设计路线","date":"2018-07-08T16:26:25.000Z","url":"/2018/07/08/oiblogs/luogu4201/","tags":[["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"挺神仙的树形 dp，做这题还要深刻理解树剖。 显然题目中所给的图是一棵树。而且这个修铁路方式就跟树链剖分差不多。问题转化为将树剖成不相交的链，使得到根节点所经过的轻边条数最小。（这里的链可以带拐的，不用和树链剖分一样必须直上直下） ref1 and ref2，懒得写了…… "},{"title":"luogu4203 [NOI2008]糖果雨","date":"2018-07-07T19:27:00.000Z","url":"/2018/07/07/oiblogs/luogu4203/","tags":[["数学——计算几何","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"ref and ref 神仙数形结合…… "},{"title":"luogu1912 [NOI2009]诗人小G","date":"2018-07-06T16:07:21.000Z","url":"/2018/07/06/oiblogs/luogu1912/","tags":[["动态规划——决策单调性","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"怎样证明决策单调性？打表、瞪眼（误） ref 这个是详细的题解 "},{"title":"luogu1758 [NOI2009]管道取珠","date":"2018-07-06T10:06:16.000Z","url":"/2018/07/06/oiblogs/luogu1758/","tags":[["动态规划——普通dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%99%AE%E9%80%9Adp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"神仙 dp。ref 显然不能暴力求。考虑一下 $\\sum a_i^2$ 是什么意义。 经过一番瞎搞，我们知道了这是“让两个人各玩一次，得到的序列相同的方案数”。 然后就水水的了。 "},{"title":"luogu1864 [NOI2009]二叉查找树","date":"2018-07-06T08:28:07.000Z","url":"/2018/07/06/oiblogs/luogu1864/","tags":[["动态规划——区间dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4dp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"ref 不是太懂 orz。 "},{"title":"luogu2048 [NOI2010]超级钢琴","date":"2018-07-05T16:05:36.000Z","url":"/2018/07/05/oiblogs/luogu2048/","tags":[["数据结构——RMQ","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94RMQ/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"要是今年 NOI 也是这种水水的题就好了 qwq。 考虑朴素的暴力，找出所有区间然后爆搞。 考虑优化一点的暴力，我们可以找出最优解，累加最优解，放弃最优解，找下一个不是当前最优解的最优解（解就是区间的数字和）……这样循环地做。最优解的左端点只有 $n$ 个，因此我们对于每个左端点，研究一下以这个点为左端点的合法区间的最优解是几。 记 $o,l,r,t,v$ 为左端点 $o$，合法区间的右端点在 $[l,r]$ 中的情况。这些所有合法区间的最优解是 $v$ 当右端点是 $t$ 的时候。加上这个区间以后，这个区间能扩展出两个不优于它的解 $o,l,t-1,t_l,v_l$ 和 $o,t+1,r,t_r,v_r$。 用堆来找当前一坨解中的最优解，RMQ 最大值，前缀和区间和。 "},{"title":"luogu1954 [NOI2010]航空管制","date":"2018-07-05T10:39:51.000Z","url":"/2018/07/05/oiblogs/luogu1954/","tags":[["图论——拓扑排序","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"拓扑排序。 正着做挺难的，反着来。 第一问很好做，就是普通的拓扑排序。 第二问。想一想，我们反着来，就是构建反图拓扑排序，填充发射序列的时候也是反着来的。那么我们在不使用当前点的情况下拓扑排序，要是实在拓扑不下去了就说明必须是这个点了，这也就是这个点出现的最早位置。 "},{"title":"luogu2046 [NOI2010]海拔","date":"2018-07-05T08:57:15.000Z","url":"/2018/07/05/oiblogs/luogu2046/","tags":[["图论——网络流","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E6%B5%81/"],["图论——最短次短K短路","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E6%AC%A1%E7%9F%ADK%E7%9F%AD%E8%B7%AF/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"平面图转最短路。 大力猜性质： 每个点是 $0$ 或 $1$。 $0$ 连片，$1$ 连片。 发现这两个性质后脑补一下，答案就是最小割。 "},{"title":"luogu2414 [NOI2011]阿狸的打字机","date":"2018-07-04T20:50:12.000Z","url":"/2018/07/04/oiblogs/luogu2414/","tags":[["字符串——AC自动机","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"orz "},{"title":"luogu1971 [NOI2011]兔兔与蛋蛋游戏","date":"2018-07-04T18:09:25.000Z","url":"/2018/07/04/oiblogs/luogu1971/","tags":[["图论——二分图","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E5%9B%BE/"],["数学——博弈论","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%8D%9A%E5%BC%88%E8%AE%BA/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"ref1 and ref2 判定一个点是不是在增广路上的姿势…… "},{"title":"luogu1995 [NOI2011]智能车比赛","date":"2018-07-04T11:34:41.000Z","url":"/2018/07/04/oiblogs/luogu1995/","tags":[["动态规划——普通dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%99%AE%E9%80%9Adp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"水水的 dp，水水的 poorpool。 "},{"title":"luogu1973 [NOI2011]Noi嘉年华","date":"2018-07-04T08:25:45.000Z","url":"/2018/07/04/oiblogs/luogu1973/","tags":[["动态规划——普通dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%99%AE%E9%80%9Adp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"ref1 ref2 我不会告诉你我第一眼看错题了的…… "},{"title":"uoj109 【APIO2013】TASKSAUTHOR","date":"2018-07-03T11:21:46.000Z","url":"/2018/07/03/oiblogs/uoj109/","tags":[["非传统题","/tags/%E9%9D%9E%E4%BC%A0%E7%BB%9F%E9%A2%98/"]],"categories":[["OI","/categories/OI/"],["非传统题","/categories/OI/%E9%9D%9E%E4%BC%A0%E7%BB%9F%E9%A2%98/"]],"content":"ref born1 born2 born4 born5 born6 born7 born8 "},{"title":"luogu2081 [NOI2012]迷失游乐园","date":"2018-07-02T20:44:43.000Z","url":"/2018/07/02/oiblogs/luogu2081/","tags":[["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"],["图论——基环树","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%8E%AF%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"ref 涨姿势…… "},{"title":"luogu2179 [NOI2012]骑行川藏","date":"2018-07-02T16:46:30.000Z","url":"/2018/07/02/oiblogs/luogu2179/","tags":[["数学——微积分","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%BE%AE%E7%A7%AF%E5%88%86/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"参考 rabbithu 的博客。 "},{"title":"luogu1398 [NOI2013]书法家","date":"2018-06-27T18:37:26.000Z","url":"/2018/06/27/oiblogs/luogu1398/","tags":[["动态规划——普通dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%99%AE%E9%80%9Adp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"分成 $11$ 个阶段 dp： 具体的转移看代码。你可能发现，有的转移有“自己到自己”，比如 $11$；有的就没有，比如 $7$。有“自己到自己”的区域，是因为他的宽度可以很宽。 "},{"title":"luogu1232 [NOI2013]树的计数","date":"2018-06-27T15:25:11.000Z","url":"/2018/06/27/oiblogs/luogu1232/","tags":[["图论——树论","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%A0%91%E8%AE%BA/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"ref 好神仙的思维题啊 QAQ "},{"title":"luogu1399 [NOI2013]快餐店","date":"2018-06-27T10:25:45.000Z","url":"/2018/06/27/oiblogs/luogu1399/","tags":[["图论——基环树","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E5%9F%BA%E7%8E%AF%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"ref 搞不懂啊……就学了个基环树找环 "},{"title":"luogu1397 [NOI2013]矩阵游戏","date":"2018-06-26T11:40:40.000Z","url":"/2018/06/26/oiblogs/luogu1397/","tags":[["数学——数论","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E6%95%B0%E8%AE%BA/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"这群人怎么都用的矩阵快速幂呀 QAQ，来讲个数学方法吧。 前置技能：高中数学必修“数列”，扩展欧拉定理降幂。 考虑从 $F_{i,1}$ 推到 $F_{i,m}$。考虑到有人没学过数列我还是推一下吧 qwq。 我们设 $F_{i,j} + k = a(F_{i,j-1}+k)$，易得到 $(a-1)k=b$。我们需要对 $a$ 分类讨论。 当 $a=1$ 时将 $a$ 放到题目给的第二个式子，得到 $F_{i,j}=F_{i,1}+(j-1)b$。 再考虑 $F_{i+1, 1}$ 的转移。 $F_{i+1,1}=cF_{i,m}+d=c(F_{i,1}+(m-1)b)+d=cF_{i,1}+cb(m-1)+d$。 用同样的套路得到 $F_{n+1,1}$ 的式子。我们发现 $c$ 也是要分类讨论的。我们记 $D=cb(m-1)+d$。 $c=1$ 时，$F_{n+1,1}=F_{1,1}+nD$。 否则 $F_{n+1,1}=c^nF_{1,1}+D \\cdot \\dfrac{c^n-1}{c-1}$。 这样我们便可以轻松得到 $F_{n+1,1}$ 了。 当 $a \\neq 1$ 时于是 $k=b/(a-1)$。同样地我们得出 $F_{i,j}=a^{j-1}F_{i,1}+(a^{j-1}-1) \\dfrac{b}{a-1}$。 再考虑 $F_{i+1, 1}$ 的转移。 $F_{i+1,1}=cF_{i,m}+d=c(a^{m-1}F_{i,1}+(a^{m-1}-1) \\dfrac{b}{a-1})+d$。 化简得到 $a^{m-1}cF_{i,1}+c(a^{m-1}-1) \\dfrac{b}{a-1}+d$ 记 $A=a^{m-1}c$，$B=c(a^{m-1}-1) \\dfrac{b}{a-1}+d$，则 $F_{i+1,1}=AF_{i,1}+B$。 我们再讨论一下是否 $A=1$。不过，我们发现这里和上面的式子（$F_{i+1,1}=cF_{i,1}+D$）的形式是一样的（只有常数不同），那么我们不必重复讨论，只要将求解 $F_{n+1,1}$ 写成一个函数调用就可以了。这个函数的讨论就按照上面对 $c$ 的讨论做就行了。 现在我们得到了 $F_{n+1,1}$ ，只需要按照题目中给的第三个式子逆推就行了。于是我们 AC 了这道题。 最后解释一下为什么要用扩展欧拉定理降幂。观察到 $n,m$ 太大了，肯定要取模。当 $n,m$ 作系数的时候是对 $10^9+7$ 取模的，但是我们发现 $n,m$ 还要作指数，作指数应当对 $\\varphi(10^9+7)$ 取模。所以要用扩展欧拉定理降幂，因此我们要记录一下 $n,m$ 对于这两个不同的模数取模后的值。 "},{"title":"luogu1224 [NOI2013]向量内积","date":"2018-06-26T09:20:00.000Z","url":"/2018/06/26/oiblogs/luogu1224/","tags":[["乱搞","/tags/%E4%B9%B1%E6%90%9E/"]],"categories":[["OI","/categories/OI/"],["乱搞","/categories/OI/%E4%B9%B1%E6%90%9E/"]],"content":"ref 什么玩意儿……随机化乱搞神题。 "},{"title":"luogu2305 [NOI2014]购票","date":"2018-06-25T20:51:54.000Z","url":"/2018/06/25/oiblogs/luogu2305/","tags":[["动态规划——斜率优化","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"],["图论——点分治","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"ref "},{"title":"luogu2354 [NOI2014]随机数生成器","date":"2018-06-25T11:12:52.000Z","url":"/2018/06/25/oiblogs/luogu2354/","tags":[["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["贪心","/categories/%E8%B4%AA%E5%BF%83/"]],"content":"只要不看错题就好办……模拟生成矩阵，然后贪心考虑 $1 \\ldots nm$ 是否能填，这个维护一下每一行的能放数的位置就好了。 "},{"title":"luogu2375 [NOI2014]动物园","date":"2018-06-25T09:25:56.000Z","url":"/2018/06/25/oiblogs/luogu2375/","tags":[["字符串——KMP","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94KMP/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"如果不管重叠就显然是在每个位置上不断迭代 next 数组，看迭代几次。 要是管重叠就迭代到不重叠就好了。预先处理一下“对于每个位置 $i$，有多少字符串满足 $1 \\ldots l = i-l+1 \\ldots i$”，这样不断迭代，时间复杂度 $n^2$。 倍增优化迭代到不重叠的过程，时间复杂度 $n \\log n$。可以过 $80$ 分，卡常可以 AC。 考虑记录一个变量，表示当前位置上最大的那个合法的 $l$，那么下一个位置就类似与 KMP 字符串匹配地研究一下 $l$ 的变化，复杂度 $n$，可以 AC。 倍增暴力： "},{"title":"luogu2304 [NOI2015]小园丁与老司机","date":"2018-06-25T08:13:11.000Z","url":"/2018/06/25/oiblogs/luogu2304/","tags":[["图论——网络流","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E6%B5%81/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"ref，神仙题，不会。 还打破了我码长纪录…… "},{"title":"luogu2178 [NOI2015]品酒大会","date":"2018-06-23T08:47:39.000Z","url":"/2018/06/23/oiblogs/luogu2178/","tags":[["字符串——后缀数组","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"ref 挺神仙的…… "},{"title":"luogu2168 [NOI2015]荷马史诗","date":"2018-06-22T21:29:09.000Z","url":"/2018/06/22/oiblogs/luogu2168/","tags":[["字符串——编码","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94%E7%BC%96%E7%A0%81/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"对于我这种没学过哈夫曼树的人极不友好…… ref "},{"title":"luogu2150 [NOI2015]寿司晚宴","date":"2018-06-22T19:38:27.000Z","url":"/2018/06/22/oiblogs/luogu2150/","tags":[["动态规划——状压dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E7%8A%B6%E5%8E%8Bdp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"ref "},{"title":"luogu1721 [NOI2016]国王饮水记","date":"2018-06-22T16:12:11.000Z","url":"/2018/06/22/oiblogs/luogu1721/","tags":[["动态规划——斜率优化","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"鬼畜题……看picks大爷的课件吧。 以下略去高精小数库，要想过编译应当复制高精库并修改高精库精度。 "},{"title":"luogu1712 [NOI2016]区间","date":"2018-06-21T20:11:24.000Z","url":"/2018/06/21/oiblogs/luogu1712/","tags":[["数据结构——线段树","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"先按照长度降序排序，然后一条条加入线段。当发现某个点被覆盖超过 $m$ 次后就开始不断统计答案并由长到短地删掉加了的线段（像是尺取法）直到没有超过 $m$ 次的。正确性显然。 ref "},{"title":"luogu1587 [NOI2016]循环之美","date":"2018-06-21T16:44:51.000Z","url":"/2018/06/21/oiblogs/luogu1587/","tags":[["数学——反演和筛法","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%8F%8D%E6%BC%94%E5%92%8C%E7%AD%9B%E6%B3%95/"]],"categories":[["数学","/categories/%E6%95%B0%E5%AD%A6/"]],"content":"推公式推个爽。 猜想一个既约分数 $i/j$ 是美的当 $(j,k)=1$。 假设竖式除法中余数出现循环的长度是 $l$，那么 $i \\equiv ik^l \\pmod j$。也即 $k^l \\equiv 1 \\pmod j$，那么想一想费马小定理成立的条件就能分析出 $(j,k)=1$。 答案为$$\\begin{aligned}&amp;\\sum_{i=1}^n \\sum_{j=1}^m [(i,j)=1][(j,k)=1] \\= &amp; \\sum_{j=1}^m [(j,k)=1] \\sum_{i=1}^n [(i,j)=1] \\= &amp; \\sum_{j=1}^m [(j,k)=1] \\sum_{i=1}^n \\sum_{d \\mid (i,j)} \\mu(d) \\= &amp; \\sum_d \\mu(d) \\sum_{i=1}^n [d \\mid i] \\sum_{j=1}^m [d \\mid j][(j,k)=1] \\ = &amp; \\sum_d \\mu(d) \\left \\lfloor \\frac{n}{i} \\right \\rfloor \\sum_{jd=1}^m[(jd,k)=1] \\ = &amp; \\sum_d \\mu(d) \\left \\lfloor \\frac{n}{i} \\right \\rfloor \\sum_{j=1}^{\\lfloor m/d \\rfloor}[(jd,k)=1] \\ = &amp; \\sum_d \\mu(d) \\left \\lfloor \\frac{n}{i} \\right \\rfloor \\sum_{j=1}^{\\lfloor m/d \\rfloor}[(j,k)=1][(d,k)=1] \\ = &amp; \\sum_{d=1}^n [(d,k)=1] \\mu(d) \\left \\lfloor \\frac{n}{i} \\right \\rfloor \\sum_{j=1}^{\\lfloor m/d \\rfloor}[(j,k)=1] \\\\end{aligned}$$ 稍作休息，我们想要是能 $O(1)$ 求出后面的 sigma 该有多好啊，这样就能 $O(n)$ 地拿到 $84$ 分了。因为 $(i,j)=(i \\bmod j,j)$。我们定义一个函数 $f(x)$ 表示 $\\sum_{i=1}^x [(i,k)=1]$，依据刚才说的就是 $f(x)=\\lfloor x/k \\rfloor f(k) + f(x \\bmod k)$。这样就拿到了 $84$ 分，就当做是 AC 了。 现在我们要快速求出$$\\begin{aligned}&amp; \\sum_{i=1}^n [(i,k)=1] \\mu(i) \\= &amp; \\sum_{i=1}^n \\mu(i) \\sum_{d \\mid (i,k)} \\mu(d) \\= &amp; \\sum_{d|k} \\mu(d) \\sum_{i=1}^{\\lfloor n/d \\rfloor} \\mu(id) \\= &amp; \\sum_{d|k} \\mu(d) \\sum_{i=1}^{\\lfloor n/d \\rfloor} \\mu(i)\\mu(d)[(i,d)=1] \\= &amp; \\sum_{d|k} \\mu(d)^2 \\sum_{i=1}^{\\lfloor n/d \\rfloor} \\mu(i)[(i,d)=1] \\\\end{aligned}$$ 如果我们记这个式子为 $s(n,k)$，则 $s(n,k)=\\sum_{d \\mid k} \\mu(d)^2 s(\\lfloor n/d \\rfloor,d)$。 然而我们发现 $k=1$ 时进入了循环递归，然而我们发现此时就是让求 $\\mu$ 前缀和，杜教筛。做完了。 "},{"title":"luogu3768 简单的数学题","date":"2018-06-21T15:32:31.000Z","url":"/2018/06/21/oiblogs/luogu3768/","tags":[["数学——反演和筛法","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%8F%8D%E6%BC%94%E5%92%8C%E7%AD%9B%E6%B3%95/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"推公式推个爽。 具体看 yyb 的博客吧 orz，但是也要自己推一遍哦。 "},{"title":"bzoj4916 神犇和蒟蒻","date":"2018-06-21T10:41:50.000Z","url":"/2018/06/21/oiblogs/bzoj4916/","tags":[["数学——反演和筛法","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%8F%8D%E6%BC%94%E5%92%8C%E7%AD%9B%E6%B3%95/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"第一问答案显然是 $1$，考虑一下 $\\mu$ 的计算过程就会发现平方数的 $\\mu$ 是 $0$……。 $\\varphi(i^2)=i \\varphi(i)$ 这个也很显然，考虑一下欧拉函数的计算式就知道是对的了。 然后就是杜教筛。 "},{"title":"luogu1173 [NOI2016]网格","date":"2018-06-20T20:38:30.000Z","url":"/2018/06/20/oiblogs/luogu1173/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"],["图论——割点与桥","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E5%89%B2%E7%82%B9%E4%B8%8E%E6%A1%A5/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"真鬼畜啊这蛐蛐题…… 容易观察到答案就是 $[-1,2]$ 之间。 $-1$：跳蚤数 $&lt;1$ 或两个跳蚤四联通。 $0$：跳蚤不连通。 $1$：把四联通跳蚤连边，存在割点。 $2$：其余情况。 然而跳蚤太多了，想办法忽略一些。我们选择将每个蛐蛐为中心的 $5 \\times 5$ 的方格拉出来连边。 这样图也许不连通，但是跳蚤是联通的。如果跳蚤不连通，那么这些跳蚤必定是围在一团蛐蛐身边的。dfs 蛐蛐团然后判跳蚤是否分属不同的联通块。这样是 $0$ 的判定。 然后存在割点就成了在联通块内是否存在割点。 建议不要看代码自己脑补。 "},{"title":"luogu1117 [NOI2016]优秀的拆分","date":"2018-06-20T14:56:33.000Z","url":"/2018/06/20/oiblogs/luogu1117/","tags":[["字符串——后缀数组","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%94%E2%80%94%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"]],"categories":[["OI","/categories/OI/"],["字符串","/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"content":"我们惊喜地发现傻叉哈希能拿 $95$ 分，那就不要想正解了，这就是 A 了。 关于正解，其实就是加速“一个字符及其左（右）有多少个AA型字符串”的计算，一次算一个改成了一次算好几个。具体看 yyb 的博客。 九十五分暴力： "},{"title":"loj2306 「NOI2017」蔬菜","date":"2018-06-19T11:26:16.000Z","url":"/2018/06/19/oiblogs/loj2306/","tags":[["贪心","/tags/%E8%B4%AA%E5%BF%83/"]],"categories":[["OI","/categories/OI/"],["贪心","/categories/OI/%E8%B4%AA%E5%BF%83/"]],"content":"贪心神题…… 问：在第 $i$ 天之前卖掉的蔬菜输蔡是在第 $i+1$ 天之前卖掉的蔬菜的子集吗？ 答：显然。 正难则反，借用黑框眼镜我们把时间倒转，现在是在某些时刻开始有蔬菜运过来，然后再也不会消失了。 那么我们就把每种的第一个蔬菜和其余蔬菜分开，然后把所有蔬菜按照价值降序排序。按照价值依次往时间点上填蔬菜。 用并查集维护一个时间点及其之前的时间之中，哪个靠后的时间点可以被填蔬菜。 这样我们就得到了 $t=100000$ 时候的答案。然后根据上面的问答，我们按照时间轴往前推就行了。每次删掉最便宜的那些（如果要删的话） "},{"title":"cogs2369 bzoj3456 城市规划","date":"2018-06-16T09:48:08.000Z","url":"/2018/06/16/oiblogs/bzoj3456/","tags":[["数学——FFT、NTT、多项式","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94FFT%E3%80%81NTT%E3%80%81%E5%A4%9A%E9%A1%B9%E5%BC%8F/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"ref "},{"title":"hdu1028 Ignatius and the Princess III","date":"2018-06-15T21:18:35.000Z","url":"/2018/06/15/oiblogs/hdu1028/","tags":[["数学——生成函数","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"生成函数看： rabbithu 推fibonacci通项 "},{"title":"loj2303 「NOI2017」蚯蚓排队","date":"2018-06-15T14:44:31.000Z","url":"/2018/06/15/oiblogs/loj2303/","tags":[["数据结构——哈希表","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"先想出一个暴力，拿链表模拟蚯蚓的 merge 和 split，每次操作把受影响的长度为 $50$ 以内的子串扔进哈希表计数。查询的时候就是直接查哈希表乘起来。复杂度 $mk^2+s$。 预计得分 $44$，实际得分 $100$ 分。 你可能目瞪口呆，居然在 NOI 考场上能见到一道暴力题。事实上能分析出复杂度或者敢写大暴力也是本事……观察到 split 的复杂度最多 $ck^2$，merge 最多也就是 merge 成了一条链，有 $nk$ 个子串，而每个子串只会被处理一次，所以复杂度 $nk+ck^2+s$，这就是传说中的优化暴力然后发现复杂度是对的…… "},{"title":"loj2302 「NOI2017」整数","date":"2018-06-15T09:48:29.000Z","url":"/2018/06/15/oiblogs/loj2302/","tags":[["数据结构——线段树","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"首先 $n\\log^2 n$ 的暴力还是很好想的，二进制分解 $a$ 然后加加减减就行了。退位进位的 $1$ 用线段树找。 然后压个 $30$ 位就好了。 "},{"title":"loj2008 「SCOI2015」小凸想跑步","date":"2018-06-14T19:55:26.000Z","url":"/2018/06/14/oiblogs/loj2008/","tags":[["数学——计算几何","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"列出面积的不等式，化简发现是线性规划那种形式，用半平面交做。 注意限制点在多边形内哦。 loj 这题卡精度……bzoj不卡 "},{"title":"loj2007 「SCOI2015」国旗计划","date":"2018-06-14T11:03:02.000Z","url":"/2018/06/14/oiblogs/loj2007/","tags":[["数据结构——ST表、倍增、RMQ","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94ST%E8%A1%A8%E3%80%81%E5%80%8D%E5%A2%9E%E3%80%81RMQ/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"先拆环成链每个人复制一遍（因为可能有跨越 $m$ 的人）。 然后可以发现，每个人的下一个战士都是固定的。ST 表搞出来优化暴力覆盖就行了。 "},{"title":"luogu4103 [HEOI2014]大工程","date":"2018-06-13T21:26:21.000Z","url":"/2018/06/13/oiblogs/luogu4103/","tags":[["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"],["数据结构——虚树","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%99%9A%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"先建虚树，然后树形 dp 一下就好了。转移看代码吧。 "},{"title":"虚树讲解和 luogu2495 [SDOI2011]消耗战","date":"2018-06-13T19:41:54.000Z","url":"/2018/06/13/oiblogs/luogu2495/","tags":[["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"],["数据结构——虚树","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%99%9A%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"虚树挺劲爆的，得学一学…… 例题 luogu2495 [SDOI2011]消耗战。 如果只有一次询问就是个傻叉树形 dp：记 $dp_i$ 是斩断 $i$ 子树中所有关键点的最小费用（不能直接斩断 $i$ 和他父亲的道路），那么枚举当前结点 $u$ 的儿子 $v$，要是 $v$ 是关键点那 $dp_u$ 就要加上 $minval_v$（从 $u$ 到 $v$ 的道路的权值的最小值），否则就加上 $\\min(minval_v, dp_v)$。 然而如果是多组呢？……观察到 $k$ 的和是十万级别，而且，那些非关键点好像不是太重要，似乎可以压缩一下？或者说，我们能不能找到一种单组复杂度跟 $k$ 有关，而不是 $n$ 有关的算法？ 于是就有了虚树这种东西。 现在，我们只想把关键点和他们的 lca（为了压缩路径）提取出来。可是这 $k$ 个关键点两两组成 lca 会有多少个呢？会不会很多啊？不会的。最多 $k-1$ 个。 而且，这些 lca 就是把关键点按 dfs 序排序后依次计算两个相邻的点的 lca。（证明？大致思想若三个点有三个 lca，那么就会存在一个点有两个父亲两姓家奴） 我们考虑按照 dfs 序依次加入结点和 lca。我们用一个栈表示“在虚树已经构造好的情况下，从根到最后加入的那个结点所构成的链”，栈顶是最后加入的结点，记为 $p$。另外，我们在构建虚树的时候只记录父亲。如果你有加边的需要构建完了再加。 好了。现在我们要加一个新结点 $x$ 了。他和 $p$ 的 lca 必定在那条链上（即使 lca 可能不在栈中）。我们先考虑一下要不要加 lca。对于 $p$ 和栈顶的上一个结点 $q$，如果 $q$ 比 lca 深或者就是 lca，那么 $p$ 的父亲就还是 $q$，并且把 $p$ 弹掉；否则说明 $p,q$ 中间卡了个 lca没加进去，$p$ 的父亲改为 $lca$，并且把 $p$ 弹掉。 然后如果栈顶不是 lca 的话就把 lca 入栈。然后把 $x$ 入栈。这样我们成功地加入了一个新结点，维护了虚树和栈。虚树便构造完毕了。 然后就是在虚树上跑 dp 了。注意清零的技巧哦。 "},{"title":"cf989c A Mist of Florescence","date":"2018-06-13T11:21:26.000Z","url":"/2018/06/13/oiblogs/cf989c/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"请看： (骚话是我自己加的……因为这张图太令人震撼了……十分好写代码……) "},{"title":"bzoj3578 GTY的人类基因组计划2","date":"2018-06-13T09:59:46.000Z","url":"/2018/06/13/oiblogs/bzoj3578/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"题面写的是个什么玩意儿…… 大概就是说，你有 $m$ 个集合，$n$ 个元素。起初所有元素都在 $1$ 号集合。 有两种操作：一种是给元素换集合；一种是查询一个子区间内没有被标记过的集合的元素个数和，查询完毕后把这个子区间的集合都标记。（注意：集合有没有被标记不在于集合的编号，而在于这个集合内的元素） 怎么做呢？给每个元素 rand 一个权值，集合的权值是元素的权值的异或。map 记录（集合权值）一个集合是否被标记过，set 记录（编号）哪些集合对答案有贡献，查询时 lower_bound 就行了。 谜之复杂度QAQ "},{"title":"bzoj3514 Codechef MARCH14 GERALD07加强版","date":"2018-06-13T09:06:39.000Z","url":"/2018/06/13/oiblogs/bzoj3514/","tags":[["数据结构——LCT","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94LCT/"],["数据结构——主席树","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91/"]],"categories":[["OI","/categories/OI/"],["数据结构","/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"content":"ref这题好神啊……主要要有一个思想，强制在线，又是区间，想着用主席树，搞出一个能代表每个边的东西来。我反正想不到&gt;_&lt;。 "},{"title":"loj2192 「SHOI2014」概率充电器","date":"2018-06-13T07:37:37.000Z","url":"/2018/06/13/oiblogs/loj2192/","tags":[["数学——概率与期望","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"],["动态规划——树形dp","/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E6%A0%91%E5%BD%A2dp/"]],"categories":[["OI","/categories/OI/"],["动态规划","/categories/OI/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"]],"content":"就是先算一下每个点在他的子树影响下不连通的概率，然后再考虑父亲的影响。 ref "},{"title":"bzoj3569 DZY Loves Chinese II","date":"2018-06-12T21:14:09.000Z","url":"/2018/06/12/oiblogs/bzoj3569/","tags":[["数学——线性基","/tags/%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E5%9F%BA/"]],"categories":[["OI","/categories/OI/"],["数学","/categories/OI/%E6%95%B0%E5%AD%A6/"]],"content":"经典乱搞做法…… 先搞出一棵生成树，然后非树边赋随机权值，树边为跨越他的非树边的权值异或。 要是不连通就是这 $k$ 个数异或出了 $0$。线性基。 "},{"title":"cf990f Flow Control","date":"2018-06-12T19:22:12.000Z","url":"/2018/06/12/oiblogs/cf990f/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"所有点权和必须为 $0$，这是显然的。 然后就随便硬点一棵生成树出来然后 dfs 就好了。 "},{"title":"cf990d Graph And Its Complement","date":"2018-06-11T21:59:24.000Z","url":"/2018/06/11/oiblogs/cf990d/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"有大于 $1$ 个联通块时，补图显然是一大个联通块。 特判一下 $a=b=1$ 时。此时 $n=1$ 或 $n \\geq 4$ 有解（比如一条链） "},{"title":"cf990c Bracket Sequences Concatenation Problem","date":"2018-06-11T21:14:30.000Z","url":"/2018/06/11/oiblogs/cf990c/","tags":[["思维","/tags/%E6%80%9D%E7%BB%B4/"]],"categories":[["OI","/categories/OI/"],["思维","/categories/OI/%E6%80%9D%E7%BB%B4/"]],"content":"这是一道普及组难度题……然而我脑子瓦特了…… 就是分成四类： 好序列 需要若干左括号的序列 需要若干右括号的序列 凉透了的废材序列 拼一拼就行了 "},{"title":"luogu2597 [ZJOI2012]灾难","date":"2018-06-10T10:52:33.000Z","url":"/2018/06/10/oiblogs/luogu2597/","tags":[["图论——拓扑排序","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"],["图论——LCA","/tags/%E5%9B%BE%E8%AE%BA%E2%80%94%E2%80%94LCA/"]],"categories":[["OI","/categories/OI/"],["图论","/categories/OI/%E5%9B%BE%E8%AE%BA/"]],"content":"先拓扑排序一下，然后按照拓扑序构建“灭绝树”，就是说一个结点，他的所有食物来源在灭绝树中的 lca 就是这个结点在灭绝树中的父亲。 "},{"date":"2022-10-17T07:18:55.916Z","url":"/ad.json","categories":[[" ",""]],"content":"{\"author\":\"poorpool\",\"keywords\":\"blog\",\"description\":\"poorpool's blog\",\"nav_name\":\"poorpool\",\"motto\":\"生年不满百，常怀千岁忧。\",\"github\":\"\",\"favicon\":{\"icon\":\"/images/favicon.ico\",\"touch_icon\":\"/images/touch-icon.png\"},\"rss\":null,\"custom_styles\":null,\"custom_scripts\":null,\"highlight_theme\":\"night eighties\",\"mathjax\":true,\"copyright\":{\"enable\":true,\"author\":\"poorpool\",\"show_link\":true,\"more\":\"版权声明: 本博客所有文章除特别声明外, 均采用 CC BY-NC-SA 4.0 许可协议. 转载请注明出处!\"},\"start_time\":\"2019-11-23\",\"leancloud\":{\"appid\":\"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz\",\"appkey\":\"WaR7nrzhliHj9aVwdQzkdlGd\",\"comment\":false,\"count\":true},\"welcome\":{\"enable\":false,\"interval\":30},\"disqus\":{\"enable\":false,\"id\":null},\"busuanzi\":false,\"passwords\":[\"efe07af7441da2b69c4a41e42e73be4db47f66010a56900788a458354a7373ec\"],\"share\":{\"twitter\":true,\"facebook\":true,\"weibo\":true,\"qq\":true,\"wechat\":true},\"analytics\":{\"360\":{\"enable\":false,\"id\":null},\"baidu\":{\"enable\":false},\"google\":{\"enable\":false,\"id\":null}},\"reward\":null,\"cdn\":{\"leancloud\":\"//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js\",\"mathjax\":\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\",\"valine\":\"//unpkg.com/valine/dist/Valine.min.js\",\"busuanzi\":\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\",\"font_awesome\":\"//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"},\"nav\":[{\"name\":\"首页\",\"path\":\"/\"},{\"name\":\"归档\",\"path\":\"/archives/\"},{\"name\":\"标签\",\"path\":\"/tags/\"},{\"name\":\"分类\",\"path\":\"/categories/\"},{\"name\":\"友链\",\"path\":\"/friends/\"},{\"name\":\"关于\",\"path\":\"/about/\"}],\"footer\":[{\"title\":\"博客推荐\",\"children\":[{\"name\":\"poorpool in cnblogs\",\"path\":\"\"}]}],\"footer_contact\":\"Email: chenyixiao@foxmail.com\",\"friends_avatar_cdn\":null,\"friends\":null}"},{"title":"about","date":"2022-10-17T07:18:55.916Z","url":"/about/index.html","categories":[[" ",""]],"content":"我是 poorpool，原来就读于山西省临汾第一中学校，现在在华中科技大学计算机科学与技术学院读书。 曾经是 OIer，NOI 2018 Cu。 联创团队 Lab 组成员。 联系方式 QQ 489679970。"},{"title":"categories","date":"2022-10-17T07:18:55.916Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"friends","date":"2019-11-23T14:17:00.000Z","url":"/friends/index.html","categories":[[" ",""]]},{"title":"友链","date":"2020-08-05T11:46:08.000Z","url":"/links/index.html","categories":[[" ",""]],"content":"UniqueRapiz margatroid hxj HUSTKSKun jjikkollp"},{"title":"search","date":"2021-08-20T22:33:43.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2022-10-17T07:18:56.300Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"UPDOWNLOADER","date":"2022-02-15T13:43:52.000Z","url":"/updown/index.html","categories":[[" ",""]],"content":"  使用取得内容时，可以在输入框里输入代码，也可以直接在网站链接后面加上代码。 取得文件： 取得文本： 命令行： 如果你不幸忘记了 curl 的用法，可以 curl  来取得上面的用法。 更多内容参见 github 文档。"}]