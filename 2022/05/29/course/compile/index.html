<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/images/icons/favicon.ico">
    
    
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/logo.png">
    
    


    <!-- meta -->


<title>编译原理笔记 | 怀中落霞</title>


    <meta name="keywords" content="笔记, 编译原理">




    <!-- OpenGraph -->
 
    <meta name="description" content="过！过！过！">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理笔记">
<meta property="og:url" content="https://poorpool.github.io/2022/05/29/course/compile/index.html">
<meta property="og:site_name" content="怀中落霞">
<meta property="og:description" content="过！过！过！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220330223124328.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220330223532698.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220331082033770.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220331085250128.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220331091635117.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220407081506001.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220407081736004.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220407084113774.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414084718054.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414090551991.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414083551890.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419081117532.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414090745492.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414105256495.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419082022955.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419082119908.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414092719407.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220414092810437.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419083609234.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419084319905.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419084959351.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419085416649.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419085604298.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419090316698.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419101007194.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419101319842.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220419101431945.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421082139849.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421082420386.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421082504587.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421082740405.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421083325643.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220421083340220.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428081111495.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428082511008.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428083145749.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428083245056.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428083420727-16511060612761.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428084438149.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428084500970.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428084514951.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428084615079.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220428084626767.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220502152007125.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220502152019257.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503084504065.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503084519357.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503084839204.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503085505514.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503091034551.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503091043963.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503091359102.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503092728081.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503093200172.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503094230676.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503095023503.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220503094939549.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510083743748.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510083854799.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510083956629.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510084009733.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510084020483.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510084032839.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510164659045.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510165822712.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510191348959.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510191429332.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510191852844.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220510192044831.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523090729753.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523091450231.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523091924170.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523092221539.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523093848685-16532699290421.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523094232788.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523094834861.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523102243905.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523110955171.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523111750937.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523112337336.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523112514088.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523112608775.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523112720484.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523112729649.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523113011411.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220523113025922.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609081130115.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609082010995.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609082230107.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609083150216.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609085820617.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609092014882.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609092046983.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609092424634.png">
<meta property="og:image" content="https://poorpool.github.io/images/compileprinciple/image-20220609093528334.png">
<meta property="article:published_time" content="2022-05-29T22:37:22.000Z">
<meta property="article:modified_time" content="2024-01-27T13:50:50.943Z">
<meta property="article:author" content="poorpool">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="编译原理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://poorpool.github.io/images/compileprinciple/image-20220330223124328.png">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/a11y-light.css" media="none" onload="this.media='all'">
        
    

    
    

    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="怀中落霞" type="application/atom+xml">
</head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">怀中落霞</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/categories/" class="navbar-menu button">分类</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/links/" class="navbar-menu button">友链</a>
                
                    <a href="/about/" class="navbar-menu button">关于</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/categories/" class="dropdown-menu button">分类</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/links/" class="dropdown-menu button">友链</a>
                
                    <a href="/about/" class="dropdown-menu button">关于</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        编译原理笔记
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2022/05/" class="post-meta__date button">2022-05-29</a>
        
    <span class="separate-dot"></span><a href="/categories/%E7%AC%94%E8%AE%B0/" class="button">笔记</a>

 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA%E5%92%8C%E8%AF%BE%E7%A8%8B%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">引论和课程重点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ch02-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">ch02-文法和语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch03-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">ch03-词法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch04-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">ch04-自顶向下语法分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch05-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">ch05-自底向上优先分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch06-LR%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">ch06-LR分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch07-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">ch07-语法制导的语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch08-%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.7.</span> <span class="toc-text">ch08-静态语义分析和中间代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch09-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">1.8.</span> <span class="toc-text">ch09-运行时存储组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch10-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.9.</span> <span class="toc-text">ch10-代码优化与目标代码生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">文法和语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E4%B8%B2-%E6%96%87%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">符号和符号串-文法的基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">文法和语言的形式化定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">文法的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">上下文无关文法及其语法树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">句型的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-%E6%96%87%E6%B3%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%BD%99%E8%A7%84%E5%88%99%E5%92%8Cepsilon-%CE%B5-%E8%A7%84%E5%88%99"><span class="toc-number">2.6.</span> <span class="toc-text">补充说明-文法中的多余规则和epsilon (ε) 规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">词法分析程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.</span> <span class="toc-text">单词的形式化描述工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">有穷自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">各类转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E8%BD%AC%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">正规式转正规文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E8%BD%AC%E6%AD%A3%E8%A7%84%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">正规文法转正规式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NFA%E8%BD%ACDFA"><span class="toc-number">3.4.3.</span> <span class="toc-text">NFA转DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E7%9A%84%E5%8C%96%E7%AE%80"><span class="toc-number">3.4.4.</span> <span class="toc-text">DFA的化简</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E5%92%8C%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.5.</span> <span class="toc-text">正规式和有穷自动机的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E5%92%8C%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.6.</span> <span class="toc-text">正规文法和有穷自动机的转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">自顶向下语法分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.</span> <span class="toc-text">确定的自顶向下语法分析思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E5%88%A4%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">LL(1)文法的判别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E9%9D%9ELL-1-%E6%96%87%E6%B3%95%E5%88%B0LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E7%AD%89%E4%BB%B7%E5%8F%98%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">某些非LL(1)文法到LL(1)文法的等价变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">LL(1)分析的实现-递归下降分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E7%9A%84%E5%AE%9E%E7%8E%B0-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">LL(1)分析的实现-表驱动分析法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">自底向上优先分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">简单优先分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">算符优先分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">LR 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">LR分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">LR(0)分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%89%8D%E7%BC%80%E5%92%8C%E5%8F%AF%E5%BD%92%E5%89%8D%E7%BC%80"><span class="toc-number">6.2.1.</span> <span class="toc-text">活前缀和可归前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%B4%BB%E5%89%8D%E7%BC%80DFA"><span class="toc-number">6.2.2.</span> <span class="toc-text">识别活前缀DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0LR-0-%E9%A1%B9%E7%9B%AE%E9%9B%86%E8%A7%84%E8%8C%83%E6%97%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">构造LR(0)项目集规范族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.2.4.</span> <span class="toc-text">LR(0)分析表的构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">SLR(1)分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">LR(1)分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LALR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">LALR(1)分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.</span> <span class="toc-text">语法制导的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.</span> <span class="toc-text">基于属性文法的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">7.1.1.</span> <span class="toc-text">属性文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.2.</span> <span class="toc-text">语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8CL-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">S-属性文法和L-属性文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ES-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.4.</span> <span class="toc-text">基于S-属性文法的语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.5.</span> <span class="toc-text">基于L-属性文法的语义计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.</span> <span class="toc-text">基于翻译模式的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">翻译模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ES-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.2.</span> <span class="toc-text">基于S-翻译模式的语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.3.</span> <span class="toc-text">基于L-翻译模式的自顶向下计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.4.</span> <span class="toc-text">基于L-翻译模式的自底向上计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.</span> <span class="toc-text">静态语义分析和中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">8.1.</span> <span class="toc-text">静态语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.2.</span> <span class="toc-text">中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%92%8C%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">8.2.1.</span> <span class="toc-text">赋值语句和算术表达式的翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">8.2.2.</span> <span class="toc-text">说明语句的翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%9B%9E%E5%A1%AB%EF%BC%88backpatching%EF%BC%89"><span class="toc-number">8.2.3.</span> <span class="toc-text">拉链与代码回填（backpatching）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">9.</span> <span class="toc-text">运行时存储组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">运行时存储组织概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.1.</span> <span class="toc-text">静态存储分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.2.</span> <span class="toc-text">栈式存储分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.3.</span> <span class="toc-text">堆式存储分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%A0%88%E5%B8%A7%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">活动记录（栈帧）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">过程调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">10.</span> <span class="toc-text">代码优化与目标代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">优化技术介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E3%80%81%E6%B5%81%E5%9B%BE%E3%80%81%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.2.</span> <span class="toc-text">基本块、流图、循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97"><span class="toc-number">10.2.1.</span> <span class="toc-text">基本块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%9B%BE"><span class="toc-number">10.2.2.</span> <span class="toc-text">流图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.3.</span> <span class="toc-text">常用优化方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">10.3.</span> <span class="toc-text">代码优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.1.</span> <span class="toc-text">窥孔优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">局部优化（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.3.</span> <span class="toc-text">循环优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF"><span class="toc-number">10.4.</span> <span class="toc-text">目标代码生成技术</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA%E5%92%8C%E8%AF%BE%E7%A8%8B%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">引论和课程重点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ch02-%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">ch02-文法和语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch03-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">ch03-词法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch04-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">ch04-自顶向下语法分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch05-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">ch05-自底向上优先分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch06-LR%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">ch06-LR分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch07-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">ch07-语法制导的语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch08-%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.7.</span> <span class="toc-text">ch08-静态语义分析和中间代码生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch09-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">1.8.</span> <span class="toc-text">ch09-运行时存储组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch10-%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">1.9.</span> <span class="toc-text">ch10-代码优化与目标代码生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">文法和语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E4%B8%B2-%E6%96%87%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">符号和符号串-文法的基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">文法和语言的形式化定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">文法的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">上下文无关文法及其语法树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">2.5.</span> <span class="toc-text">句型的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-%E6%96%87%E6%B3%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%BD%99%E8%A7%84%E5%88%99%E5%92%8Cepsilon-%CE%B5-%E8%A7%84%E5%88%99"><span class="toc-number">2.6.</span> <span class="toc-text">补充说明-文法中的多余规则和epsilon (ε) 规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">词法分析程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.</span> <span class="toc-text">单词的形式化描述工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">有穷自动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">各类转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E8%BD%AC%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">正规式转正规文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E8%BD%AC%E6%AD%A3%E8%A7%84%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">正规文法转正规式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NFA%E8%BD%ACDFA"><span class="toc-number">3.4.3.</span> <span class="toc-text">NFA转DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E7%9A%84%E5%8C%96%E7%AE%80"><span class="toc-number">3.4.4.</span> <span class="toc-text">DFA的化简</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E5%BC%8F%E5%92%8C%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.5.</span> <span class="toc-text">正规式和有穷自动机的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E8%A7%84%E6%96%87%E6%B3%95%E5%92%8C%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.6.</span> <span class="toc-text">正规文法和有穷自动机的转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">自顶向下语法分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.</span> <span class="toc-text">确定的自顶向下语法分析思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E5%88%A4%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">LL(1)文法的判别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%BA%9B%E9%9D%9ELL-1-%E6%96%87%E6%B3%95%E5%88%B0LL-1-%E6%96%87%E6%B3%95%E7%9A%84%E7%AD%89%E4%BB%B7%E5%8F%98%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">某些非LL(1)文法到LL(1)文法的等价变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E7%9A%84%E5%AE%9E%E7%8E%B0-%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">LL(1)分析的实现-递归下降分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E7%9A%84%E5%AE%9E%E7%8E%B0-%E8%A1%A8%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">LL(1)分析的实现-表驱动分析法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">自底向上优先分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">简单优先分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">算符优先分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR-%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">LR 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LR%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">LR分析概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90"><span class="toc-number">6.2.</span> <span class="toc-text">LR(0)分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E5%89%8D%E7%BC%80%E5%92%8C%E5%8F%AF%E5%BD%92%E5%89%8D%E7%BC%80"><span class="toc-number">6.2.1.</span> <span class="toc-text">活前缀和可归前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E6%B4%BB%E5%89%8D%E7%BC%80DFA"><span class="toc-number">6.2.2.</span> <span class="toc-text">识别活前缀DFA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0LR-0-%E9%A1%B9%E7%9B%AE%E9%9B%86%E8%A7%84%E8%8C%83%E6%97%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">构造LR(0)项目集规范族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.2.4.</span> <span class="toc-text">LR(0)分析表的构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">SLR(1)分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">LR(1)分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LALR-1-%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">LALR(1)分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.</span> <span class="toc-text">语法制导的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.</span> <span class="toc-text">基于属性文法的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">7.1.1.</span> <span class="toc-text">属性文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.2.</span> <span class="toc-text">语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8CL-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">S-属性文法和L-属性文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ES-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.4.</span> <span class="toc-text">基于S-属性文法的语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.1.5.</span> <span class="toc-text">基于L-属性文法的语义计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.</span> <span class="toc-text">基于翻译模式的语义计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">翻译模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ES-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.2.</span> <span class="toc-text">基于S-翻译模式的语义计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.3.</span> <span class="toc-text">基于L-翻译模式的自顶向下计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EL-%E7%BF%BB%E8%AF%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.4.</span> <span class="toc-text">基于L-翻译模式的自底向上计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.</span> <span class="toc-text">静态语义分析和中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90"><span class="toc-number">8.1.</span> <span class="toc-text">静态语义分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">8.2.</span> <span class="toc-text">中间代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E5%92%8C%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">8.2.1.</span> <span class="toc-text">赋值语句和算术表达式的翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91"><span class="toc-number">8.2.2.</span> <span class="toc-text">说明语句的翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%9B%9E%E5%A1%AB%EF%BC%88backpatching%EF%BC%89"><span class="toc-number">8.2.3.</span> <span class="toc-text">拉链与代码回填（backpatching）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87"><span class="toc-number">9.</span> <span class="toc-text">运行时存储组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">运行时存储组织概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.1.</span> <span class="toc-text">静态存储分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.2.</span> <span class="toc-text">栈式存储分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%BC%8F%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D"><span class="toc-number">9.1.3.</span> <span class="toc-text">堆式存储分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%EF%BC%88%E6%A0%88%E5%B8%A7%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">活动记录（栈帧）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">过程调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">10.</span> <span class="toc-text">代码优化与目标代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">优化技术介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E3%80%81%E6%B5%81%E5%9B%BE%E3%80%81%E5%BE%AA%E7%8E%AF"><span class="toc-number">10.2.</span> <span class="toc-text">基本块、流图、循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97"><span class="toc-number">10.2.1.</span> <span class="toc-text">基本块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%9B%BE"><span class="toc-number">10.2.2.</span> <span class="toc-text">流图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.3.</span> <span class="toc-text">常用优化方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">10.3.</span> <span class="toc-text">代码优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.1.</span> <span class="toc-text">窥孔优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">10.3.2.</span> <span class="toc-text">局部优化（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.3.</span> <span class="toc-text">循环优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF"><span class="toc-number">10.4.</span> <span class="toc-text">目标代码生成技术</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>过！过！过！</p>
<span id="more"></span>

<h2 id="引论和课程重点"><a href="#引论和课程重点" class="headerlink" title="引论和课程重点"></a>引论和课程重点</h2><p>编译过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成</p>
<p>第一章大概10%</p>
<p>第二章文法语言肯定要给语言要求使用文法描述，可以结合第三章</p>
<p>自顶向下分析肯定会考一个完整的</p>
<p>LR也会考一个完整的</p>
<p>算符优先，简单优先可能不会考完整的，只会考一个概念</p>
<p>几种LR的关系要知道</p>
<p>第七八章要考，可能会考翻译模式，给c让你翻译中间代码。</p>
<p>第九章考一个栈帧就行了</p>
<p>具体的开完会再说</p>
<p>课程重点选择来源：作业里有的、PPT后面写的重点</p>
<h3 id="ch02-文法和语言"><a href="#ch02-文法和语言" class="headerlink" title="ch02-文法和语言"></a>ch02-文法和语言</h3><p>设计一个已知语言的文法；确定已知文法定义的语言；求句型的短语、直接短语和句柄；文法二义性判定</p>
<h3 id="ch03-词法分析"><a href="#ch03-词法分析" class="headerlink" title="ch03-词法分析"></a>ch03-词法分析</h3><p>设计正规文法|正规式|有穷自动机；等价转换；词法分析器的构造</p>
<h3 id="ch04-自顶向下语法分析方法"><a href="#ch04-自顶向下语法分析方法" class="headerlink" title="ch04-自顶向下语法分析方法"></a>ch04-自顶向下语法分析方法</h3><ul>
<li>计算产生式的SELECT()集</li>
<li>FIRST()集，FOLLOW()集</li>
<li>判断文法是否LL(1)文法</li>
<li>LL(1)分析表</li>
<li>LL(1)分析算法</li>
<li>递归子程序构造</li>
<li>非LL(1)文法：提取左公因子，消除左递归，改造或重新设计文法，使其成为LL(1)文法</li>
</ul>
<h3 id="ch05-自底向上优先分析"><a href="#ch05-自底向上优先分析" class="headerlink" title="ch05-自底向上优先分析"></a>ch05-自底向上优先分析</h3><p>计算优先关系；优先文法的判定；构造优先分析表；优先分析算法</p>
<h3 id="ch06-LR分析"><a href="#ch06-LR分析" class="headerlink" title="ch06-LR分析"></a>ch06-LR分析</h3><p><strong>基本概念</strong>：<br>可归前缀、活前缀、LR(0)项目、移进项目、待约项目、归约项目、接受项目、移进-归约冲突、归约-归约冲突、LR(0)项目集、LR(0)项目集规范族、LR(0)文法、SLR(1)文法、搜索符、搜索集、LR(1)项目、LR(1)文法、LR(1)项目集规范族、同心项目、同心项目集和LALR(1)文法<br><strong>重点掌握</strong>：</p>
<ul>
<li>构造识别LR(0)活前缀DFA、构造识别LR(1)活前缀DFA和合并识别LR(1)活前缀DFA的同心项目集；</li>
<li>LR(0)、SLR(1)、LR(1)和LALR(1)文法判别；</li>
<li>LR(0)、SLR(1)、LR(1)和LALR(1) 分析表；</li>
<li>LR分析算法。</li>
</ul>
<h3 id="ch07-语法制导的语义分析"><a href="#ch07-语法制导的语义分析" class="headerlink" title="ch07-语法制导的语义分析"></a>ch07-语法制导的语义分析</h3><p>属性文法基本概念与属性的计算方法；翻译模式基本概念与属性的计算方法</p>
<h3 id="ch08-静态语义分析和中间代码生成"><a href="#ch08-静态语义分析和中间代码生成" class="headerlink" title="ch08-静态语义分析和中间代码生成"></a>ch08-静态语义分析和中间代码生成</h3><p>符号表的作用于基本实现技术；表达式的中间代码表示；基本语法规则的语义规则设计</p>
<h3 id="ch09-运行时存储组织"><a href="#ch09-运行时存储组织" class="headerlink" title="ch09-运行时存储组织"></a>ch09-运行时存储组织</h3><p>静态数组、动态数组、关键字池、浮动地址代码、静态数据对象、动态数据对象、<strong>静态存储分配、栈式动态存储分配、堆式存储分配、过程活动记录和静态层次数</strong></p>
<h3 id="ch10-代码优化与目标代码生成"><a href="#ch10-代码优化与目标代码生成" class="headerlink" title="ch10-代码优化与目标代码生成"></a>ch10-代码优化与目标代码生成</h3><p>基本块划分<br>程序流图构造<br>循环的识别<br>循环的优化</p>
<h2 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h2><h3 id="符号和符号串-文法的基本要素"><a href="#符号和符号串-文法的基本要素" class="headerlink" title="符号和符号串-文法的基本要素"></a>符号和符号串-文法的基本要素</h3><p>字母表∑是非空有穷集合，其元素称为符号。由字母表∑中的符号组成的有穷序列称为 (字母表∑上的)符号串. 不含任何符号的有穷序列称为空串,记为ε。符号串α的长度是指符号串α中含有符号的个数，记为︱α︱。如果集合A的元素都是字母表∑上的符号串，则称集合A为∑上的符号串集合，简称串集。 </p>
<p>设字母表∑＝｛a，b，c｝，A＝｛ε，a，ba，cab｝，B＝｛a1，ba，cab｝，则 A是∑上的符号串集合，B不是∑上的符号串集合。 </p>
<p><strong>符号串的运算</strong>：和计算理论中的类似。连接、或、幂、正闭包、星闭包。</p>
<p><strong>符号串集合的运算</strong>：（笛卡尔）乘积、和、幂、正闭包、星闭包。</p>
<p><img src="/images/compileprinciple/image-20220330223124328.png" class="lazy" data-srcset="/images/compileprinciple/image-20220330223124328.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220330223124328"></p>
<p>显然，若A为任意一个字母表，$A^*$就是字母表上所有符号串（包括空串）的集合。</p>
<h3 id="文法和语言的形式化定义"><a href="#文法和语言的形式化定义" class="headerlink" title="文法和语言的形式化定义"></a>文法和语言的形式化定义</h3><p><img src="/images/compileprinciple/image-20220330223532698.png" class="lazy" data-srcset="/images/compileprinciple/image-20220330223532698.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220330223532698">$\alpha ::&#x3D; \beta$简写为$\alpha \rightarrow \beta$。若P中包含它，则任意的串γαδ 可以推导出γβδ，这是<strong>直接推导&#x2F;一步推导</strong>，记为γαδ $\Rightarrow$ γβδ。也可以说γβδ归约到γαδ ，这种归约称为<strong>直接归约&#x2F;一步归约</strong>。</p>
<p><img src="/images/compileprinciple/image-20220331082033770.png" class="lazy" data-srcset="/images/compileprinciple/image-20220331082033770.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220331082033770"></p>
<p>若$\alpha \stackrel{+}{\Rightarrow} \beta$或者$\alpha \rightarrow \beta$，则记$\alpha \stackrel{*}{\Rightarrow} \beta$。</p>
<p><strong>句型和句子</strong>：G[S]  有$S \stackrel{<em>}{\Rightarrow} \beta$，则称β是文法G[S]的<strong>句型</strong>。若β∈$V_T^</em>$，则称β是文法G的<strong>句子</strong>。当然，句子也是句型。</p>
<p>文法G产生语言即为其句子的集合，记为L(G)。如果两个文法的产生语言一样，文法就等价。</p>
<h3 id="文法的类型"><a href="#文法的类型" class="headerlink" title="文法的类型"></a>文法的类型</h3><ul>
<li><p>0型文法&#x2F;短语文法&#x2F;图灵机：一个文法的所有规则，<strong>左侧至少含有一个非终结符</strong>。</p>
</li>
<li><p>1型文法&#x2F;上下文有关文法&#x2F;线性界限自动机：左侧符号串的<strong>长度不大于</strong>右侧符号串的长度（空规则除外），且<strong>左侧至少含有一个非终结符</strong>。（ γAδ $\Rightarrow$ γβθδ，A被替换成βθ，跟A的上下文相关，因为要match整个 γAδ）</p>
</li>
<li><p>2型文法&#x2F;上下文无关文法：任一产生式左部均为恰<strong>好一个非终结符</strong></p>
</li>
<li><p>3型文法&#x2F;正规文法&#x2F;有限自动机：跟教材上不一样！</p>
<p><img src="/images/compileprinciple/image-20220331085250128.png" class="lazy" data-srcset="/images/compileprinciple/image-20220331085250128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220331085250128"></p>
<p>L3真含于L2真含于L1真含于L0。</p>
</li>
</ul>
<h3 id="上下文无关文法及其语法树"><a href="#上下文无关文法及其语法树" class="headerlink" title="上下文无关文法及其语法树"></a>上下文无关文法及其语法树</h3><p>  最右推导，也叫规范推导。由规范推导所得的句型，叫做规范句型(右句型)。规范推导的逆过程，叫做规范归约。 </p>
<p>  <img src="/images/compileprinciple/image-20220331091635117.png" class="lazy" data-srcset="/images/compileprinciple/image-20220331091635117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220331091635117"></p>
<p>  语法的二义性不等于语言的二义性。二义性文法可能存在等价的非二义性文法。不过语法的二义性问题是不可判定的。</p>
<h3 id="句型的分析"><a href="#句型的分析" class="headerlink" title="句型的分析"></a>句型的分析</h3><p>  假设文法G[S]是语言L之文法，即L(G)＝L，则“符号串α是否符合语言L的语法问题” 被等价地转化成“推导或归约问题”，即是否$S \stackrel{<em>}{\Rightarrow} \alpha \and \alpha \in V_T^</em>$。</p>
<p>  <strong>自顶向下分析法</strong>：从文法开始符号出发，反复使用规则，寻找匹配符号串（推导）的句型，直到推导出句子或穷尽规则也不能推导出。</p>
<p>  要解决的问题：选择句型中哪一个非终结符进行推导、选择非终结符的哪一个规则进行推导。</p>
<p>  容易出现回溯，可以考虑提公因子。</p>
<p>  <strong>自下而上分析法</strong>：从输入符号串α开始，逐步进行“归约”，直至归约出文法的开始符号 S，则输入串α是文法G定义的语言的句子，否则不是</p>
<p>  要解决的问题：如何选择句型α的子串β进行归约。</p>
<p>  按句柄归约-规范归约(移进-归约)</p>
<p>  <img src="/images/compileprinciple/image-20220407081506001.png" class="lazy" data-srcset="/images/compileprinciple/image-20220407081506001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220407081506001"></p>
<p>  总的来说,一个非终结符的树叶组成短语，一个下面就一层的非终结符的树叶组成直接短语。在做推导的时候，ε直接不写。但是在分析短语的时候，ε要写出来。一个句型<strong>最左边的那一个直接短语</strong>，叫做句柄</p>
<p>  <img src="/images/compileprinciple/image-20220407081736004.png" class="lazy" data-srcset="/images/compileprinciple/image-20220407081736004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220407081736004"></p>
<h3 id="补充说明-文法中的多余规则和epsilon-ε-规则"><a href="#补充说明-文法中的多余规则和epsilon-ε-规则" class="headerlink" title="补充说明-文法中的多余规则和epsilon (ε) 规则"></a>补充说明-文法中的多余规则和epsilon (ε) 规则</h3><p>  文法的化简：</p>
<ol>
<li><p>删除A-&gt;A这样的有害规则</p>
</li>
<li><p>删除不终结产生式（永远到不了终结符）</p>
</li>
<li><p>删除不可用产生式（压根到不了规则左边的非终结符）</p>
</li>
<li><p>删除ε产生式：</p>
</li>
</ol>
<p>  <img src="/images/compileprinciple/image-20220407084113774.png" class="lazy" data-srcset="/images/compileprinciple/image-20220407084113774.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220407084113774"></p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><h3 id="词法分析程序设计"><a href="#词法分析程序设计" class="headerlink" title="词法分析程序设计"></a>词法分析程序设计</h3><p>  输出每个词形式 (单词种别，单词自身的值)，单词种别常用enum</p>
<h3 id="单词的形式化描述工具"><a href="#单词的形式化描述工具" class="headerlink" title="单词的形式化描述工具"></a>单词的形式化描述工具</h3><p>  用正规文法、正规式、有穷自动机三种描述方法。（计算理论人狂喜）</p>
<p>  正规文法：设文法G＝（$V_N$，$V_T$，P，S），如果任意A→β∈ P，A∈ $V_N$ ，且β只能是aB或a或Ɛ, 则称文法G属于右线性3型文法。</p>
<p>  正规式：算符优先级由高到低 ：*，·，|</p>
<h3 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h3><p>  DFA的f: 状态转换(移)函数，为$K\times \Sigma \rightarrow K$的单值部分映射</p>
<p>  DFA的扩展状态转移函数 f’ $K\times \Sigma^* \rightarrow K$，编译的DFA好像允许不是每个字母都有状态去转移</p>
<p>  NFA的状态转移函数 $K\times(\Sigma\cup{ε})\rightarrow P(K)$，其中P(K)为K的幂集</p>
<p>  NFA 弧上的标记可以是ε，同一个字母可能出现在同一状态射出的多条弧上</p>
<p>  NFA</p>
<p>  <img src="/images/compileprinciple/image-20220414084718054.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414084718054.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414084718054"></p>
<p>  每次都做集合到集合的变换</p>
<p>  <img src="/images/compileprinciple/image-20220414090551991.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414090551991.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414090551991"></p>
<p>  显然$\epsilon-Closure(I)$就是I通过空转移能到达的所有状态的集合</p>
<h3 id="各类转换"><a href="#各类转换" class="headerlink" title="各类转换"></a>各类转换</h3><h4 id="正规式转正规文法"><a href="#正规式转正规文法" class="headerlink" title="正规式转正规文法"></a>正规式转正规文法</h4><p>  <img src="/images/compileprinciple/image-20220414083551890.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414083551890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414083551890"></p>
<p>  我的评价是计算理论重现江湖</p>
<h4 id="正规文法转正规式"><a href="#正规文法转正规式" class="headerlink" title="正规文法转正规式"></a>正规文法转正规式</h4><p>  <img src="/images/compileprinciple/image-20220419081117532.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419081117532.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419081117532"></p>
<h4 id="NFA转DFA"><a href="#NFA转DFA" class="headerlink" title="NFA转DFA"></a>NFA转DFA</h4><p>  <img src="/images/compileprinciple/image-20220414090745492.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414090745492.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414090745492"></p>
<p>  画这么一个表：</p>
<table>
<thead>
<tr>
<th></th>
<th>重命名</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>{0,1,7,2,4}</td>
<td>0</td>
<td>{3,8,6,1,7,2,4}</td>
<td>{5,6,1,7,2,4}</td>
</tr>
<tr>
<td>{3,8,6,1,7,2,4}</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>  就是首先放进去ε-Closure(S)，然后不断变换。注意每一个变换的结果都是ε-Closure。最后按这个表格重命名画图。</p>
<h4 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h4><ol>
<li>消除无用状态：不可达，没有通路到达终态；</li>
<li>合并等价状态（都是终结态&#x2F;非终结态，任意转换都到等价的状态）</li>
</ol>
<p>  起初的两个集合先按终结 非终结分类，每次查看有没有一个集合的两个元素的转移结果不在同一个集合里头，那么这两个元素就要拆开。</p>
<p>  <img src="/images/compileprinciple/image-20220414105256495.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414105256495.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414105256495"></p>
<h4 id="正规式和有穷自动机的转换"><a href="#正规式和有穷自动机的转换" class="headerlink" title="正规式和有穷自动机的转换"></a>正规式和有穷自动机的转换</h4><p>  NFA转正规式：</p>
<p>  <img src="/images/compileprinciple/image-20220419082022955.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419082022955.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419082022955"></p>
<p>  正规式转NFA：</p>
<p>  <img src="/images/compileprinciple/image-20220419082119908.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419082119908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419082119908"></p>
<p>  NFA转DFA就是了。</p>
<h4 id="正规文法和有穷自动机的转换"><a href="#正规文法和有穷自动机的转换" class="headerlink" title="正规文法和有穷自动机的转换"></a>正规文法和有穷自动机的转换</h4><p>  <img src="/images/compileprinciple/image-20220414092719407.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414092719407.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414092719407"></p>
<p>  <img src="/images/compileprinciple/image-20220414092810437.png" class="lazy" data-srcset="/images/compileprinciple/image-20220414092810437.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220414092810437"></p>
<h2 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h2><p>自顶向下是推导，ANTLR4，LL(1)</p>
<p><img src="/images/compileprinciple/image-20220419083609234.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419083609234.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419083609234"></p>
<h3 id="确定的自顶向下语法分析思想"><a href="#确定的自顶向下语法分析思想" class="headerlink" title="确定的自顶向下语法分析思想"></a>确定的自顶向下语法分析思想</h3><p>约定好每次选择最左边的非终结符，选择出来一个唯一的产生式</p>
<p>FIRST(α)-串首(终结)符号集</p>
<p><img src="/images/compileprinciple/image-20220419084319905.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419084319905.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419084319905"></p>
<p>FOLLOW(A)-非终结符的后继(终结)符号集。FOLLOW(A)是由任意句型中紧邻非终结符号A之后出现的终结符号a组成的集合。</p>
<p><img src="/images/compileprinciple/image-20220419084959351.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419084959351.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419084959351"></p>
<p><img src="/images/compileprinciple/image-20220419085416649.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419085416649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419085416649"></p>
<p>SELECT(A→α) - 产生式的可选集</p>
<p><img src="/images/compileprinciple/image-20220419085604298.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419085604298.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419085604298"></p>
<p>文法G是LL(1)的，当且仅当对每个VN，A的两个不同产生式A→α，A→β，满足SELECT(A→α) ∩ SELECT(A→β) &#x3D; Φ 其中，α、β不能同时推导出ε。确定的无二义性的。</p>
<p>L – Left to right parsing 从左至右分析token<br>L – Left-most derivation 最左推导<br>1 –只需向右看1个符号便可以决定选择哪个产生式进行推导</p>
<p><img src="/images/compileprinciple/image-20220419090316698.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419090316698.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419090316698"></p>
<h3 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1)文法的判别"></a>LL(1)文法的判别</h3><p>文法G是LL(1)的,当且仅当任意两个左部相同的产生式其select集的交集为空。</p>
<ul>
<li>判别$S \stackrel{*}{\Rightarrow} \alpha$ ？仅当α中所有非终结符全部可推导出空，且α无非空的终结符</li>
<li>求产生式右部FIRST集, 如产式右部可推导出ε,则还需：</li>
<li>计算产生式左部FOLLOW集</li>
</ul>
<p><strong>判别能否产生空串</strong>：</p>
<p><img src="/images/compileprinciple/image-20220419101007194.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419101007194.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419101007194"></p>
<p><strong>求产生式右部FIRST集</strong>：</p>
<p><img src="/images/compileprinciple/image-20220419101319842.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419101319842.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419101319842"></p>
<p><strong>求follow集合</strong>：</p>
<p><img src="/images/compileprinciple/image-20220419101431945.png" class="lazy" data-srcset="/images/compileprinciple/image-20220419101431945.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220419101431945"></p>
<h3 id="某些非LL-1-文法到LL-1-文法的等价变换"><a href="#某些非LL-1-文法到LL-1-文法的等价变换" class="headerlink" title="某些非LL(1)文法到LL(1)文法的等价变换"></a>某些非LL(1)文法到LL(1)文法的等价变换</h3><p>若文法含有左公共因子，或者含有直接或间接左递归，一定不是LL(1)文法。</p>
<p>先消除左递归，再提取左公因子。</p>
<p><strong>提取左公因子</strong>：</p>
<p><img src="/images/compileprinciple/image-20220421082139849.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421082139849.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421082139849"></p>
<p>这么不断提取。注意没有左公因子只是一个必要条件。</p>
<p><strong>消除左递归</strong>：</p>
<p><img src="/images/compileprinciple/image-20220421082420386.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421082420386.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421082420386"></p>
<p><img src="/images/compileprinciple/image-20220421082504587.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421082504587.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421082504587"></p>
<p><strong>消除一切左递归</strong>：</p>
<p><img src="/images/compileprinciple/image-20220421082740405.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421082740405.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421082740405"></p>
<h3 id="LL-1-分析的实现-递归下降分析法"><a href="#LL-1-分析的实现-递归下降分析法" class="headerlink" title="LL(1)分析的实现-递归下降分析法"></a>LL(1)分析的实现-递归下降分析法</h3><p>将每个非终结符编写成一个递归子程序，选择规则的实现步骤是将输入串“下一个符号”逐个与A规则的选择集进行判定。</p>
<h3 id="LL-1-分析的实现-表驱动分析法"><a href="#LL-1-分析的实现-表驱动分析法" class="headerlink" title="LL(1)分析的实现-表驱动分析法"></a>LL(1)分析的实现-表驱动分析法</h3><p><img src="/images/compileprinciple/image-20220421083325643.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421083325643.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421083325643"></p>
<p><img src="/images/compileprinciple/image-20220421083340220.png" class="lazy" data-srcset="/images/compileprinciple/image-20220421083340220.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220421083340220"></p>
<h2 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h2><h3 id="简单优先分析法"><a href="#简单优先分析法" class="headerlink" title="简单优先分析法"></a>简单优先分析法</h3><p><img src="/images/compileprinciple/image-20220428081111495.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428081111495.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428081111495"></p>
<p>文法G的符号集V中,任意两个符号之间至多$\lessdot$lessdot、$\gtrdot$gtrdot、$\eqcirc$eqcirc（实在打不出来了）三种简单优先关系之一,且没有相同右部的规则,则文法G称为简单优先文法。</p>
<p><img src="/images/compileprinciple/image-20220428082511008.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428082511008.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428082511008"></p>
<h3 id="算符优先分析法"><a href="#算符优先分析法" class="headerlink" title="算符优先分析法"></a>算符优先分析法</h3><p><img src="/images/compileprinciple/image-20220428083145749.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428083145749.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428083145749"></p>
<p><img src="/images/compileprinciple/image-20220428083245056.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428083245056.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428083245056"></p>
<p>设不含空规则的文法G为OG文法,如果任意两个终结符之间至多存在$\eqcirc,\lessdot,\gtrdot$三种算符优先关系之一,则称文法G为算符优先文法(Operator Precedence Grammar),简称OPG文法。</p>
<p><img src="/images/compileprinciple/image-20220428083420727-16511060612761.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428083420727-16511060612761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428083420727"></p>
<p>后面太复杂了，做了作业再截图</p>
<p><img src="/images/compileprinciple/image-20220428084438149.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428084438149.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428084438149"></p>
<p><img src="/images/compileprinciple/image-20220428084500970.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428084500970.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428084500970"></p>
<p><img src="/images/compileprinciple/image-20220428084514951.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428084514951.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428084514951"></p>
<p><img src="/images/compileprinciple/image-20220428084615079.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428084615079.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428084615079"></p>
<p><img src="/images/compileprinciple/image-20220428084626767.png" class="lazy" data-srcset="/images/compileprinciple/image-20220428084626767.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220428084626767"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>注意：任何句型前后都有一个井号！自己加的。</p>
<p>竖着的是a，横着的是b，内容是a和b的关系</p>
<p>N代表任意非终结符，感觉是根据前一个非终结符的关系来判定，小于和等于就移进。大于规约。</p>
<p><img src="/images/compileprinciple/image-20220502152007125.png" class="lazy" data-srcset="/images/compileprinciple/image-20220502152007125.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220502152007125"></p>
<p><img src="/images/compileprinciple/image-20220502152019257.png" class="lazy" data-srcset="/images/compileprinciple/image-20220502152019257.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220502152019257"></p>
<h2 id="LR-分析"><a href="#LR-分析" class="headerlink" title="LR 分析"></a>LR 分析</h2><p>语法分析。<strong>本章要对着ppt仔仔细细研究</strong>。</p>
<h3 id="LR分析概述"><a href="#LR分析概述" class="headerlink" title="LR分析概述"></a>LR分析概述</h3><p>LR(k)：L(Left to right parsing), R(right-most derivation in reverse), K(look ahead k token(s))</p>
<p>总控程序、分析栈和分析表三个组成部分，移进-规约法。</p>
<p><img src="/images/compileprinciple/image-20220503084504065.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503084504065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503084504065"></p>
<p><img src="/images/compileprinciple/image-20220503084519357.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503084519357.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503084519357"></p>
<p><img src="/images/compileprinciple/image-20220503084839204.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503084839204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503084839204"></p>
<p>总之，状态栈和符号栈要同进同出。</p>
<h3 id="LR-0-分析"><a href="#LR-0-分析" class="headerlink" title="LR(0)分析"></a>LR(0)分析</h3><h4 id="活前缀和可归前缀"><a href="#活前缀和可归前缀" class="headerlink" title="活前缀和可归前缀"></a>活前缀和可归前缀</h4><p>简单地说，先找到句柄（最左直接短语），然后<strong>活前缀</strong>是从符号串最左端到句柄最右端，这一条串的所有前缀。<strong>可归前缀</strong>是从符号串最左端到句柄最右端这一条串。</p>
<p><img src="/images/compileprinciple/image-20220503085505514.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503085505514.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503085505514"></p>
<h4 id="识别活前缀DFA"><a href="#识别活前缀DFA" class="headerlink" title="识别活前缀DFA"></a>识别活前缀DFA</h4><p>技术线路是根据文法G，构造识别活前缀NFA  M。之后通过子集法，将NFA M确定化，得到识别活前缀DFA  M′。</p>
<ol>
<li>添加一条$S’\rightarrow S$规则，S’作为起始符，用来给最后转移到接收态。</li>
<li>S→aAcBe这样的，画状态，最后一个节点标上规则的序号并为可接收态，每个非终结符边前面的状态要通过$\epsilon$转移到相应的规则上面</li>
<li>确定化nfa，得到dfa，按照标注的规则转移</li>
</ol>
<p><img src="/images/compileprinciple/image-20220503091034551.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503091034551.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503091034551"></p>
<p><img src="/images/compileprinciple/image-20220503091043963.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503091043963.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503091043963"></p>
<h4 id="构造LR-0-项目集规范族"><a href="#构造LR-0-项目集规范族" class="headerlink" title="构造LR(0)项目集规范族"></a>构造LR(0)项目集规范族</h4><p>首先是给状态取一个规范的名称</p>
<p><img src="/images/compileprinciple/image-20220503091359102.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503091359102.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503091359102"></p>
<p>这样的话，可以通过上面的方法构造识别活前缀的dfa，也可以使用LR(0)项目集(规范族)<strong>直接构造</strong>识别活前缀的DFA。</p>
<p><img src="/images/compileprinciple/image-20220503092728081.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503092728081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503092728081"></p>
<p>设I是文法G的LR(0)项目子集，则MOVE(I，X)定义如下：MOVE(I，X) ＝ {A→αX·β︱A→α·Xβ∈I}。move就相当于把点往后挪了一格。</p>
<p>I的闭包就是它和第一个非终结符的规则的集合：</p>
<p><img src="/images/compileprinciple/image-20220503093200172.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503093200172.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503093200172"></p>
<p><strong>最终构造DFA方法（仔细研读）</strong>：</p>
<p><img src="/images/compileprinciple/image-20220503094230676.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503094230676.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503094230676"></p>
<p>文法G的识别活前缀DFA  M的状态集称为文法G的LR(0)项目集规范族。 </p>
<p><img src="/images/compileprinciple/image-20220503095023503.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503095023503.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503095023503"></p>
<h4 id="LR-0-分析表的构造"><a href="#LR-0-分析表的构造" class="headerlink" title="LR(0)分析表的构造"></a>LR(0)分析表的构造</h4><p><img src="/images/compileprinciple/image-20220503094939549.png" class="lazy" data-srcset="/images/compileprinciple/image-20220503094939549.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220503094939549"></p>
<p>表见上。<strong>总之</strong>，有一个状态$i$（对应项目集规范族$I_i$）</p>
<ul>
<li>非终结符转移到$j$，填action为j</li>
<li>$I_i$是不含规约项目的，那么通过终结符转移到j，填action为$S_j$</li>
<li>$I_i$是含规约项目的，那么全行都是对应的的$r_x$</li>
<li>状态1通常是$S’\rightarrow S$，那么action[1,S]为accept。</li>
</ul>
<p>移进-归约冲突: 项目集中同时出现移进和归约项目：A→α•aβ，B→γ•<br>归约-归约冲突：项目集中同时出现多个归约项目：A→α•，B→β•</p>
<p>如果文法G的LR(0)项目集规范族<strong>不存在移进-归约冲突或归约-归约冲突的项目集，则文法G称为LR(0)文法</strong>。可采用LR(0)分析法、无二义性的。分析表ACTION表中每格仅会是移进、归约和报错3种动作之一。</p>
<h3 id="SLR-1-分析"><a href="#SLR-1-分析" class="headerlink" title="SLR(1)分析"></a>SLR(1)分析</h3><p>LL(1)的痛苦是解决不了移进-规约冲突和规约-规约冲突问题。</p>
<p>不是LR(0)文法时，可以采用简单地<strong>向后看1个输入符号</strong>的方法，解决移进-归约冲突或归约-归约冲突。</p>
<p><img src="/images/compileprinciple/image-20220510083743748.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510083743748.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510083743748"></p>
<p>它的构造法和LR(1)的很类似，除了$I_i$是含规约项目的时候，**不再是简单地把全行都搞成对应的$r_x$**，而是$\forall a\in FOLLOW(A), action[i,a]&#x3D;r_i$。也就是说得在follow集合里头。</p>
<p><img src="/images/compileprinciple/image-20220510083854799.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510083854799.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510083854799"></p>
<p>SLR(1)文法，是无二义性的；LR(0)文法，一定也是SLR(1)文法 </p>
<p><img src="/images/compileprinciple/image-20220510083956629.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510083956629.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510083956629"></p>
<p><img src="/images/compileprinciple/image-20220510084009733.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510084009733.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510084009733"></p>
<p><img src="/images/compileprinciple/image-20220510084020483.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510084020483.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510084020483"></p>
<p><img src="/images/compileprinciple/image-20220510084032839.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510084032839.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510084032839"></p>
<h3 id="LR-1-分析"><a href="#LR-1-分析" class="headerlink" title="LR(1)分析"></a>LR(1)分析</h3><p>b∈FOLLOW(A)只是归约α的一个必要条件，而非充分条件</p>
<p>把First(β)作为产生式作为B→γ归约时向前查看的符号集合,代替SLR(1)分析法中的Follow(B)</p>
<p>并将向前搜索符号集也放在LR(0)项目的后面:[A→α•β, a]， a称为向前搜索符(展望符) - LR(1)项目</p>
<p>LR(1)项目中LR(0)项目部分称为LR(1)项目的心。</p>
<p>同心的LR(1)项目简记为 [LR(0)项目，搜索符1︱搜索符2︱···︱搜索符m]。</p>
<p>“搜索符1︱搜索符2︱···︱搜索符m”称为搜索集。</p>
<p>形如[A→α•, a]的项表示仅在下一个输入符号等于a时才可以按照A→α 进行归约； </p>
<p>这样的a的集合总是FOLLOW(A)的子集，通常是真子集</p>
<p><img src="/images/compileprinciple/image-20220510164659045.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510164659045.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510164659045"></p>
<p><img src="/images/compileprinciple/image-20220510165822712.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510165822712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510165822712"></p>
<p>就是非终结符的后头和后继符都那啥</p>
<p><img src="/images/compileprinciple/image-20220510191348959.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510191348959.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510191348959"></p>
<p><img src="/images/compileprinciple/image-20220510191429332.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510191429332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510191429332"></p>
<p><img src="/images/compileprinciple/image-20220510191852844.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510191852844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510191852844"></p>
<h3 id="LALR-1-分析"><a href="#LALR-1-分析" class="headerlink" title="LALR(1)分析"></a>LALR(1)分析</h3><p>如果采用同心项目集合并方法，进行合并后的文法G的LR(1)项目集规范族，没有LR(1)项目冲突，则称文法G为LALR(1)文法。</p>
<p>合并同心集时产生移进-规约、归约-归约冲突, 就不是LALR(1)文法。</p>
<p><img src="/images/compileprinciple/image-20220510192044831.png" class="lazy" data-srcset="/images/compileprinciple/image-20220510192044831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220510192044831"></p>
<p>任何一个二义性文法都不是LR的</p>
<h2 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h2><h3 id="基于属性文法的语义计算"><a href="#基于属性文法的语义计算" class="headerlink" title="基于属性文法的语义计算"></a>基于属性文法的语义计算</h3><h4 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h4><p><strong>综合属性</strong>：</p>
<ul>
<li>自下而上传递信息</li>
<li>语法规则：产生式左部符号的综合属性由产生式右部符号的属性计算得出</li>
<li>语法树：父节点的综合属性由子结点的属性和父结点自身的属性计算得出</li>
</ul>
<p>终结符的综合属性值是由词法分析器提供的词法值，因此在属性文法中没有计算终结符属性值的语义规则</p>
<p><strong>继承属性</strong>：</p>
<ul>
<li><p>自上而下传递信息</p>
</li>
<li><p>语法规则：根据右部候选式中的符号的属性和左部符号的属性计算右部候选式中的符号的继承属性</p>
</li>
<li><p>语法树：根据父结点和兄长节点的属性计算子结点的继承属性</p>
<p><img src="/images/compileprinciple/image-20220523090729753.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523090729753.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523090729753"></p>
</li>
</ul>
<p>产生式右部符号的继承属性和产生式左部符号的综合属性由本产生式提供计算规则。且规则中只能使用本产生式中文法符号的属性。<br>产生式左部符号的继承属性和产生式右部符号的综合属性的计算规则不由本产生式提供，而是根据其它产生式的语义规则来计算。</p>
<p>带注释的语法树(仅含综合属性)：仅使用综合属性的属性文法称S－属性文法</p>
<p><img src="/images/compileprinciple/image-20220523091450231.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523091450231.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523091450231"></p>
<p>带注释的语法树(含继承属性）：先构造语法树，再计算属性。</p>
<h4 id="语义计算"><a href="#语义计算" class="headerlink" title="语义计算"></a>语义计算</h4><p>属性依赖：</p>
<p><img src="/images/compileprinciple/image-20220523091924170.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523091924170.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523091924170"></p>
<p>如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边</p>
<p><img src="/images/compileprinciple/image-20220523092221539.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523092221539.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523092221539"></p>
<p>树遍历算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">While  还有未被计算的属性  do</span><br><span class="line">	VisitNode(S) 	  /*S是开始符号*/</span><br><span class="line"></span><br><span class="line">procedure VisitNode (N:Node) ;</span><br><span class="line">begin</span><br><span class="line">     if N是一个非终结符 then  /*假设其产生式为N→X1…Xm*/</span><br><span class="line">	     for i :=1 to  m  do</span><br><span class="line">              if XiVN  then /*即Xi是非终结符*/</span><br><span class="line">		         begin</span><br><span class="line">		              计算Xi的所有能够计算的继承属性；</span><br><span class="line">		              VisitNode (Xi)</span><br><span class="line">              end;</span><br><span class="line">     计算N的所有能够计算的综合属性；</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>一遍扫描法：<br>在语法分析的同时计算属性值 </p>
<p>语义规则被计算的时机</p>
<ul>
<li>自上而下分析，一个产生式匹配输入串成功时</li>
<li>自下而上分析，一个产生式被用于进行归约时</li>
</ul>
<h4 id="S-属性文法和L-属性文法"><a href="#S-属性文法和L-属性文法" class="headerlink" title="S-属性文法和L-属性文法"></a>S-属性文法和L-属性文法</h4><p>仅含综合属性的属性文法称为S-属性文法</p>
<p><img src="/images/compileprinciple/image-20220523093848685-16532699290421.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523093848685-16532699290421.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523093848685"></p>
<h4 id="基于S-属性文法的语义计算"><a href="#基于S-属性文法的语义计算" class="headerlink" title="基于S-属性文法的语义计算"></a>基于S-属性文法的语义计算</h4><p>给LR分析栈里头加上一个语义栈</p>
<p><img src="/images/compileprinciple/image-20220523094232788.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523094232788.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523094232788"></p>
<h4 id="基于L-属性文法的语义计算"><a href="#基于L-属性文法的语义计算" class="headerlink" title="基于L-属性文法的语义计算"></a>基于L-属性文法的语义计算</h4><p>上面的树遍历法</p>
<h3 id="基于翻译模式的语义计算"><a href="#基于翻译模式的语义计算" class="headerlink" title="基于翻译模式的语义计算"></a>基于翻译模式的语义计算</h3><h4 id="翻译模式"><a href="#翻译模式" class="headerlink" title="翻译模式"></a>翻译模式</h4><p>属性文法的语义规则：总是放在产生式的尾部<br>翻译模式：把语义规则（也称语义动作），用花括号{ }括起来，插入到产生式右部的合适位置上。进一步细化了语义计算的时机。</p>
<h4 id="基于S-翻译模式的语义计算"><a href="#基于S-翻译模式的语义计算" class="headerlink" title="基于S-翻译模式的语义计算"></a>基于S-翻译模式的语义计算</h4><p>S-翻译模式：仅涉及到综合属性，通常语义动作集置于产生式右端的末尾。常采用LR的自底向上的分析法，和S属性文法类似。</p>
<p>与S-属性文法类似</p>
<ul>
<li>基础文法是LL(1)：自顶向下计算</li>
<li>基础文法是LR系：自底向上计算</li>
</ul>
<h4 id="基于L-翻译模式的自顶向下计算"><a href="#基于L-翻译模式的自顶向下计算" class="headerlink" title="基于L-翻译模式的自顶向下计算"></a>基于L-翻译模式的自顶向下计算</h4><p><img src="/images/compileprinciple/image-20220523094834861.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523094834861.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523094834861"></p>
<ul>
<li>分析程序由一组递归子程序(函数)组成，每个非终结符对应一个子程序</li>
<li>如果非终结符有多个产生式，根据当前符号和SELECT集决定用哪个产生式</li>
<li>从左到右分析符号串，遇到终结符就匹配，遇到非终结符就调用相应的分析子程序</li>
<li>要求基础文法是LL(1)的</li>
</ul>
<h4 id="基于L-翻译模式的自底向上计算"><a href="#基于L-翻译模式的自底向上计算" class="headerlink" title="基于L-翻译模式的自底向上计算"></a>基于L-翻译模式的自底向上计算</h4><p>从翻译模式中删除嵌入在产生式中间的语义动作<br>继承属性的求值结果以综合属性值存放在语义栈中，对继承属性的访问变成对语义栈中某个综合属性的访问<br>模拟继承属性的计算</p>
<p><img src="/images/compileprinciple/image-20220523102243905.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523102243905.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523102243905"></p>
<h2 id="静态语义分析和中间代码生成"><a href="#静态语义分析和中间代码生成" class="headerlink" title="静态语义分析和中间代码生成"></a>静态语义分析和中间代码生成</h2><h3 id="静态语义分析"><a href="#静态语义分析" class="headerlink" title="静态语义分析"></a>静态语义分析</h3><p>类型表达式：</p>
<p>基本类型是类型表达式</p>
<p>若T是类型表达式，I是整数域 (0..5; 1..10), 则Array(I,T) 也是类型表达式</p>
<p>若T是类型表达式，则pointer(T)是类型表达式</p>
<p>……</p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p><img src="/images/compileprinciple/image-20220523110955171.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523110955171.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523110955171"></p>
<h4 id="赋值语句和算术表达式的翻译"><a href="#赋值语句和算术表达式的翻译" class="headerlink" title="赋值语句和算术表达式的翻译"></a>赋值语句和算术表达式的翻译</h4><p>S -&gt; id :&#x3D; E</p>
<p>   语义属性<br>     id.place : id 对应的存储位置<br>     E.place : 用来存放 E 的值的存储单元的地址<br>     E.code :  对E 求值的 TAC 语句序列<br>     S.code :  对应于 S 的 TAC 语句序列 </p>
<p>   语义函数&#x2F;过程<br>     gen() : 生成一条 TAC 语句<br>     newtemp() : 在符号表中新建一个从未使用过的名字，<br>                 并返回该名字的存储位置<br>     || 是TAC 语句序列之间的链接运算 </p>
<p><img src="/images/compileprinciple/image-20220523111750937.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523111750937.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523111750937"></p>
<h4 id="说明语句的翻译"><a href="#说明语句的翻译" class="headerlink" title="说明语句的翻译"></a>说明语句的翻译</h4><p><img src="/images/compileprinciple/image-20220523112337336.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523112337336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523112337336"></p>
<p><img src="/images/compileprinciple/image-20220523112514088.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523112514088.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523112514088"></p>
<p>bool表达式的翻译</p>
<p><img src="/images/compileprinciple/image-20220523112608775.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523112608775.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523112608775"></p>
<h4 id="拉链与代码回填（backpatching）"><a href="#拉链与代码回填（backpatching）" class="headerlink" title="拉链与代码回填（backpatching）"></a>拉链与代码回填（backpatching）</h4><p><img src="/images/compileprinciple/image-20220523112720484.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523112720484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523112720484"></p>
<p><img src="/images/compileprinciple/image-20220523112729649.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523112729649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523112729649"></p>
<p><img src="/images/compileprinciple/image-20220523113011411.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523113011411.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523113011411"></p>
<p><img src="/images/compileprinciple/image-20220523113025922.png" class="lazy" data-srcset="/images/compileprinciple/image-20220523113025922.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220523113025922"></p>
<h2 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h2><h3 id="运行时存储组织概述"><a href="#运行时存储组织概述" class="headerlink" title="运行时存储组织概述"></a>运行时存储组织概述</h3><p><img src="/images/compileprinciple/image-20220609081130115.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609081130115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609081130115"></p>
<h4 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h4><p>数据空间仅需要有静态数据区即可。对于所有数据对象，其分配的存储地址都是相对于静态数据区的偏移量，即登记在符号表中数据对象的地址( .place)属性值。</p>
<p>绝对地址 ＝ 静态数据区首址 + 偏移量</p>
<h4 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h4><ul>
<li>调用子程序时，在栈顶，给子程序分配所需的子程序数据区；</li>
<li>子程序返回时，从栈顶，收回分配给子程序所占用存储区。</li>
<li>当子程序被递归调用时，同一个子程序可能在数据空间中同时拥有多个子程序数据区，每个数据区对应于同一个子程序的一次执行过程。</li>
</ul>
<p>对于所有数据对象，其分配的存储地址都是<strong>相对于数据对象所在的子程序数据区的偏移量</strong>。</p>
<p>栈帧又叫活动记录。</p>
<h4 id="堆式存储分配"><a href="#堆式存储分配" class="headerlink" title="堆式存储分配"></a>堆式存储分配</h4><p>略</p>
<h3 id="活动记录（栈帧）"><a href="#活动记录（栈帧）" class="headerlink" title="活动记录（栈帧）"></a>活动记录（栈帧）</h3><p><img src="/images/compileprinciple/image-20220609082010995.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609082010995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609082010995"></p>
<p>注意：在本题中，int的单元数是1，float的单元数是2！</p>
<p><img src="/images/compileprinciple/image-20220609082230107.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609082230107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609082230107"></p>
<p>嵌套程序块：太难了，感觉不会考</p>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><p>call-by-value ：调用过程计算实参的值，将其放于对应的存储空间，被调用过程执行时，就像使用局部变量一样使用这些形式单元</p>
<p><img src="/images/compileprinciple/image-20220609083150216.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609083150216.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609083150216"></p>
<p>call-by-reference：想想C语言，很直观</p>
<h2 id="代码优化与目标代码生成"><a href="#代码优化与目标代码生成" class="headerlink" title="代码优化与目标代码生成"></a>代码优化与目标代码生成</h2><h3 id="优化技术介绍"><a href="#优化技术介绍" class="headerlink" title="优化技术介绍"></a>优化技术介绍</h3><p>常量折叠：r2 &#x3D; 2 * 3   优化为  r2 &#x3D; 6</p>
<p>常量传播：代入常量</p>
<p>常量传播可能导致分枝判断条件是常量，从而导致分枝的代码不需要执行，这种优化叫做稀疏有条件的常数传播</p>
<p>……略</p>
<h3 id="基本块、流图、循环"><a href="#基本块、流图、循环" class="headerlink" title="基本块、流图、循环"></a>基本块、流图、循环</h3><h4 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h4><p>基本块是一个最大的不可分割的、连续的三地址指令序列，这个块中的指令要么全执行，要么全不执行。</p>
<p>基本块的入口：</p>
<ul>
<li>程序的第1条语句；</li>
<li>(条件&#x2F;无条件)跳转语句的<strong>跳转目标语句</strong>；</li>
<li>条件跳转语句的<strong>下一条语句</strong>；</li>
</ul>
<p>划分基本块的方法如下：</p>
<ul>
<li>依据入口语句定义，确定程序所有的入口语句；</li>
<li>对每一个入口语句，确定对应的基本块。这些基本块是由入口语句向后直到<ul>
<li>转移语句(包括该语句在内)；</li>
<li>或到停止语句；</li>
<li>或到下一个入口语句(不包括该语句)之间的代码段。</li>
</ul>
</li>
<li>凡不属于任何一个基本块的语句都是无用语句，将其全部删除。</li>
</ul>
<h4 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h4><p><img src="/images/compileprinciple/image-20220609085820617.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609085820617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609085820617"></p>
<p>一般把基本块划分和图画到一块（图里头放基本块）</p>
<h4 id="常用优化方法"><a href="#常用优化方法" class="headerlink" title="常用优化方法"></a>常用优化方法</h4><p><strong>删除公共子表达式</strong>(CSE)：如果表达式x op y先前已被计算过，并且从先前的计算到现在，x op y中变量的值没有改变，那么x op y的这次出现就称为公共子表达式</p>
<p>cse可以是基本块内的，也可以是其他基本块的，叫做全局公共子表达式。</p>
<p>删除全局公共子表达式的时候要非常谨慎，因为很有可能在别的块改了值！</p>
<p><strong>删除无用代码</strong>：常用的公共子表达式消除算法会引入一些形如x &#x3D; y的赋值语句，在其之后尽可能地用y代替x，然后就能给删除无用代码带来机会</p>
<p><strong>常量合并</strong>：前面讲了</p>
<p><strong>代码移动</strong>：不管循环执行多少次都得到相同结果的表达式，在进入循环之前就对它们求值</p>
<p><strong>强度削弱</strong>：用较快的操作代替较慢的操作，如用加代替乘</p>
<p><strong>循环</strong>：</p>
<p>在程序流图G中，对于任意一个结点序列α，如果在结点序列<strong>之外存在一个结点</strong>指向<strong>结点序列中的结点</strong>V，或者结点<strong>序列中的结点V是程序首结点</strong>，则称结点V 为结点序列α的入口结点。</p>
<p><img src="/images/compileprinciple/image-20220609092014882.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609092014882.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609092014882"></p>
<p><img src="/images/compileprinciple/image-20220609092046983.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609092046983.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609092046983"></p>
<p>求循环：我感觉这玩意考不了</p>
<h3 id="代码优化技术"><a href="#代码优化技术" class="headerlink" title="代码优化技术"></a>代码优化技术</h3><h4 id="窥孔优化"><a href="#窥孔优化" class="headerlink" title="窥孔优化"></a>窥孔优化</h4><p>删除冗余的存(store)或取(load)操作</p>
<h4 id="局部优化（重点）"><a href="#局部优化（重点）" class="headerlink" title="局部优化（重点）"></a>局部优化（重点）</h4><p><img src="/images/compileprinciple/image-20220609092424634.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609092424634.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609092424634"></p>
<p>对基本块中每一条四元式代码，依次构造对应的DAG图，最后基本块中所有四元式构造出来DAG连成整个基本块的DAG，</p>
<ul>
<li>准备操作数的结点 </li>
<li>常量合并</li>
<li>常量传播</li>
<li>复制传播</li>
<li>删除公共子表达式</li>
<li>删除无用赋值(死代码)</li>
</ul>
<h4 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h4><p>对循环中的代码，可以实行</p>
<ul>
<li>代码外提</li>
<li>归纳变量强度消弱</li>
<li>删除归纳变量(变换循环控制条件)</li>
<li>循环展开</li>
<li>循环合并</li>
</ul>
<h3 id="目标代码生成技术"><a href="#目标代码生成技术" class="headerlink" title="目标代码生成技术"></a>目标代码生成技术</h3><p><img src="/images/compileprinciple/image-20220609093528334.png" class="lazy" data-srcset="/images/compileprinciple/image-20220609093528334.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220609093528334"></p>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2024-01-27</p></div> 
    <div class="post-entry__tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" class="post-tags__link button"># 笔记</a><a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" class="post-tags__link button"># 编译原理</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2022/05/29/course/database/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            数据库笔记
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2022/02/01/language_notes/cpptopiclearning/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            C++ 专题学习
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2017&nbsp;-&nbsp;2024 <a href="/">怀中落霞</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 


    <script>
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
                loader: {
                    source: {
                        '[tex]/amsCd': '[tex]/amscd',
                        '[tex]/AMScd': '[tex]/amscd'
                    }
                },
                tex: {
                    inlineMath: {'[+]': [['$', '$']]},
                    tags: 'ams'
                },
                options: {
                    renderActions: {
                        findScript: [10, doc => {
                            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                                const display = !!node.type.match(/; *mode=display/);
                                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                                const text = document.createTextNode('');
                                node.parentNode.replaceChild(text, node);
                                math.start = {node: text, delim: '', n: 0};
                                math.end = {node: text, delim: '', n: 0};
                                doc.math.push(math);
                            });
                        }, '', false],
                        insertedScript: [200, () => {
                            document.querySelectorAll('mjx-container').forEach(node => {
                                let target = node.parentNode;
                                if (target.nodeName.toLowerCase() === 'li') {
                                    target.parentNode.classList.add('has-jax');
                                }
                            });
                        }, '', false]
                    }
                }
            };
            (function () {
                var script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
                script.defer = true;
                document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    </script>

 

 

 

 




    </body>
</html>
