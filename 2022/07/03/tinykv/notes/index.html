<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/images/icons/favicon.ico">
    
    
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/logo.png">
    
    


    <!-- meta -->


<title>TinyKV 课程报告 | 怀中落霞</title>


    <meta name="keywords" content="Raft, TinyKV, 分布式">




    <!-- OpenGraph -->
 
    <meta name="description" content="代码在 https:&#x2F;&#x2F;github.com&#x2F;poorpool&#x2F;tinykv ，96.1分。">
<meta property="og:type" content="article">
<meta property="og:title" content="TinyKV 课程报告">
<meta property="og:url" content="https://poorpool.github.io/2022/07/03/tinykv/notes/index.html">
<meta property="og:site_name" content="怀中落霞">
<meta property="og:description" content="代码在 https:&#x2F;&#x2F;github.com&#x2F;poorpool&#x2F;tinykv ，96.1分。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://poorpool.github.io/images/tinykv/2-scores.png">
<meta property="og:image" content="https://poorpool.github.io/images/tinykv/1-peer_and_region.png">
<meta property="article:published_time" content="2022-07-03T14:31:00.000Z">
<meta property="article:modified_time" content="2024-05-28T05:20:26.937Z">
<meta property="article:author" content="poorpool">
<meta property="article:tag" content="Raft">
<meta property="article:tag" content="TinyKV">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://poorpool.github.io/images/tinykv/2-scores.png">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/a11y-light.css" media="none" onload="this.media='all'">
        
    

    
    

    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="怀中落霞" type="application/atom+xml">
</head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">怀中落霞</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/categories/" class="navbar-menu button">分类</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/links/" class="navbar-menu button">友链</a>
                
                    <a href="/about/" class="navbar-menu button">关于</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/categories/" class="dropdown-menu button">分类</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/links/" class="dropdown-menu button">友链</a>
                
                    <a href="/about/" class="dropdown-menu button">关于</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        TinyKV 课程报告
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2022/07/" class="post-meta__date button">2022-07-03</a>
        
    <span class="separate-dot"></span><a href="/categories/%E7%AC%94%E8%AE%B0/" class="button">笔记</a>

 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E7%A8%8B%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">日程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-1"><span class="toc-number">2.</span> <span class="toc-text">project 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-2"><span class="toc-number">3.</span> <span class="toc-text">project 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2a"><span class="toc-number">3.1.</span> <span class="toc-text">project 2a</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#project-2aa%E3%80%812ab"><span class="toc-number">3.1.1.</span> <span class="toc-text">project 2aa、2ab</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E8%B5%B7%E6%9D%A5%E7%9C%8B"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">连起来看</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%A5%A5%E4%B9%89"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">重构奥义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9-append-no-op-entry-%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">对 append no-op entry 的思考</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%94%B6%E5%88%B0%E5%85%B6%E4%BB%96%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">对收到其他任期的消息的思考</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">其他小问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#project-2ac"><span class="toc-number">3.1.2.</span> <span class="toc-text">project 2ac</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2b"><span class="toc-number">3.2.</span> <span class="toc-text">project 2b</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">结构体关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler-%E7%9A%84-proposeRaftCommand"><span class="toc-number">3.2.2.</span> <span class="toc-text">peer_msg_handler 的 proposeRaftCommand()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler-%E7%9A%84-HandleRaftReady"><span class="toc-number">3.2.3.</span> <span class="toc-text">peer_msg_handler 的 HandleRaftReady()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage-SaveReadyState"><span class="toc-number">3.2.4.</span> <span class="toc-text">peer_storage SaveReadyState()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage-Append"><span class="toc-number">3.2.5.</span> <span class="toc-text">peer_storage Append()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#firstIndex-%E4%B8%8D%E4%BB%8E-0-%E5%BC%80%E5%A7%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">firstIndex 不从 0 开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peers-%E9%94%99%E8%AF%AF"><span class="toc-number">3.2.7.</span> <span class="toc-text">peers 错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84-fail"><span class="toc-number">3.2.8.</span> <span class="toc-text">莫名其妙的 fail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getWrongValue-%E4%BB%A5%E5%8F%8A-CmdType-%E9%94%99%E8%AF%AF"><span class="toc-number">3.2.9.</span> <span class="toc-text">getWrongValue 以及 CmdType 错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B4%A9%E6%BA%83%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.10.</span> <span class="toc-text">从崩溃中恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2c"><span class="toc-number">3.3.</span> <span class="toc-text">project 2c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">RaftLog 的改动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raft-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.3.2.</span> <span class="toc-text">raft 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage"><span class="toc-number">3.3.3.</span> <span class="toc-text">peer_storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler"><span class="toc-number">3.3.4.</span> <span class="toc-text">peer_msg_handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-3"><span class="toc-number">4.</span> <span class="toc-text">project 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3a"><span class="toc-number">4.1.</span> <span class="toc-text">project 3a</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E4%BA%BA%E7%A6%85%E8%AE%A9"><span class="toc-number">4.1.1.</span> <span class="toc-text">领导人禅让</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">增删节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3b"><span class="toc-number">4.2.</span> <span class="toc-text">project 3b</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">4.2.1.</span> <span class="toc-text">配置变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#region-split"><span class="toc-number">4.2.2.</span> <span class="toc-text">region split</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#meta-corruption-detected-%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">meta corruption detected 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E8%8A%82%E7%82%B9%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.4.</span> <span class="toc-text">增删节点导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proposal-%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.5.</span> <span class="toc-text">proposal 导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storeMeta-%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.6.</span> <span class="toc-text">storeMeta 导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#no-region-%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.7.</span> <span class="toc-text">no region 问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3c"><span class="toc-number">4.3.</span> <span class="toc-text">project 3c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-4"><span class="toc-number">5.</span> <span class="toc-text">project 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4a"><span class="toc-number">5.1.</span> <span class="toc-text">4a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-4b-4c"><span class="toc-number">5.2.</span> <span class="toc-text">project 4b 4c</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E7%A8%8B%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">日程表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-1"><span class="toc-number">2.</span> <span class="toc-text">project 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-2"><span class="toc-number">3.</span> <span class="toc-text">project 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2a"><span class="toc-number">3.1.</span> <span class="toc-text">project 2a</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#project-2aa%E3%80%812ab"><span class="toc-number">3.1.1.</span> <span class="toc-text">project 2aa、2ab</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E8%B5%B7%E6%9D%A5%E7%9C%8B"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">连起来看</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%9E%84%E5%A5%A5%E4%B9%89"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">重构奥义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9-append-no-op-entry-%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">对 append no-op entry 的思考</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%94%B6%E5%88%B0%E5%85%B6%E4%BB%96%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">对收到其他任期的消息的思考</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">其他小问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#project-2ac"><span class="toc-number">3.1.2.</span> <span class="toc-text">project 2ac</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2b"><span class="toc-number">3.2.</span> <span class="toc-text">project 2b</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">结构体关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler-%E7%9A%84-proposeRaftCommand"><span class="toc-number">3.2.2.</span> <span class="toc-text">peer_msg_handler 的 proposeRaftCommand()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler-%E7%9A%84-HandleRaftReady"><span class="toc-number">3.2.3.</span> <span class="toc-text">peer_msg_handler 的 HandleRaftReady()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage-SaveReadyState"><span class="toc-number">3.2.4.</span> <span class="toc-text">peer_storage SaveReadyState()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage-Append"><span class="toc-number">3.2.5.</span> <span class="toc-text">peer_storage Append()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#firstIndex-%E4%B8%8D%E4%BB%8E-0-%E5%BC%80%E5%A7%8B"><span class="toc-number">3.2.6.</span> <span class="toc-text">firstIndex 不从 0 开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peers-%E9%94%99%E8%AF%AF"><span class="toc-number">3.2.7.</span> <span class="toc-text">peers 错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84-fail"><span class="toc-number">3.2.8.</span> <span class="toc-text">莫名其妙的 fail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getWrongValue-%E4%BB%A5%E5%8F%8A-CmdType-%E9%94%99%E8%AF%AF"><span class="toc-number">3.2.9.</span> <span class="toc-text">getWrongValue 以及 CmdType 错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B4%A9%E6%BA%83%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.10.</span> <span class="toc-text">从崩溃中恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-2c"><span class="toc-number">3.3.</span> <span class="toc-text">project 2c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">RaftLog 的改动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raft-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.3.2.</span> <span class="toc-text">raft 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-storage"><span class="toc-number">3.3.3.</span> <span class="toc-text">peer_storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peer-msg-handler"><span class="toc-number">3.3.4.</span> <span class="toc-text">peer_msg_handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-3"><span class="toc-number">4.</span> <span class="toc-text">project 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3a"><span class="toc-number">4.1.</span> <span class="toc-text">project 3a</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E4%BA%BA%E7%A6%85%E8%AE%A9"><span class="toc-number">4.1.1.</span> <span class="toc-text">领导人禅让</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E8%8A%82%E7%82%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">增删节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3b"><span class="toc-number">4.2.</span> <span class="toc-text">project 3b</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">4.2.1.</span> <span class="toc-text">配置变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#region-split"><span class="toc-number">4.2.2.</span> <span class="toc-text">region split</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#meta-corruption-detected-%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">meta corruption detected 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E8%8A%82%E7%82%B9%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.4.</span> <span class="toc-text">增删节点导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proposal-%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.5.</span> <span class="toc-text">proposal 导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storeMeta-%E5%AF%BC%E8%87%B4%E7%9A%84-request-timeout"><span class="toc-number">4.2.6.</span> <span class="toc-text">storeMeta 导致的 request timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#no-region-%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.7.</span> <span class="toc-text">no region 问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-3c"><span class="toc-number">4.3.</span> <span class="toc-text">project 3c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#project-4"><span class="toc-number">5.</span> <span class="toc-text">project 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4a"><span class="toc-number">5.1.</span> <span class="toc-text">4a</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project-4b-4c"><span class="toc-number">5.2.</span> <span class="toc-text">project 4b 4c</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>代码在 <a target="_blank" rel="noopener" href="https://github.com/poorpool/tinykv">https://github.com/poorpool/tinykv</a> ，96.1分。</p>
<span id="more"></span>

<p><img src="/images/tinykv/2-scores.png" class="lazy" data-srcset="/images/tinykv/2-scores.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="img"></p>
<p>因为我电脑的 tmpfs 不够大，我在 kv&#x2F;test_raftstore&#x2F;cluster.go:61 中把测试目录设置在 &#x2F;home&#x2F;poorpool&#x2F;tinykvtmp 了，提交的时候我把它给删了。如果要想在个人笔记本上跑，可能要这么设置一下，PingCAP 评测的时候应该不需要。</p>
<p>1 2a 2b 2c 3a 3c 4a 4b 4c 一定可以一次跑通，3b 有15%的概率会 fail 一个点，85%的概率一次跑通</p>
<h2 id="日程表"><a href="#日程表" class="headerlink" title="日程表"></a>日程表</h2><p>说明：我以前做过一遍 TinyKV，对 Raft 和 Percolator 也有一定的了解。这次是为了拿 TinyKV 抵学校的系统能力综合培养，所以重做了一遍，整洁了代码，整洁了逻辑。</p>
<p>下面的时间是我这一次的耗时，如果算上我以前做第一次的时间，总耗时大概在 25 个整天。</p>
<p>20220702 下载项目，完成 1</p>
<p>20220703 完成 2aa，2ab，但是后面一直在实习，没时间写，忘差不多了</p>
<p>20220808 因为以前写的太糟糕，把代码删了重写，完成了 2aa</p>
<p>20220809 完成了 2ab、2ac</p>
<p>20220810-11 重构代码，加注释，补充 2a 笔记</p>
<p>20220812 阅读 2b 文档，完成代码，能通过 2b 一半的测试</p>
<p>20220813 能通过另一半的测试，完善 2b 笔记，优化 2b 代码；开始写 2c</p>
<p>20220814 完成 2c，完成 3a，完成 3b（留下了一些 bug）</p>
<p>20220815 调 3b bug，进行批量测试，虽然不能 100% 跑过，但是差不多了。休息</p>
<p>20220816 完善 2c 3a 3b 文档，完成 3c</p>
<p>20220817 完善 3c 4a 4b 4c 文档</p>
<h2 id="project-1"><a href="#project-1" class="headerlink" title="project 1"></a>project 1</h2><p>要支持四个基本的操作 Put&#x2F;Delete&#x2F;Get&#x2F;Scan，键是key+column。</p>
<p>程序入口在 kv&#x2F;main.go，会根据是否 raft 来决定使用 raft_storage 还是 standalone_storage（本节内容），最终提供一个 grpc 服务，定义在 proto&#x2F;proto&#x2F;tinykvpb.proto proto&#x2F;proto&#x2F;kvrpcpb.proto 中。</p>
<p>需要实现的文件在 <code>kv/storage/standalone_storage/standalone_storage.go</code></p>
<p>要实现的接口 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Other stuffs</span></span><br><span class="line">    Write(ctx *kvrpcpb.Context, batch []Modify) <span class="type">error</span></span><br><span class="line">    Reader(ctx *kvrpcpb.Context) (StorageReader, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StandAloneReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	txn *badger.Txn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StandAloneStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *badger.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部维护一个 badger db，使用 engine_util 中的 CreateDB。写的时候将 <code>[]storage.Modify</code> 转换为 engine_util.WriteBatch，读的时候获取 badger 事务调用 engine_util 中的函数即可。注意读要求一致性所以要开事务，最后记得 Discard</p>
<h2 id="project-2"><a href="#project-2" class="headerlink" title="project 2"></a>project 2</h2><h3 id="project-2a"><a href="#project-2a" class="headerlink" title="project 2a"></a>project 2a</h3><p>因为一年半以前写过一次 TinyKv，所以这次把 raft 论文复习了一遍直接就开始写了。写之前看一下网上对 etcd raft 实现的分析，可以学到很多思路。</p>
<h4 id="project-2aa、2ab"><a href="#project-2aa、2ab" class="headerlink" title="project 2aa、2ab"></a>project 2aa、2ab</h4><h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>首先最好具备优雅地打印日志的能力，比如用一个开关控制自己的日志是否打印。我在 log&#x2F;log.go 中写了一个 DInfo 函数，由 debugSwitch 控制调试输出，并且因为打印到文件里头，可选地关掉了日志高亮。最好是一开始就能打好日志，后面调试才方便。</p>
<h5 id="连起来看"><a href="#连起来看" class="headerlink" title="连起来看"></a>连起来看</h5><p>2aa 实现了领导人选举，2ab 实现了日志复制，但是它们的边界其实没有特别清楚，比如说领导人选举的时候，要确保自己的日志是比较新的，所以两部分会有一点重合。如果按照测试写过去，容易出现 2ab 过了但是 2aa 挂了的问题。因此两个最好连起来看。</p>
<p>我记得我就是完成了 2ab 以后发现 TestLeaderCycle2aa过不了，打印日志，发现测试里有三个人轮流选举当 leader 的过程，1 可以获得 1 2 3 的支持，2 可以获得 2 3 的支持，3 只能得到自己的支持。原因是 3 的日志不够新，追溯日志，是我本来在 becomeLeader 里头添加 no-op 日志条目却没有把他们 append 出去，导致日志不是最新的。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>在创建 RaftLog、Raft 的时候，要注意恢复 hardState，正确地处理好各个值的初始化问题。我印象比较深刻的有：</p>
<ul>
<li>从 HardState 中恢复 term vote commit</li>
<li>创建的时候不要调用 becomeFollower 把 vote 信息给覆盖了，，，</li>
<li>不要漏了 config 中的 applied，感觉是后面才会用到，这里容易忽略掉</li>
<li>commit stabled 这些都是 index，不是数组下标</li>
</ul>
<h5 id="重构奥义"><a href="#重构奥义" class="headerlink" title="重构奥义"></a>重构奥义</h5><p>我记得我第一次写 TinyKV 的时候，raft.go 一个文件一千多行，函数乱飞，翻起来都不好翻，日志也不好打。这次我吸取上一次的教训，立志精进代码风格：</p>
<ul>
<li>把 raft.go 拆了<ul>
<li>raft.go 处理创建、状态转换、消息分发给处理函数</li>
<li>raft_sender.go 发消息，每个 MessageType 写一个函数，最终统一调用 send() 来发消息，这样能够统一打日志（非常关键）</li>
<li>raft_handler.go 用来处理收到的信息</li>
</ul>
</li>
<li>函数摆好顺序，按照 MessageType 排序，工具函数放在调用函数的前头一眼就能看见</li>
<li>注释！注释！注释！</li>
<li>不要追求速度，写完以后重构代码，细化不合理的地方，完善文档。不要像拖拉机一样坑吭吭吭就往下写</li>
</ul>
<p>下面主要写一下遇到的问题和思考。raft 流程网上已经很充分了。</p>
<h5 id="对-append-no-op-entry-的思考"><a href="#对-append-no-op-entry-的思考" class="headerlink" title="对 append no-op entry 的思考"></a>对 append no-op entry 的思考</h5><p>raft 要求 leader 不能提交之前任期的日志条目，或者说，提交的日志条目必须包含自己的任期，再说得清楚一些，提交的日志条目必须包含当前最新的任期（raft 论文有很好的例子）。为了在本任期没有收到同步请求的情况下也要能提交之前的日志，应当在成为 leader 的时候立刻 propose 一个空条目并 append 下去。</p>
<h5 id="对收到其他任期的消息的思考"><a href="#对收到其他任期的消息的思考" class="headerlink" title="对收到其他任期的消息的思考"></a>对收到其他任期的消息的思考</h5><p>过期消息直接丢弃即可（但是返回一个 response 提示它过期了会不会更好一些）</p>
<p>对于来自大任期的消息，不能简单地接受领导，只有他明确说明自己是领导，才接受。我以前想出来一个很好的例子：1 2 | 3 隔离，1 term 6 leader, 3 term 7 candidate 。解除隔离以后，1 收到了 3 的请求投票 rpc，要更新自己的任期，但是不能接受对方的领导。只有明确声明自己是领导才承认，即 Append 和 Heartbeat</p>
<h5 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h5><ul>
<li>leader 收到同任期 candidate 投票请求也要投拒绝票，而不是 drop message</li>
<li>append 日志的时候有很多细节要想清楚，例如 leader.commit &gt; my.commit 时， commit &#x3D; min(leader.commit, leader 给我的 lastIndex（不是我的最后一个 lastIndex）)，因为你返回的 match 不可以比 leader 现在 lastIndex 还大</li>
<li>收到心跳要发回复，收到心跳回复要检查 progress 并确定要不要发 append</li>
<li>commit 增加了，才广播 append</li>
</ul>
<h4 id="project-2ac"><a href="#project-2ac" class="headerlink" title="project 2ac"></a>project 2ac</h4><p>稍微简单一些，实现 raft 的上层节点 RawNode，返回 Ready，代表上次处理完 Ready 以后和这次的更改。为此要保存下来之前的 SoftState 和 HardState。在返回新 Ready 时，如果 SoftState 和以前的不一样，才返回有值的 SoftState，否则返回空。</p>
<p>出 Ready 时，还会清空消息。Advance 更新 RawNode 的各种 State，处理日志 stabled applied</p>
<h3 id="project-2b"><a href="#project-2b" class="headerlink" title="project 2b"></a>project 2b</h3><p>从 2b 开始，文档、测试和实现之间的 gap 就有点大了。有两个文档很推荐看，不要闭门造车，要见贤思齐（不是抄袭）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/talent-plan-tinykv-white-paper">TinyKV 白皮书（力荐）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/LX-676655103/Tinykv-2021/blob/course/doc/project2.md">一个学长写的笔记（也很好）</a></li>
</ul>
<p>这一章最终要体现在 kv&#x2F;raftstore&#x2F;peer_storage.go kv&#x2F;raftstore&#x2F;peer_msg_handler.go，代码是在这两个文件里头写的。并且很有可能返工修改 2a。</p>
<h4 id="结构体关系"><a href="#结构体关系" class="headerlink" title="结构体关系"></a>结构体关系</h4><p>首先了解一下这些结构体的相互关系：</p>
<p><img src="/images/tinykv/1-peer_and_region.png" class="lazy" data-srcset="/images/tinykv/1-peer_and_region.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="peer_and_region"></p>
<p>上面这一串，整体是作为 RaftStorage，RaftStorage 实现了我们在实验一里头实现的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start() <span class="type">error</span></span><br><span class="line">	Stop() <span class="type">error</span></span><br><span class="line">	Write(ctx *kvrpcpb.Context, batch []Modify) <span class="type">error</span></span><br><span class="line">	Reader(ctx *kvrpcpb.Context) (StorageReader, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StorageReader <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// When the key doesn&#x27;t exist, return nil for the value</span></span><br><span class="line">	GetCF(cf <span class="type">string</span>, key []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">	IterCF(cf <span class="type">string</span>) engine_util.DBIterator</span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它收到请求以后，会一通分发，进入 peer_msg_handler 处理消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> peerMsgHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	*peer</span><br><span class="line">	ctx *GlobalContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>peerMsgHandler 基于 peer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> proposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// index + term for unique identification</span></span><br><span class="line">	index     <span class="type">uint64</span></span><br><span class="line">	term      <span class="type">uint64</span></span><br><span class="line">	cb        *message.Callback</span><br><span class="line">	startTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> peer <span class="keyword">struct</span> &#123;</span><br><span class="line">	ticker *ticker</span><br><span class="line">    RaftGroup *raft.RawNode</span><br><span class="line">	peerStorage *PeerStorage</span><br><span class="line">	Meta     *metapb.Peer</span><br><span class="line">	regionId <span class="type">uint64</span></span><br><span class="line">	Tag <span class="type">string</span></span><br><span class="line">	proposals []*proposal</span><br><span class="line">	LastCompactedIdx <span class="type">uint64</span></span><br><span class="line">	peerCache <span class="keyword">map</span>[<span class="type">uint64</span>]*metapb.Peer</span><br><span class="line">	PeersStartPendingTime <span class="keyword">map</span>[<span class="type">uint64</span>]time.Time</span><br><span class="line">	stopped <span class="type">bool</span></span><br><span class="line">	SizeDiffHint <span class="type">uint64</span></span><br><span class="line">	ApproximateSize *<span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里头还有一个 metapb.Peer，存放了 peer id 和 store id。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> metapb;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Peer</span> &#123;      </span><br><span class="line">    <span class="type">uint64</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64</span> store_id = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到刚才说的 peer，它有一个 RaftGroup，意味着它就是 raft 中的一个节点。这个节点的 Storage，就是 PeerStorage：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PeerStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">	region *metapb.Region</span><br><span class="line">	raftState *rspb.RaftLocalState</span><br><span class="line">	applyState *rspb.RaftApplyState</span><br><span class="line">	snapState snap.SnapState</span><br><span class="line">	regionSched <span class="keyword">chan</span>&lt;- worker.Task</span><br><span class="line">	snapTriedCnt <span class="type">int</span></span><br><span class="line">	Engines *engine_util.Engines</span><br><span class="line">	Tag <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">HardState</span> &#123;</span><br><span class="line">  <span class="type">uint64</span> term = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64</span> vote = <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint64</span> commit = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RaftLocalState</span> &#123;</span><br><span class="line">    eraftpb.HardState hard_state = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64</span> last_index = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint64</span> last_term = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RaftApplyState</span> &#123;</span><br><span class="line">    <span class="type">uint64</span> applied_index = <span class="number">1</span>;</span><br><span class="line">    RaftTruncatedState truncated_state = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PeerStorage 实现了我们在 Raft 中的 Storage 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">	InitialState() (pb.HardState, pb.ConfState, <span class="type">error</span>)</span><br><span class="line">	Entries(lo, hi <span class="type">uint64</span>) ([]pb.Entry, <span class="type">error</span>)</span><br><span class="line">	Term(i <span class="type">uint64</span>) (<span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">	LastIndex() (<span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">	FirstIndex() (<span class="type">uint64</span>, <span class="type">error</span>)</span><br><span class="line">	Snapshot() (pb.Snapshot, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peer-msg-handler-的-proposeRaftCommand"><a href="#peer-msg-handler-的-proposeRaftCommand" class="headerlink" title="peer_msg_handler 的 proposeRaftCommand()"></a>peer_msg_handler 的 proposeRaftCommand()</h4><p>注意：这里和后面的代码都是经过摘取的，真实的代码中肯定还包含了错误校验等一系列其他繁琐的事情。</p>
<p>上面提到了，读写请求最后都会到达 proposeRaftCommand，在这个函数中把读写请求序列化作为一条日志条目 propose 进 Raft，让它去 append、commit、apply。我们要等日志 apply 的时候才能返回给客户端 response。考虑到 apply 的时候也是在这个 peer_msg_handler 里面，我们给他维护一个 proposal 结构，能够得到日志条目和回调的对应关系。</p>
<p>也就是说，我们在这个函数里干的事情主要是（省略了错误处理）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data, err := msg.Marshal()</span><br><span class="line">d.appendProposal(d.nextProposalIndex(), d.Term(), cb)</span><br><span class="line">err = d.RaftGroup.Propose(data)</span><br></pre></td></tr></table></figure>

<p>代码都比较好理解。appendProposal 是我自己写的记录回调的函数，理论上来说应该使用日志条目 index 和 term，但是在 raft 之外的上层无法取得，我们直接取最后一条日志后面的 index 就好：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span></span> nextProposalIndex() <span class="type">uint64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.RaftGroup.Raft.RaftLog.LastIndex() + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加回调是一个麻烦的事情，因为我们都知道并不是 propose 了的日志条目就会被 commit 被 apply，有可能被覆盖掉。我们希望 proposal 数组里头也要像日志数组里头一样干干净净，index 递增，就要在增加 proposal 的时候删除冲突的日志条目，也就是 index 大于等于当前 proposal.index 的条目都删除掉。 当然，这里不能直接删除，要把要被删除的回调都返回一个 ErrRespStaleCommand，可以理解为要求客户端重试的统一回复。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> appendProposal(index <span class="type">uint64</span>, term <span class="type">uint64</span>, cb *message.Callback) &#123;</span><br><span class="line">	<span class="comment">// 希望达到 index 单增</span></span><br><span class="line">	p := &amp;proposal&#123;</span><br><span class="line">		index:     index,</span><br><span class="line">		term:      term,</span><br><span class="line">		cb:        cb,</span><br><span class="line">		startTime: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(d.peer.proposals) == <span class="number">0</span> &#123;</span><br><span class="line">		d.peer.proposals = <span class="built_in">append</span>(d.peer.proposals, p)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index &gt;= d.peer.proposals[<span class="number">0</span>].index &#123;</span><br><span class="line">		off := index - d.peer.proposals[<span class="number">0</span>].index</span><br><span class="line">		<span class="keyword">if</span> off &lt;= <span class="type">uint64</span>(<span class="built_in">len</span>(d.peer.proposals)) &#123;</span><br><span class="line">			<span class="keyword">for</span> _, v := <span class="keyword">range</span> d.peer.proposals[off:] &#123;</span><br><span class="line">				v.cb.Done(ErrRespStaleCommand(d.Term()))</span><br><span class="line">			&#125;</span><br><span class="line">			d.peer.proposals = d.peer.proposals[:off]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d.peer.proposals = <span class="built_in">append</span>(d.peer.proposals, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peer-msg-handler-的-HandleRaftReady"><a href="#peer-msg-handler-的-HandleRaftReady" class="headerlink" title="peer_msg_handler 的 HandleRaftReady()"></a>peer_msg_handler 的 HandleRaftReady()</h4><p>Raft 消息的最终宿命是被丢掉或者被 apply，apply 等一系列变化会体现在 Ready 中，处理的函数就是 HandleRaftReady()，它的流程大概如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> HandleRaftReady() &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> !d.peer.RaftGroup.HasReady() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	ready := d.peer.RaftGroup.Ready()</span><br><span class="line">	</span><br><span class="line">	result, err := d.peer.peerStorage.SaveReadyState(&amp;ready)</span><br><span class="line">	<span class="comment">// 暂时不关注这个 Result</span></span><br><span class="line">	d.Send(d.ctx.trans, ready.Messages)</span><br><span class="line">	<span class="keyword">for</span> _, entry := <span class="keyword">range</span> ready.CommittedEntries &#123;</span><br><span class="line">		kvWb := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">		d.applyRaftLog(entry, kvWb)</span><br><span class="line">		d.peerStorage.applyState.AppliedIndex = entry.Index</span><br><span class="line">		err = kvWb.SetMeta(meta.ApplyStateKey(d.regionId), d.peerStorage.applyState)</span><br><span class="line">		err = d.peerStorage.Engines.WriteKV(kvWb)</span><br><span class="line">		<span class="keyword">if</span> d.stopped &#123;</span><br><span class="line">		    WB := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">		    WB.DeleteMeta(meta.ApplyStateKey(d.regionId))</span><br><span class="line">		    err = d.peerStorage.Engines.WriteKV(WB)</span><br><span class="line">		    <span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d.peer.RaftGroup.Advance(ready)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它首先调用 peer_storage 的 SaveReadyState() 保存 raft 日志、HardState 等状态，然后把消息发送出去</p>
<blockquote>
<p>hint：使用 GlobalContext 中的 Transport 来发送 Raft消息</p>
</blockquote>
<p>接下来轮番应用日志，并且及时更新 ApplyState（后面停机了删除 ApplyState 的代码我忘了是哪一部分引入的了，也贴上来）</p>
<blockquote>
<p>hint: 应用每一条日志都要赶快更新、持久化 ApplyState，不然会造成数据不一致<br>hint: 使用 WriteBatch 来确保写入一致性，例如，使用一个 kvWb 来同时保存 key-value 更新和 applyState 的更新</p>
</blockquote>
<p>应用普通日志的代码：</p>
<blockquote>
<p>hint: 找不到回调也要 apply</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> applyNormalRequest(msg *raft_cmdpb.RaftCmdRequest,</span><br><span class="line">	entry pb.Entry, kvWb *engine_util.WriteBatch) &#123;</span><br><span class="line"></span><br><span class="line">	resp := &amp;raft_cmdpb.RaftCmdResponse&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	p := d.findProposal(entry.Index, entry.Term)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> msg.Requests &#123;</span><br><span class="line">		<span class="keyword">switch</span> v.CmdType &#123;</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Get:</span><br><span class="line">			ans, err := engine_util.GetCF(d.peerStorage.Engines.Kv, v.Get.Cf, v.Get.Key)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                    p.cb.Done(ErrResp(err))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;</span><br><span class="line">				CmdType: raft_cmdpb.CmdType_Get,</span><br><span class="line">				Get: &amp;raft_cmdpb.GetResponse&#123;</span><br><span class="line">					Value: ans,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Put:</span><br><span class="line">			kvWb.SetCF(v.Put.Cf, v.Put.Key, v.Put.Value)</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;</span><br><span class="line">				CmdType: raft_cmdpb.CmdType_Put,</span><br><span class="line">				Put:     &amp;raft_cmdpb.PutResponse&#123;&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Delete:</span><br><span class="line">			kvWb.DeleteCF(v.Delete.Cf, v.Delete.Key)</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;</span><br><span class="line">				CmdType: raft_cmdpb.CmdType_Delete,</span><br><span class="line">				Delete:  &amp;raft_cmdpb.DeleteResponse&#123;&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="keyword">case</span> raft_cmdpb.CmdType_Snap:</span><br><span class="line">			resp.Responses = <span class="built_in">append</span>(resp.Responses, &amp;raft_cmdpb.Response&#123;</span><br><span class="line">				CmdType: raft_cmdpb.CmdType_Snap,</span><br><span class="line">				Snap: &amp;raft_cmdpb.SnapResponse&#123;</span><br><span class="line">					Region: d.Region(),</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.cb.Txn = d.peerStorage.Engines.Kv.NewTransaction(<span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">		p.cb.Done(resp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hint: snap 请求回调应该设置事务 Transaction 为 false</p>
</blockquote>
<p>应用普通日志的时候，要查找回调，即顺着 proposal 数组查找到自己要的 index，并且删除没有用的回调。一定要记住，日志的匹配要求 index 和 term 都匹配：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> findProposal(index <span class="type">uint64</span>, term <span class="type">uint64</span>) *proposal &#123;</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(d.proposals) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p := d.proposals[<span class="number">0</span>]</span><br><span class="line">		d.proposals = d.proposals[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">if</span> p.index &lt; index &#123;</span><br><span class="line">			NotifyStaleReq(d.Term(), p.cb)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> p.index == index &#123;</span><br><span class="line">			<span class="keyword">if</span> p.term != term &#123;</span><br><span class="line">				NotifyStaleReq(d.Term(), p.cb)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> p</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peer-storage-SaveReadyState"><a href="#peer-storage-SaveReadyState" class="headerlink" title="peer_storage SaveReadyState()"></a>peer_storage SaveReadyState()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> SaveReadyState(ready *raft.Ready) (*ApplySnapResult, <span class="type">error</span>) &#123;</span><br><span class="line">	raftWb := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">    ps.Append(ready.Entries, raftWb) <span class="comment">// 注意：这里可能会改变 raftState</span></span><br><span class="line">	<span class="keyword">if</span> !raft.IsEmptyHardState(ready.HardState) &#123;</span><br><span class="line">		ps.raftState.HardState = &amp;ready.HardState</span><br><span class="line">	&#125;</span><br><span class="line">	raftWb.SetMeta(meta.RaftStateKey(ps.region.Id), ps.raftState)</span><br><span class="line">	ps.Engines.WriteRaft(raftWb)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略了对 snapshot 的处理，这是 2c 的部分了。我们回顾一下 Ready 的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SoftState <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lead      <span class="type">uint64</span></span><br><span class="line">    RaftState StateType</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Ready <span class="keyword">struct</span> &#123;</span><br><span class="line">	*SoftState</span><br><span class="line">	pb.HardState</span><br><span class="line">	Entries []pb.Entry</span><br><span class="line">	Snapshot pb.Snapshot</span><br><span class="line">	CommittedEntries []pb.Entry</span><br><span class="line">	Messages []pb.Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message、CommittedEntries 不是要保存的内容，因此只有 HardState Entries 需要保存。</p>
<h4 id="peer-storage-Append"><a href="#peer-storage-Append" class="headerlink" title="peer_storage Append()"></a>peer_storage Append()</h4><p>Append 函数保存日志。</p>
<p>回忆一下这个表格：</p>
<table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">KeyFormat</th>
<th align="left">Value</th>
<th align="left">DB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">raft_log_key</td>
<td align="left">0x01 0x02 region_id 0x01 log_idx</td>
<td align="left">Entry</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">raft_state_key</td>
<td align="left">0x01 0x02 region_id 0x02</td>
<td align="left">RaftLocalState</td>
<td align="left">raft</td>
</tr>
<tr>
<td align="left">apply_state_key</td>
<td align="left">0x01 0x02 region_id 0x03</td>
<td align="left">RaftApplyState</td>
<td align="left">kv</td>
</tr>
<tr>
<td align="left">region_state_key</td>
<td align="left">0x01 0x03 region_id 0x01</td>
<td align="left">RegionLocalState</td>
<td align="left">kv</td>
</tr>
</tbody></table>
<p>日志条目和 RaftLocalState 状态都存在 raftDB 里面，和上面的kvDB一样，都是一个单机数据库。</p>
<p>根据提示，保存日志要分三步走：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> Append(entries []eraftpb.Entry, raftWB *engine_util.WriteBatch) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2B).</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(entries) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	prevLastIndex, err := ps.LastIndex()</span><br><span class="line">	<span class="comment">// 1. 保存 raft 日志条目</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> entries &#123;</span><br><span class="line">		key := meta.RaftLogKey(ps.region.Id, v.Index)</span><br><span class="line">		err = raftWB.SetMeta(key, &amp;v)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2. 更新 raftState（hardState 的更新在外头）</span></span><br><span class="line">	thisLastIndex := entries[<span class="built_in">len</span>(entries)<span class="number">-1</span>].Index</span><br><span class="line">	ps.raftState.LastTerm = entries[<span class="built_in">len</span>(entries)<span class="number">-1</span>].Term</span><br><span class="line">	ps.raftState.LastIndex = thisLastIndex</span><br><span class="line">	<span class="comment">// 3. 删除不会被提交的条目（比如自己 stabled 的日志被 leader 给删了）</span></span><br><span class="line">	<span class="keyword">for</span> i := thisLastIndex + <span class="number">1</span>; i &lt;= prevLastIndex; i++ &#123;</span><br><span class="line">		key := meta.RaftLogKey(ps.region.Id, i)</span><br><span class="line">		raftWB.DeleteMeta(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据测试，不在这里写入</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个 peer_storage_test.go 测试文件，可以用来辅助测一下 append 函数。</p>
<h4 id="firstIndex-不从-0-开始"><a href="#firstIndex-不从-0-开始" class="headerlink" title="firstIndex 不从 0 开始"></a>firstIndex 不从 0 开始</h4><p>打印了日志以后发现，firstIndex 从 5 开始，其实文档里面有说 Note that the value of both RAFT_INIT_LOG_TERM and RAFT_INIT_LOG_INDEX is 5。这样的话，我原本 RaftLog 里面没有日志的时候 lastIndex 返回的是 0，现在看来应该返回的是 firstIndex - 1。对应的 Term 也要从 storage 里头取了。</p>
<p>做到这里还返回去改造了 Raft 和 RaftLog，感觉以后还要接着改造，，</p>
<h4 id="peers-错误"><a href="#peers-错误" class="headerlink" title="peers 错误"></a>peers 错误</h4><p>做 2b 的时候打日志调试，意外地发现遇到了所有人都是 leader 的诡异情况。打印构造情况，发现 c.peers 只有自己一个人，要从 confState 里面取。暂时还不清楚这个是干啥的，但是取了就可以了。</p>
<h4 id="莫名其妙的-fail"><a href="#莫名其妙的-fail" class="headerlink" title="莫名其妙的 fail"></a>莫名其妙的 fail</h4><p>第一次做 tinykv 的时候遇到过这种情况，tmpfs 是基于内存的，我的内存 16g 扛不住，kv&#x2F;test_raftstore&#x2F;cluster.go:61 里面把临时文件夹放在 ssd 里面，现在可以跑过了，但是要自己清空测试文件夹。</p>
<h4 id="getWrongValue-以及-CmdType-错误"><a href="#getWrongValue-以及-CmdType-错误" class="headerlink" title="getWrongValue 以及 CmdType 错误"></a>getWrongValue 以及 CmdType 错误</h4><p>也是打日志一通观察，发现这样的一个场景：</p>
<p>1 2 3 4 5，起初 2 为 term 6 leader，后来 1 2 | 3 4 5，4 为 term 7 leader。2 propose 了日志 a，4 propose 了日志 b，不幸地它们 index 相同<br>，4 的日志会覆盖 2 的，因此 2 apply 的时候也要检查 term，看记录 proposal 的时候和现在的日志的 term 是否一样。如果不检查 term，2 会 apply 4 的日志条目 b，但是回调 a，造成错误。</p>
<p>给 proposal 比对的时候加上 term，如果 term 和当前 term 不一样，就返回 StaleCommand。 </p>
<h4 id="从崩溃中恢复"><a href="#从崩溃中恢复" class="headerlink" title="从崩溃中恢复"></a>从崩溃中恢复</h4><p>在可能崩溃的测试中，出现了这样的问题：unexpected raft log index: lastIndex 5 &lt; appliedIndex 3359</p>
<p>一看就是持久化没做好，观察 panic 的地方，是 RaftLocalState 没有保存。一通断点调试，发现 RaftLocalState 我保存之前的时候是存的指针，修改的时候，指针指向的地方值会变，就没有保存好以前的 RaftLocalState。没想到给指针搞了，，，</p>
<p>测试的时候自己写一个 shell 脚本，连续跑测试很多次，会很有助于调试。因为 2b 开始不是跑一遍就能测出来的了。</p>
<h3 id="project-2c"><a href="#project-2c" class="headerlink" title="project 2c"></a>project 2c</h3><p>完成快照。比方说现在 1 2 3 4 5，5 号挂了很长时间，其他四个人都 apply 很多日志了，这时候 5 恢复，没有必要给他发送那么长的日志，直接给他发一条快照就好了。</p>
<p>实现快照需要稍微改造一下 raft 模块，然后在 2b 的基础上增加一些改动。</p>
<h4 id="RaftLog-的改动"><a href="#RaftLog-的改动" class="headerlink" title="RaftLog 的改动"></a>RaftLog 的改动</h4><p>我们引入一下 snapshotIndex snapshotTerm 的概念。2a 的 firstIndex 是第一条日志条目的 index，那 snapshotIndex 就是被归档不可用的最后一条日志条目的 index，初始化为 firstIndex - 1，对应的 Term 从 storage 中取得。</p>
<p>RaftLog 里面有一个 pendingSnapshot，名字顾名思义。因为它的存在，lastIndex() 什么的也要修改。比如一个新创建的 peer 被发送了 snapshot，我们就说这个 lastIndex 就是 pendingSnapshot 的 lastIndex，不能说是 0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RaftLog)</span></span> LastIndex() <span class="type">uint64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l.entries) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l.entries[<span class="built_in">len</span>(l.entries)<span class="number">-1</span>].Index</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l.pendingSnapshot != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l.pendingSnapshot.Metadata.Index</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l.snapshotIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用快照的时候，除了要设置各种 index，还要把现有的日志条目清空。因为应用快照就代表着完全接受快照：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RaftLog)</span></span> applySnapshot(snap *pb.Snapshot) &#123;</span><br><span class="line">	l.first = snap.Metadata.Index + <span class="number">1</span></span><br><span class="line">	l.applied = snap.Metadata.Index</span><br><span class="line">	l.committed = snap.Metadata.Index</span><br><span class="line">	l.stabled = snap.Metadata.Index</span><br><span class="line">	l.snapshotIndex = snap.Metadata.Index</span><br><span class="line">	l.snapshotTerm = snap.Metadata.Term</span><br><span class="line">	l.entries = <span class="literal">nil</span></span><br><span class="line">	l.pendingSnapshot = snap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 applySnapshot 名字其实起得不好，它不是发生在 apply 阶段的，而是 handleSnapshot 时候被调用的，就像 handleAppend 一样。</p>
<h4 id="raft-模块"><a href="#raft-模块" class="headerlink" title="raft 模块"></a>raft 模块</h4><p>需要明确一下，snapshot 的地位和 append heartbeat 的地位是一样的，都是 leader 宣示自己的领导地位，因此处理 snapshot 的时候也要和 append 一样处理任期和 state。</p>
<p>下面的代码比较清楚了，如果取得不到日志条目，就发送快照。因为取得快照是一个耗费时间的任务，可能暂时不可用，这样的话就跳过发送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> sendAppend(to <span class="type">uint64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	index := r.Prs[to].Next - <span class="number">1</span></span><br><span class="line">	term, err := r.RaftLog.Term(index)</span><br><span class="line">	<span class="keyword">if</span> r.Prs[to].Next &lt;= util.RaftInvalidIndex || err == ErrCompacted &#123; <span class="comment">// next 到达 0 直接快照</span></span><br><span class="line">		snap, err := r.RaftLog.getSnapshot()</span><br><span class="line">		<span class="keyword">if</span> err == ErrSnapshotTemporarilyUnavailable &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		m := pb.Message&#123;</span><br><span class="line">			MsgType:  pb.MessageType_MsgSnapshot,</span><br><span class="line">			To:       to,</span><br><span class="line">			From:     r.id,</span><br><span class="line">			Term:     r.Term,</span><br><span class="line">			Snapshot: &amp;snap,</span><br><span class="line">		&#125;</span><br><span class="line">		r.send(m)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 日志可以取得，发送 append</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理快照的时候要注意，忽略 commit 不能增加的快照，这个会被认为是过期的，但是也要返回给 leader 提示，让他以为是成功更新，不然 leader 一直收不到回复，就会一直发快照而卡死。不要忘记处理 Prs。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Raft)</span></span> handleSnapshot(m pb.Message) &#123;</span><br><span class="line">	<span class="comment">// Your Code Here (2C).</span></span><br><span class="line">	r.State = StateFollower</span><br><span class="line">	r.Lead = m.From</span><br><span class="line">	r.electionElapsed = <span class="number">0</span></span><br><span class="line">	r.leadTransferee = None</span><br><span class="line">	</span><br><span class="line">	snap := m.Snapshot</span><br><span class="line">	<span class="keyword">if</span> snap.Metadata.Index &lt;= r.RaftLog.committed &#123;</span><br><span class="line">		r.sendAppendResponse(m.From, <span class="literal">false</span>, snap.Metadata.Index)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.RaftLog.applySnapshot(snap)</span><br><span class="line">	</span><br><span class="line">	r.Prs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint64</span>]*Progress)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> snap.Metadata.ConfState.Nodes &#123;</span><br><span class="line">		<span class="keyword">if</span> v == r.id &#123;</span><br><span class="line">			r.Prs[v] = &amp;Progress&#123;</span><br><span class="line">				Match: r.RaftLog.LastIndex(),</span><br><span class="line">				Next:  r.RaftLog.LastIndex() + <span class="number">1</span>,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r.Prs[v] = &amp;Progress&#123;</span><br><span class="line">				Match: <span class="number">0</span>,</span><br><span class="line">				Next:  r.RaftLog.LastIndex() + <span class="number">1</span>,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r.sendAppendResponse(m.From, <span class="literal">false</span>, r.RaftLog.LastIndex())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peer-storage"><a href="#peer-storage" class="headerlink" title="peer_storage"></a>peer_storage</h4><p>RaftLog 接收到 Snapshot 以后，会体现在 Ready 中，目的是更新一下各种 State，在 SaveReadyState 中自然也要添加上这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> SaveReadyState(ready *raft.Ready) (*ApplySnapResult, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> applySnapResult *ApplySnapResult</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> !raft.IsEmptySnap(&amp;ready.Snapshot) &#123;</span><br><span class="line">		kvWb := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">		raftWb := &amp;engine_util.WriteBatch&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> applySnapResult, err = ps.ApplySnapshot(&amp;ready.Snapshot, kvWb, raftWb); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">        ps.Engines.WriteKV(kvWb)</span><br><span class="line">        ps.Engines.WriteRaft(raftWb)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> applySnapResult, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ApplySnapshot() 比较复杂，但是步骤也很清晰：</p>
<ol>
<li>删除旧信息。快照的应用让 Raft 日志条目等信息变得无用。不过，删除的时候要注意 ps.isInitialized() 才可以删除，不然会产生错误</li>
<li>更新 raftState、applyState、regionState。这是因为快照也可能包含新的 region 的信息</li>
<li>send <code>runner.RegionTaskApply</code> task to region worker through <code>PeerStorage.regionSched</code> and wait until region worker finishes.</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PeerStorage)</span></span> ApplySnapshot(snapshot *eraftpb.Snapshot, kvWB *engine_util.WriteBatch, raftWB *engine_util.WriteBatch) (*ApplySnapResult, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Infof(<span class="string">&quot;%v begin to apply snapshot&quot;</span>, ps.Tag)</span><br><span class="line">	snapData := <span class="built_in">new</span>(rspb.RaftSnapshotData)</span><br><span class="line">	<span class="keyword">if</span> err := snapData.Unmarshal(snapshot.Data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ps.isInitialized() &#123;</span><br><span class="line">		<span class="keyword">if</span> err := ps.clearMeta(kvWB, raftWB); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		ps.clearExtraData(snapData.Region)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ps.raftState = &amp;rspb.RaftLocalState&#123;</span><br><span class="line">		HardState: &amp;eraftpb.HardState&#123;</span><br><span class="line">			Term:   snapshot.Metadata.Term,</span><br><span class="line">			Vote:   ps.raftState.HardState.Vote,</span><br><span class="line">			Commit: snapshot.Metadata.Index,</span><br><span class="line">		&#125;,</span><br><span class="line">		LastIndex: snapshot.Metadata.Index,</span><br><span class="line">		LastTerm:  snapshot.Metadata.Term,</span><br><span class="line">	&#125;</span><br><span class="line">	ps.applyState = &amp;rspb.RaftApplyState&#123;</span><br><span class="line">		AppliedIndex: snapshot.Metadata.Index,</span><br><span class="line">		TruncatedState: &amp;rspb.RaftTruncatedState&#123;</span><br><span class="line">			Index: snapshot.Metadata.Index,</span><br><span class="line">			Term:  snapshot.Metadata.Term,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ps.snapState.StateType = snap.SnapState_Applying</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := kvWB.SetMeta(meta.ApplyStateKey(snapData.Region.Id), ps.applyState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := raftWB.SetMeta(meta.RaftStateKey(snapData.Region.Id), ps.raftState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	meta.WriteRegionState(kvWB, snapData.Region, rspb.PeerState_Normal)</span><br><span class="line"></span><br><span class="line">	notifier := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	ps.regionSched &lt;- &amp;runner.RegionTaskApply&#123; <span class="comment">// 这里应该使用指针，，，总之要和其他地方保持一致</span></span><br><span class="line">		RegionId: snapData.Region.Id,</span><br><span class="line">		Notifier: notifier,</span><br><span class="line">		SnapMeta: snapshot.Metadata,</span><br><span class="line">		StartKey: snapData.Region.StartKey,</span><br><span class="line">		EndKey:   snapData.Region.EndKey,</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-notifier</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;ApplySnapResult&#123;</span><br><span class="line">		PrevRegion: ps.region,</span><br><span class="line">		Region:     snapData.Region,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="peer-msg-handler"><a href="#peer-msg-handler" class="headerlink" title="peer_msg_handler"></a>peer_msg_handler</h4><p>快照消息的产生、发送、处理是在 raft 模块中的。在上层 peer_msg_handler，我们实际上处理的是压缩日志请求。不同于增删改查，这是一个 adminRequest，因此也要相应在 propose 的时候做出一些调整。</p>
<p>首先，AdminRequest 不会和普通 Request 一起出现；压缩日志请求没有回调，所以不需要处理 proposal 相关的逻辑。</p>
<p>同样地，在处理 Ready 的时候，我们也要处理一下 AdminRequest 了。对应的处理逻辑文档里写得很清楚了，这里粘贴一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *peerMsgHandler)</span></span> applyAdminRequest(msg *raft_cmdpb.RaftCmdRequest,</span><br><span class="line">	entry pb.Entry, kvWb *engine_util.WriteBatch) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> msg.AdminRequest.CmdType &#123;</span><br><span class="line">	<span class="keyword">case</span> raft_cmdpb.AdminCmdType_CompactLog:</span><br><span class="line">		compactLog := msg.AdminRequest.CompactLog</span><br><span class="line">		<span class="keyword">if</span> compactLog.CompactIndex &gt;= d.peerStorage.applyState.TruncatedState.Index &#123;</span><br><span class="line">			d.peerStorage.applyState.TruncatedState.Index = compactLog.CompactIndex</span><br><span class="line">			d.peerStorage.applyState.TruncatedState.Term = compactLog.CompactTerm</span><br><span class="line">			err := kvWb.SetMeta(meta.ApplyStateKey(d.regionId), d.peerStorage.applyState)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Panic(err)</span><br><span class="line">			&#125;</span><br><span class="line">			d.ScheduleCompactLog(compactLog.CompactIndex)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我的理解，ScheduleCompactLog 最终会导致 Storage 中的日志被压缩掉。因此要时不时压缩一下我们在内存中的 RaftLog 保存的日志，也就是 maybeCompact 函数（自己在 Rawnode 中调用它）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *RaftLog)</span></span> maybeCompact() &#123;</span><br><span class="line">	firstIndex, err := l.storage.FirstIndex()</span><br><span class="line">	snapshotTerm, err := l.storage.Term(firstIndex - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> firstIndex &gt; l.first &amp;&amp; firstIndex &lt;= l.LastIndex() &#123;</span><br><span class="line">		l.entries = l.entries[firstIndex-l.first:]</span><br><span class="line">		l.first = firstIndex</span><br><span class="line">		l.snapshotIndex = firstIndex - <span class="number">1</span></span><br><span class="line">		l.snapshotTerm = snapshotTerm</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 storage 里头不存日志条目了，那内存中也不存了。</p>
<h2 id="project-3"><a href="#project-3" class="headerlink" title="project 3"></a>project 3</h2><h3 id="project-3a"><a href="#project-3a" class="headerlink" title="project 3a"></a>project 3a</h3><p>实现领导人禅让（又叫转换），增加节点，删除节点。不难，但是可能会给 3b 埋坑，，，</p>
<h4 id="领导人禅让"><a href="#领导人禅让" class="headerlink" title="领导人禅让"></a>领导人禅让</h4><p>领导人禅让基本上也可以称为 local message，因为它不会被传播。把这条消息往下 step 的时候要注意： 如果自己不是 leader，就把消息转发给 leader</p>
<p>我们使用 leadTransferee &#x3D;&#x3D; 谁 来标记当前在试图禅让给谁，禅让的判定过程叫 handleTransferLeader(to uint64)，</p>
<ul>
<li>to 被删了、to 是自己，返回</li>
<li>更新领导人禅让计时器，记录 leadTransferee</li>
<li>检查 leadTransferee 日志情况。如果和自己日志一样新，就向他发送 MsgTimeoutNow，leadTransferee 收到以后会和收到 MsgHup 一样立刻开始选举</li>
<li>如果 leadTransferee 日志没自己新，就给他发 append</li>
</ul>
<p>与此同时，handleAppendResponse 里面，如果接收到来自 leadTransferee 的消息，就重新调用 handleTransferLeader 检查禅让情况</p>
<p>需要注意的事情：</p>
<ul>
<li>在领导人转换期间，禁止一切 propose。直接返回 ErrProposalDropped</li>
<li>如果 leadTransferee 挂了，就会导致领导人禅让计时器超时，这种情况下终止禅让，不然一直不能 propose</li>
</ul>
<h4 id="增删节点"><a href="#增删节点" class="headerlink" title="增删节点"></a>增删节点</h4><p>增加节点，就要更新 Prs，设置好它的 Match 和 Next（lastIndex + 1）。如果是 leader，可以考虑立刻广播心跳，因为 peer 的创建是根据消息的 to 不存在而创建的，这样可以尽快达成一致</p>
<p>删除节点，也要更新 Prs，也要尝试更新 commit 和广播 append</p>
<h3 id="project-3b"><a href="#project-3b" class="headerlink" title="project 3b"></a>project 3b</h3><p>如果说《春江花月夜》是诗中的诗，顶峰上的顶峰，那 3b 一定是 TinyKV 中的顶峰了，不论是它的抽象程度还是困难程度，还是找不到 bug 在哪里的痛苦，以及测试的耗时，，，做这一部分的时候要多参考参考其他人的文档，跟同学讨论讨论，上网搜索报错和 bug，时刻保持心态的平和。</p>
<p>3b 分为三部分，第一部分实现领导人转换，很简单不需要很多功夫，收到这个 adminRequest 的时候直接调用 RawNode 的相关方法然后返回就行，不需要 propose；第二部分实现配置变更；第三部分实现 multi-raft 的 region split</p>
<p>我跑了 28 次，有 4 次会 fail，每次 fail 一个点。</p>
<h4 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h4><p>配置变更也是作为 AdminRequest 来到 proposeRaftCommand 的，但是因为它比较特殊，不仅要通过 Raft 同步，还要修改 Prs，为了表示区分，它在日志条目中的 Type 为 EntryType_EntryConfChange，并且有一个专门的 ProposeConfChange(cc pb.ConfChange) 方法，因此，proposeRaftCommand 处理这个 AdminRequest 也稍微有一点变化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">context, err := msg.Marshal()</span><br><span class="line">changePeer := msg.AdminRequest.ChangePeer</span><br><span class="line">confChange := pb.ConfChange&#123;</span><br><span class="line">    ChangeType: changePeer.ChangeType,</span><br><span class="line">    NodeId:     changePeer.Peer.Id,</span><br><span class="line">    Context:    context,</span><br><span class="line">&#125;</span><br><span class="line">d.appendProposal(d.nextProposalIndex(), d.Term(), cb)</span><br><span class="line">err = d.RaftGroup.ProposeConfChange(confChange)</span><br></pre></td></tr></table></figure>

<p>把 msg 也传进去，因为后面可能要捞出来检查版本。</p>
<p>因为我们一次只处理一个节点变更，日志条目容不得两个节点变更的未 apply 日志存在，所以要用 pendingConfIndex 确保只有一个节点变更日志等待 apply</p>
<p>此后同样的步骤，我们首先把内容都取出来，检查 Region 版本是否匹配。如果不匹配，说明已经过时了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">confChange := &amp;pb.ConfChange&#123;&#125;</span><br><span class="line">err := confChange.Unmarshal(entry.Data)</span><br><span class="line">msg := &amp;raft_cmdpb.RaftCmdRequest&#123;&#125;</span><br><span class="line">err = msg.Unmarshal(confChange.Context)</span><br><span class="line"></span><br><span class="line">p := d.findProposal(entry.Index, entry.Term)</span><br><span class="line">err = util.CheckRegionEpoch(msg, d.Region(), <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        p.cb.Done(ErrResp(err))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">d.RaftGroup.ApplyConfChange(*confChange)</span><br></pre></td></tr></table></figure>

<p>接下来，如果是增加节点，我们就</p>
<ol>
<li>更新 region ConfVer</li>
<li>插入到 peer Cache 中</li>
<li>插入到 peer 数组中</li>
<li>写入 WriteBatch</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d.Region().RegionEpoch.ConfVer++</span><br><span class="line">d.insertPeerCache(msg.AdminRequest.ChangePeer.Peer)</span><br><span class="line">d.Region().Peers = <span class="built_in">append</span>(d.Region().Peers, msg.AdminRequest.ChangePeer.Peer)</span><br><span class="line">meta.WriteRegionState(kvWb, d.Region(), rspb.PeerState_Normal)</span><br></pre></td></tr></table></figure>

<p>如果是删除节点，则要分类讨论：删除自己就 destroyPeer()，删除别人使用和上面差不多的技法。</p>
<h4 id="region-split"><a href="#region-split" class="headerlink" title="region split"></a>region split</h4><p>split adminRequest 的地位和压缩日志一样，因此直到 apply 前，处理的方法都大差不差。</p>
<p>注意：引入 split 以后，get put delete 要检查 key 是否在 region 中。 split apply 的时候也要检查 key 是否在 region 中、版本对不对，步骤大概为：</p>
<ol>
<li>创建新 region</li>
<li>修改当前 region 的 Version，endKey，storeMeta（记得加锁）等等</li>
<li>使用 ReplaceOrInsert 更新 regionRanges，也写入 WriteBatch</li>
<li>在当前 store 创建 peer</li>
<li>向路由注册 peer</li>
<li>向新 region 发送 start</li>
<li>回调</li>
</ol>
<h4 id="meta-corruption-detected-问题"><a href="#meta-corruption-detected-问题" class="headerlink" title="meta corruption detected 问题"></a>meta corruption detected 问题</h4><p>我参考的 <a target="_blank" rel="noopener" href="https://github.com/LX-676655103/Tinykv-2021/blob/course/doc/project3.md%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E7%8E%B0%E6%98%AF%E5%9C%A8">https://github.com/LX-676655103/Tinykv-2021/blob/course/doc/project3.md，这个问题的出现是在</a> destroyPeer 中，meta.regionRanges.Delete(&amp;regionItem{region: d.Region()}) &#x3D;&#x3D; nil 导致的。删除为空，是因为新创建的 peer 没有插入到 regionRanges 中。因此要在 maybeCreatePeer() 最后面加一句 meta.regionRanges.ReplaceOrInsert(&amp;regionItem{region: peer.Region()})，这样就不会出现无效删除的问题了。</p>
<h4 id="增删节点导致的-request-timeout"><a href="#增删节点导致的-request-timeout" class="headerlink" title="增删节点导致的 request timeout"></a>增删节点导致的 request timeout</h4><p>我搜索到了这个问题 <a target="_blank" rel="noopener" href="https://asktug.com/t/topic/274196/1%EF%BC%8C%E8%A7%82%E5%AF%9F%E6%97%A5%E5%BF%97%E8%BF%98%E7%9C%9F%E6%98%AF%E8%BF%99%E6%A0%B7%E3%80%82%E6%AF%94%E6%96%B9%E8%AF%B4%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B">https://asktug.com/t/topic/274196/1，观察日志还真是这样。比方说最后剩下</a> 1 2，1 是 leader 要删除自己，1 send append to 2, 2 send appendResponse to 1, 1 update commit and destroy itself。考虑到 commit 更新了，1 要发给 2 commit 更新的消息，但是<strong>如果这条消息不幸被 drop 掉</strong>，2 就不知道 1 给删除了！！！此时，2 一直不知道 1 给删除了，试图发起投票，当然是无尽的失败。</p>
<p>我也用的邪道，在 handleAppendResponse 里面，如果要更新 commit 广播 append，就把 append 连续广播五遍，减少消息丢失的可能性，，，但是这样挺不优雅的</p>
<h4 id="proposal-导致的-request-timeout"><a href="#proposal-导致的-request-timeout" class="headerlink" title="proposal 导致的 request timeout"></a>proposal 导致的 request timeout</h4><p>原来我对 proposal 处理得比较粗浅，打印出来发现它不是单调的，使用了 append rpc 类似的方法来确保它单调。但是还是有很小的概率不单调，可能是并发操作吧。</p>
<h4 id="storeMeta-导致的-request-timeout"><a href="#storeMeta-导致的-request-timeout" class="headerlink" title="storeMeta 导致的 request timeout"></a>storeMeta 导致的 request timeout</h4><p>我发现在增删节点的时候加锁修改 storeMeta 容易增加超时几率，很迷惑，暂时不太会改，只能在这里不修改它了。<br>参考了，不过没有用 <a target="_blank" rel="noopener" href="https://asktug.com/t/topic/274160">https://asktug.com/t/topic/274160</a></p>
<h4 id="no-region-问题"><a href="#no-region-问题" class="headerlink" title="no region 问题"></a>no region 问题</h4><p>参考了 <a target="_blank" rel="noopener" href="https://github.com/Smith-Cruise/TinyKV-White-Paper/blob/main/Project3-MultiRaftKV.md">https://github.com/Smith-Cruise/TinyKV-White-Paper/blob/main/Project3-MultiRaftKV.md</a> 增加了一个方法，快速刷新 scheduler 的缓存，有效避免了 no region 问题。</p>
<h3 id="project-3c"><a href="#project-3c" class="headerlink" title="project 3c"></a>project 3c</h3><p>完善调度器。这是一个独立的部分，可以喘一口气了，但是也要多跑几遍。</p>
<p>第一个要求是实现对 region 心跳的处理，在 scheduler&#x2F;server&#x2F;cluster.go 中的 processHeartBeat()。</p>
<p>首先写一个比较 region 谁更新的函数，先比较 Version 再比较 ConfVer</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">regionANewerThanB</span><span class="params">(a *metapb.Region, b *metapb.Region)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a.GetRegionEpoch().GetVersion() != b.GetRegionEpoch().GetVersion() &#123;</span><br><span class="line">		<span class="keyword">return</span> a.GetRegionEpoch().GetVersion() &gt; b.GetRegionEpoch().GetVersion()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.GetRegionEpoch().GetConfVer() &gt; b.GetRegionEpoch().GetConfVer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里要使用 Get 方法，因为可能有 nil，，，</p>
<p>然后检查心跳是否可以接受，首先检查同 id 的 region 谁更新，然后检查和 heartbeart region 重叠的 region，新 region 要都比他们新。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reg, _ := c.GetRegionByID(region.GetID()); reg != <span class="literal">nil</span> &amp;&amp; regionANewerThanB(reg, region.GetMeta()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrRegionIsStale(region.GetMeta(), reg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> c.ScanRegions(region.GetStartKey(), region.GetEndKey(), <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> regionANewerThanB(v.GetMeta(), region.GetMeta()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrRegionIsStale(region.GetMeta(), v.GetMeta())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以调用 PutRegion() 和 updateStoreStatusLocked()（这个函数更简单）来更新 region 情况了。</p>
<p>第二部分是选择一个 store，将 region 从这个 store 迁移到另一个 store。在 scheduler&#x2F;server&#x2F;schedulers&#x2F;balance_region.go </p>
<ol>
<li>取出所有 IsUp() 并且 DownTime 合格的 store，把他们按照 regionSize 从大到小排序</li>
<li>依次考察 store，对于每个 store<ol>
<li>试图选择一个 pendingRegion</li>
<li>选不到就试图选择一个 followerRegion</li>
<li>选不到就试图选择一个 leaderRegion</li>
<li>还选不到就考察下一个 store</li>
</ol>
</li>
<li>现在我们得到了要迁移的 region 和它的 store</li>
<li>检查 region 的 store 数量，没有超过 cluster.GetMaxReplicas() 的话，就返回。因为他可以直接创建一个 peer，而不是迁移</li>
<li>取得一个目标 store，要求 regionSize 尽量小，且不在 region 原来的 store 中</li>
<li>要求 store size 差比较大，这样迁移才有意义，也就是要 <code>region.GetApproximateSize() &lt; 2*(fromStore.GetRegionSize()-toStore.GetRegionSize())</code></li>
<li>AllocPeer, CreateMovePeerOperator</li>
</ol>
<h2 id="project-4"><a href="#project-4" class="headerlink" title="project 4"></a>project 4</h2><h3 id="4a"><a href="#4a" class="headerlink" title="4a"></a>4a</h3><p>实现一个 MvccTxn，辅助后面的实现。</p>
<p>column family 派上用场。</p>
<ul>
<li>CFLock 对应 Lock，写 key 没有 timestamp，在 value（lock 结构体）里面保存 Lock 的 startTs</li>
<li>CFDefault 对应 value，写 key 包含 startTs</li>
<li>CFWrite 对应 Write，写 key 包含 commitTs，在 value（write 结构体）里面保存 Write 的 startTs</li>
</ul>
<p>PutWrite GetLock PutLock DeleteLock DeleteValue 都比较直观（注意没有 DeleteWrite）</p>
<p>Write 的 Get 方法有两个，CurrentWrite 从 EncodeKey(key, TsMax) 开始遍历，遍历趋势是同 key 的 commitTs 变小，然后到不同 key。把 startTs 取出来，startTs 要和 txn.StartTs 相同，才是当前事务的 Write；MostRecentWrite 也是要 seek 一下，能找到同 key 的就返回了。</p>
<p>GetValue 要取得在 txn.StartTs 这一刻有效的 Value，因此从 EncodeKey(key, TsMax) 找最新 Write，如果 WriteKind 为 Delete 就返回 nil，否则就取出这个 Write 的 startTs 在 CFDefault 中的值（其实我有点疑惑这里不用考虑 WriteKind 为 rollback 吗）</p>
<h3 id="project-4b-4c"><a href="#project-4b-4c" class="headerlink" title="project 4b 4c"></a>project 4b 4c</h3><p>在 kv&#x2F;server&#x2F;server.go 中实现 KvGet KvPreWrite KvCommit，使用上面的 MvccTxn。</p>
<p>Percolator 事务基本形状：</p>
<ol>
<li>Prewrite。对于每一个 key，检查错误，有的话返回所有错误，没有的话 apply txn.Writes()<ol>
<li>检查 MostRecentWrite，有没有 commitTs &gt;&#x3D; txn.StartTs 的 write 的？有的话记录 Write 冲突</li>
<li>检查 Lock，有不是自己的 lock（lock StartTs 对不上），记录已经被锁</li>
<li>现在这个 key 没有问题了</li>
<li>给这个 key 加上锁</li>
<li>写入 value 到 CFDefault 中（写入 Value 发生在 PreWrite 阶段！！）</li>
</ol>
</li>
<li>CheckTxnStatus，以 primary key 为准<ol>
<li>检查 lock 情况，如果没 lock 或者不是自己的 lock，就检查 CurrentWrite<ol>
<li>write !&#x3D; nil，那说明事务已经执行。通过 write 的 Kind 来设置 resp 的 commitVersion</li>
<li>write &#x3D;&#x3D; nil，事务不行了，向 Write 中写入 WriteKind_ROLLBACK（这里不用删除 Value，删除 value 是在 rollback）</li>
</ol>
</li>
<li>自己的 Lock 还在，但是 lock 超时了，就向 Write 中写入 WriteKind_ROLLBACK，删 lock，删 Value</li>
<li>事务没问题，返回</li>
</ol>
</li>
<li>Commit 首先使用 Latch 对 keys 统一加锁，然后对于每个 key<ol>
<li>取 lock，如果没 lock，取得 CurrentWrite，如果已经提交就忽略，其他情况报错</li>
<li>不是自己的 lock，返回错误（可以重试）</li>
<li>写入 write</li>
</ol>
</li>
<li>Rollback 也差不多，先统一加锁，然后对于每一个 key<ol>
<li>取 CurrentWrite，已经回滚就 continue，其他情况就 Abort</li>
<li>写入 write</li>
<li>如果自己 lock 着，就删除 value 和 lock</li>
</ol>
</li>
<li>KvResolveLock 就是取得当前 txn.StartTs 的所有 lock，根据 commitVersion 决定是提交还是回滚</li>
<li>KvGet 的时候可以使用 <code>lock.IsLockedFor(req.Key, txn.StartTS, resp)</code> 来检测 lock 冲突，还会自动设置 resp 的 Error 字段，很方便。简单来说就是如果 lock 不是自己的就报错，不然就 GetValue 返回去</li>
<li>KvScan 也差不多，就是要自己实现 Scanner，确保对于每一个 key 都返回一个 value，下次就是另一个 key</li>
</ol>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2024-05-28</p></div> 
    <div class="post-entry__tags"><a href="/tags/Raft/" class="post-tags__link button"># Raft</a><a href="/tags/TinyKV/" class="post-tags__link button"># TinyKV</a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="post-tags__link button"># 分布式</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2022/08/19/english/xuanyuanyou-english/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            旋元祐英语语法链接
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2022/07/03/tinykv/raft/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            Raft 学习笔记与资料摘编
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2017&nbsp;-&nbsp;2024 <a href="/">怀中落霞</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 


    <script>
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
                loader: {
                    source: {
                        '[tex]/amsCd': '[tex]/amscd',
                        '[tex]/AMScd': '[tex]/amscd'
                    }
                },
                tex: {
                    inlineMath: {'[+]': [['$', '$']]},
                    tags: 'ams'
                },
                options: {
                    renderActions: {
                        findScript: [10, doc => {
                            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                                const display = !!node.type.match(/; *mode=display/);
                                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                                const text = document.createTextNode('');
                                node.parentNode.replaceChild(text, node);
                                math.start = {node: text, delim: '', n: 0};
                                math.end = {node: text, delim: '', n: 0};
                                doc.math.push(math);
                            });
                        }, '', false],
                        insertedScript: [200, () => {
                            document.querySelectorAll('mjx-container').forEach(node => {
                                let target = node.parentNode;
                                if (target.nodeName.toLowerCase() === 'li') {
                                    target.parentNode.classList.add('has-jax');
                                }
                            });
                        }, '', false]
                    }
                }
            };
            (function () {
                var script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
                script.defer = true;
                document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    </script>

 

 

 

 




    </body>
</html>
